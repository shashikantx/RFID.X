CCS PCM C Compiler, Version 5.078, 43599               19-Feb-19 00:51

               Filename:   C:\Users\Shashikant\Documents\GitHub\RFID.X\main.lst

               ROM used:   3967 words (48%)
                           Largest free fragment is 2048
               RAM used:   139 (38%) at main() level
                           202 (55%) worst case
               Stack used: 5 locations
               Stack size: 8

*
0000:  MOVLW  0E
0001:  MOVWF  0A
0002:  GOTO   600
0003:  NOP
.................... /*  
....................  * File:   main.c 
....................  * Author: Shashikant 
....................  * 
....................  * Created on 2 July, 2018, 12:43 PM 
....................  */ 
....................  
.................... //Options 
.................... #include <16F877A.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
0004:  DATA 0C,10
0005:  DATA 43,34
0006:  DATA E5,31
0007:  DATA EB,34
0008:  DATA EE,33
0009:  DATA 20,29
000A:  DATA C6,24
000B:  DATA 44,17
000C:  DATA 2E,17
000D:  DATA 00,00
000E:  DATA 0D,05
000F:  DATA 43,34
0010:  DATA E5,31
0011:  DATA EB,34
0012:  DATA EE,33
0013:  DATA A0,24
0014:  DATA 66,10
0015:  DATA 52,33
0016:  DATA 69,32
0017:  DATA A0,24
0018:  DATA 73,10
0019:  DATA C3,37
001A:  DATA 6E,37
001B:  DATA E5,31
001C:  DATA F4,32
001D:  DATA 64,00
001E:  DATA 0C,10
001F:  DATA 52,23
0020:  DATA 49,22
0021:  DATA 20,27
0022:  DATA 6F,3A
0023:  DATA 20,23
0024:  DATA EF,3A
0025:  DATA 6E,32
0026:  DATA 20,05
0027:  DATA A0,21
0028:  DATA E8,32
0029:  DATA E3,35
002A:  DATA A0,20
002B:  DATA E7,30
002C:  DATA 69,37
002D:  DATA 2E,17
002E:  DATA 00,01
002F:  DATA 0D,05
0030:  DATA 52,23
0031:  DATA 49,22
0032:  DATA 20,24
0033:  DATA 77,10
0034:  DATA EE,37
0035:  DATA 74,10
0036:  DATA C6,37
0037:  DATA 75,37
0038:  DATA 64,00
0039:  DATA 0C,10
003A:  DATA 52,23
003B:  DATA 49,22
003C:  DATA 20,23
003D:  DATA EF,3A
003E:  DATA 6E,32
003F:  DATA 00,01
0040:  DATA 0A,2B
0041:  DATA 3A,10
0042:  DATA 25,3C
0043:  DATA 00,00
0044:  DATA 0D,05
0045:  DATA 52,23
0046:  DATA 49,22
0047:  DATA 20,23
0048:  DATA EF,3A
0049:  DATA 6E,32
004A:  DATA A0,30
004B:  DATA 6E,32
004C:  DATA 20,24
004D:  DATA 57,10
004E:  DATA F6,32
004F:  DATA F2,39
0050:  DATA E9,37
0051:  DATA 6E,10
0052:  DATA E9,39
0053:  DATA 3A,10
0054:  DATA 30,3C
0055:  DATA 25,19
0056:  DATA D8,06
0057:  DATA 0A,00
0058:  DATA C1,3A
0059:  DATA 74,34
005A:  DATA 65,37
005B:  DATA F4,34
005C:  DATA E3,30
005D:  DATA F4,32
005E:  DATA 64,10
005F:  DATA 62,36
0060:  DATA EF,31
0061:  DATA 6B,10
0062:  DATA 30,3C
0063:  DATA 25,19
0064:  DATA 58,10
0065:  DATA F7,34
0066:  DATA 74,34
0067:  DATA A0,20
0068:  DATA 0D,05
0069:  DATA 00,01
006A:  DATA D2,32
006B:  DATA 61,32
006C:  DATA 20,33
006D:  DATA E1,34
006E:  DATA EC,32
006F:  DATA E4,06
0070:  DATA 0A,00
0071:  DATA C1,3A
0072:  DATA 74,34
0073:  DATA 65,37
0074:  DATA F4,34
0075:  DATA E3,30
0076:  DATA F4,32
0077:  DATA 64,10
0078:  DATA 62,36
0079:  DATA EF,31
007A:  DATA 6B,10
007B:  DATA 30,3C
007C:  DATA 25,19
007D:  DATA 58,10
007E:  DATA F7,34
007F:  DATA 74,34
0080:  DATA A0,35
0081:  DATA E5,3C
0082:  DATA 20,21
0083:  DATA 00,01
0084:  DATA D2,32
0085:  DATA 61,32
0086:  DATA 20,33
0087:  DATA E1,34
0088:  DATA EC,32
0089:  DATA 64,10
008A:  DATA 0D,05
008B:  DATA 00,01
008C:  DATA C1,31
008D:  DATA E3,32
008E:  DATA F3,39
008F:  DATA 20,32
0090:  DATA 65,37
0091:  DATA E9,32
0092:  DATA 64,10
0093:  DATA 61,3A
0094:  DATA 20,31
0095:  DATA EC,37
0096:  DATA E3,35
0097:  DATA 20,18
0098:  DATA F8,12
0099:  DATA 32,2C
009A:  DATA 00,00
009B:  DATA C1,3A
009C:  DATA 74,34
009D:  DATA 65,37
009E:  DATA F4,34
009F:  DATA E3,30
00A0:  DATA F4,32
00A1:  DATA 64,10
00A2:  DATA 62,36
00A3:  DATA EF,31
00A4:  DATA 6B,10
00A5:  DATA 30,3C
00A6:  DATA 25,19
00A7:  DATA 58,10
00A8:  DATA F7,34
00A9:  DATA 74,34
00AA:  DATA A0,20
00AB:  DATA 0D,05
00AC:  DATA 00,01
00AD:  DATA D2,32
00AE:  DATA 61,32
00AF:  DATA 20,33
00B0:  DATA E1,34
00B1:  DATA EC,32
00B2:  DATA E4,06
00B3:  DATA 0A,00
00B4:  DATA C1,3A
00B5:  DATA 74,34
00B6:  DATA 65,37
00B7:  DATA F4,34
00B8:  DATA E3,30
00B9:  DATA F4,32
00BA:  DATA 64,10
00BB:  DATA 62,36
00BC:  DATA EF,31
00BD:  DATA 6B,10
00BE:  DATA 30,3C
00BF:  DATA 25,19
00C0:  DATA 58,10
00C1:  DATA F7,34
00C2:  DATA 74,34
00C3:  DATA A0,35
00C4:  DATA E5,3C
00C5:  DATA 20,21
00C6:  DATA 00,01
00C7:  DATA D2,32
00C8:  DATA 61,32
00C9:  DATA 20,33
00CA:  DATA E1,34
00CB:  DATA EC,32
00CC:  DATA 64,10
00CD:  DATA 0D,05
00CE:  DATA 00,01
00CF:  DATA C1,31
00D0:  DATA E3,32
00D1:  DATA F3,39
00D2:  DATA 20,32
00D3:  DATA 65,37
00D4:  DATA E9,32
00D5:  DATA 64,10
00D6:  DATA 61,3A
00D7:  DATA 20,31
00D8:  DATA EC,37
00D9:  DATA E3,35
00DA:  DATA 20,18
00DB:  DATA F8,12
00DC:  DATA 32,2C
00DD:  DATA 00,00
00DE:  DATA C1,3A
00DF:  DATA 74,34
00E0:  DATA 65,37
00E1:  DATA F4,34
00E2:  DATA E3,30
00E3:  DATA F4,32
00E4:  DATA 64,10
00E5:  DATA F7,34
00E6:  DATA 74,34
00E7:  DATA A0,35
00E8:  DATA E5,3C
00E9:  DATA A0,20
00EA:  DATA A0,06
00EB:  DATA 0A,00
00EC:  DATA 57,39
00ED:  DATA 69,3A
00EE:  DATA 65,10
00EF:  DATA D3,3A
00F0:  DATA E3,31
00F1:  DATA E5,39
00F2:  DATA 73,33
00F3:  DATA 75,36
00F4:  DATA 0D,05
00F5:  DATA 00,01
00F6:  DATA 57,39
00F7:  DATA 69,3A
00F8:  DATA 65,10
00F9:  DATA E6,30
00FA:  DATA 69,36
00FB:  DATA 65,32
00FC:  DATA 0D,05
00FD:  DATA 00,01
00FE:  DATA C1,3A
00FF:  DATA 74,34
0100:  DATA 65,37
0101:  DATA F4,34
0102:  DATA E3,30
0103:  DATA F4,32
0104:  DATA 64,10
0105:  DATA F7,34
0106:  DATA 74,34
0107:  DATA A0,35
0108:  DATA E5,3C
0109:  DATA 20,21
010A:  DATA A0,06
010B:  DATA 0A,00
010C:  DATA 57,39
010D:  DATA 69,3A
010E:  DATA 65,10
010F:  DATA D3,3A
0110:  DATA E3,31
0111:  DATA E5,39
0112:  DATA 73,33
0113:  DATA 75,36
0114:  DATA 0D,05
0115:  DATA 00,01
0116:  DATA 57,39
0117:  DATA 69,3A
0118:  DATA 65,10
0119:  DATA C6,30
011A:  DATA 69,36
011B:  DATA 65,32
011C:  DATA 00,01
011D:  DATA C3,37
011E:  DATA 75,36
011F:  DATA 64,37
0120:  DATA 27,3A
0121:  DATA A0,30
0122:  DATA E3,31
0123:  DATA E5,39
0124:  DATA 73,10
0125:  DATA 62,36
0126:  DATA EF,31
0127:  DATA 6B,10
0128:  DATA 30,3C
0129:  DATA 25,2C
012A:  DATA A0,3B
012B:  DATA F2,34
012C:  DATA F4,32
012D:  DATA 20,33
012E:  DATA E1,34
012F:  DATA EC,32
0130:  DATA 64,00
0131:  DATA 0C,10
0132:  DATA 53,3A
0133:  DATA 61,39
0134:  DATA F4,34
0135:  DATA EE,33
0136:  DATA 2E,17
0137:  DATA 2E,00
0138:  DATA 0D,05
0139:  DATA 73,3A
013A:  DATA 61,39
013B:  DATA F4,34
013C:  DATA EE,33
013D:  DATA 2E,17
013E:  DATA 00,01
013F:  DATA 0D,05
0140:  DATA C6,37
0141:  DATA 75,37
0142:  DATA 64,10
0143:  DATA D4,30
0144:  DATA 67,1D
0145:  DATA 20,00
0146:  DATA 0D,05
0147:  DATA D3,20
0148:  DATA 4B,1D
0149:  DATA 20,18
014A:  DATA F8,12
014B:  DATA 32,3C
014C:  DATA 00,01
014D:  DATA 0D,05
014E:  DATA 20,23
014F:  DATA E1,34
0150:  DATA EC,32
0151:  DATA 64,10
0152:  DATA F4,37
0153:  DATA 20,39
0154:  DATA E5,30
0155:  DATA 64,10
0156:  DATA E3,30
0157:  DATA 72,32
0158:  DATA 00,01
0159:  DATA 0D,05
015A:  DATA A0,24
015B:  DATA EE,31
015C:  DATA EF,36
015D:  DATA 70,36
015E:  DATA 65,3A
015F:  DATA 65,10
0160:  DATA D5,24
0161:  DATA 44,00
0162:  DATA 0D,05
0163:  DATA A0,24
0164:  DATA 73,10
0165:  DATA 61,10
0166:  DATA CD,34
0167:  DATA E6,30
0168:  DATA F2,32
0169:  DATA A0,21
016A:  DATA 61,39
016B:  DATA 64,00
*
02EF:  MOVF   0B,W
02F0:  BSF    03.5
02F1:  MOVWF  52
02F2:  BCF    03.5
02F3:  BCF    0B.7
02F4:  BSF    03.5
02F5:  BSF    03.6
02F6:  BSF    0C.7
02F7:  BSF    0C.0
02F8:  NOP
02F9:  NOP
02FA:  BCF    03.6
02FB:  BTFSS  52.7
02FC:  GOTO   300
02FD:  BCF    03.5
02FE:  BSF    0B.7
02FF:  BSF    03.5
0300:  BCF    03.5
0301:  BSF    03.6
0302:  MOVF   0C,W
0303:  ANDLW  7F
0304:  BTFSC  03.2
0305:  GOTO   361
0306:  BSF    03.5
0307:  BCF    03.6
0308:  MOVWF  52
0309:  BCF    03.5
030A:  BSF    03.6
030B:  MOVF   0D,W
030C:  BSF    03.5
030D:  BCF    03.6
030E:  MOVWF  53
030F:  BCF    03.5
0310:  BSF    03.6
0311:  MOVF   0F,W
0312:  BSF    03.5
0313:  BCF    03.6
0314:  MOVWF  54
0315:  MOVF   52,W
0316:  MOVWF  56
0317:  BCF    03.5
0318:  CALL   2B5
0319:  BSF    03.5
031A:  MOVF   53,W
031B:  BCF    03.5
031C:  BSF    03.6
031D:  MOVWF  0D
031E:  BSF    03.5
031F:  BCF    03.6
0320:  MOVF   54,W
0321:  BCF    03.5
0322:  BSF    03.6
0323:  MOVWF  0F
0324:  BCF    03.6
0325:  MOVF   0B,W
0326:  BSF    03.5
0327:  MOVWF  55
0328:  BCF    03.5
0329:  BCF    0B.7
032A:  BSF    03.5
032B:  BSF    03.6
032C:  BSF    0C.7
032D:  BSF    0C.0
032E:  NOP
032F:  NOP
0330:  BCF    03.6
0331:  BTFSS  55.7
0332:  GOTO   336
0333:  BCF    03.5
0334:  BSF    0B.7
0335:  BSF    03.5
0336:  BCF    03.5
0337:  BSF    03.6
0338:  RLF    0C,W
0339:  RLF    0E,W
033A:  ANDLW  7F
033B:  BTFSC  03.2
033C:  GOTO   361
033D:  BSF    03.5
033E:  BCF    03.6
033F:  MOVWF  52
0340:  BCF    03.5
0341:  BSF    03.6
0342:  MOVF   0D,W
0343:  BSF    03.5
0344:  BCF    03.6
0345:  MOVWF  53
0346:  BCF    03.5
0347:  BSF    03.6
0348:  MOVF   0F,W
0349:  BSF    03.5
034A:  BCF    03.6
034B:  MOVWF  54
034C:  MOVF   52,W
034D:  MOVWF  56
034E:  BCF    03.5
034F:  CALL   2B5
0350:  BSF    03.5
0351:  MOVF   53,W
0352:  BCF    03.5
0353:  BSF    03.6
0354:  MOVWF  0D
0355:  BSF    03.5
0356:  BCF    03.6
0357:  MOVF   54,W
0358:  BCF    03.5
0359:  BSF    03.6
035A:  MOVWF  0F
035B:  INCF   0D,F
035C:  BTFSC  03.2
035D:  INCF   0F,F
035E:  BCF    03.6
035F:  GOTO   2EF
0360:  BSF    03.6
0361:  BCF    03.6
0362:  RETURN
0363:  MOVF   0B,W
0364:  BSF    03.5
0365:  MOVWF  65
0366:  BCF    03.5
0367:  BCF    0B.7
0368:  BSF    03.5
0369:  BSF    03.6
036A:  BSF    0C.7
036B:  BSF    0C.0
036C:  NOP
036D:  NOP
036E:  BCF    03.6
036F:  BTFSS  65.7
0370:  GOTO   374
0371:  BCF    03.5
0372:  BSF    0B.7
0373:  BSF    03.5
0374:  BCF    03.5
0375:  BSF    03.6
0376:  MOVF   0C,W
0377:  ANDLW  7F
0378:  BTFSC  03.2
0379:  GOTO   3D7
037A:  BSF    03.5
037B:  BCF    03.6
037C:  MOVWF  65
037D:  BCF    03.5
037E:  BSF    03.6
037F:  MOVF   0D,W
0380:  BSF    03.5
0381:  BCF    03.6
0382:  MOVWF  66
0383:  BCF    03.5
0384:  BSF    03.6
0385:  MOVF   0F,W
0386:  BSF    03.5
0387:  BCF    03.6
0388:  MOVWF  67
0389:  MOVF   65,W
038A:  BCF    03.5
038B:  BTFSS  0C.4
038C:  GOTO   38B
038D:  MOVWF  19
038E:  BSF    03.5
038F:  MOVF   66,W
0390:  BCF    03.5
0391:  BSF    03.6
0392:  MOVWF  0D
0393:  BSF    03.5
0394:  BCF    03.6
0395:  MOVF   67,W
0396:  BCF    03.5
0397:  BSF    03.6
0398:  MOVWF  0F
0399:  BCF    03.6
039A:  MOVF   0B,W
039B:  BSF    03.5
039C:  MOVWF  68
039D:  BCF    03.5
039E:  BCF    0B.7
039F:  BSF    03.5
03A0:  BSF    03.6
03A1:  BSF    0C.7
03A2:  BSF    0C.0
03A3:  NOP
03A4:  NOP
03A5:  BCF    03.6
03A6:  BTFSS  68.7
03A7:  GOTO   3AB
03A8:  BCF    03.5
03A9:  BSF    0B.7
03AA:  BSF    03.5
03AB:  BCF    03.5
03AC:  BSF    03.6
03AD:  RLF    0C,W
03AE:  RLF    0E,W
03AF:  ANDLW  7F
03B0:  BTFSC  03.2
03B1:  GOTO   3D7
03B2:  BSF    03.5
03B3:  BCF    03.6
03B4:  MOVWF  65
03B5:  BCF    03.5
03B6:  BSF    03.6
03B7:  MOVF   0D,W
03B8:  BSF    03.5
03B9:  BCF    03.6
03BA:  MOVWF  66
03BB:  BCF    03.5
03BC:  BSF    03.6
03BD:  MOVF   0F,W
03BE:  BSF    03.5
03BF:  BCF    03.6
03C0:  MOVWF  67
03C1:  MOVF   65,W
03C2:  BCF    03.5
03C3:  BTFSS  0C.4
03C4:  GOTO   3C3
03C5:  MOVWF  19
03C6:  BSF    03.5
03C7:  MOVF   66,W
03C8:  BCF    03.5
03C9:  BSF    03.6
03CA:  MOVWF  0D
03CB:  BSF    03.5
03CC:  BCF    03.6
03CD:  MOVF   67,W
03CE:  BCF    03.5
03CF:  BSF    03.6
03D0:  MOVWF  0F
03D1:  INCF   0D,F
03D2:  BTFSC  03.2
03D3:  INCF   0F,F
03D4:  BCF    03.6
03D5:  GOTO   363
03D6:  BSF    03.6
03D7:  BCF    03.6
03D8:  RETURN
*
0496:  MOVF   0B,W
0497:  BSF    03.5
0498:  MOVWF  66
0499:  BCF    03.5
049A:  BCF    0B.7
049B:  BSF    03.5
049C:  BSF    03.6
049D:  BSF    0C.7
049E:  BSF    0C.0
049F:  NOP
04A0:  NOP
04A1:  BCF    03.6
04A2:  BTFSS  66.7
04A3:  GOTO   4A7
04A4:  BCF    03.5
04A5:  BSF    0B.7
04A6:  BSF    03.5
04A7:  BTFSC  03.0
04A8:  GOTO   4E1
04A9:  BCF    03.5
04AA:  BSF    03.6
04AB:  MOVF   0C,W
04AC:  ANDLW  7F
04AD:  BSF    03.5
04AE:  BCF    03.6
04AF:  MOVWF  66
04B0:  BCF    03.5
04B1:  BSF    03.6
04B2:  MOVF   0D,W
04B3:  BSF    03.5
04B4:  BCF    03.6
04B5:  MOVWF  67
04B6:  BCF    03.5
04B7:  BSF    03.6
04B8:  MOVF   0F,W
04B9:  BSF    03.5
04BA:  BCF    03.6
04BB:  MOVWF  68
04BC:  MOVF   66,W
04BD:  BCF    03.5
04BE:  BTFSS  0C.4
04BF:  GOTO   4BE
04C0:  MOVWF  19
04C1:  BSF    03.5
04C2:  MOVF   67,W
04C3:  BCF    03.5
04C4:  BSF    03.6
04C5:  MOVWF  0D
04C6:  BSF    03.5
04C7:  BCF    03.6
04C8:  MOVF   68,W
04C9:  BCF    03.5
04CA:  BSF    03.6
04CB:  MOVWF  0F
04CC:  BCF    03.6
04CD:  MOVF   0B,W
04CE:  BSF    03.5
04CF:  MOVWF  69
04D0:  BCF    03.5
04D1:  BCF    0B.7
04D2:  BSF    03.5
04D3:  BSF    03.6
04D4:  BSF    0C.7
04D5:  BSF    0C.0
04D6:  NOP
04D7:  NOP
04D8:  BCF    03.6
04D9:  BTFSS  69.7
04DA:  GOTO   4DE
04DB:  BCF    03.5
04DC:  BSF    0B.7
04DD:  BSF    03.5
04DE:  DECFSZ 65,F
04DF:  GOTO   4E1
04E0:  GOTO   510
04E1:  BCF    03.5
04E2:  BSF    03.6
04E3:  RLF    0C,W
04E4:  RLF    0E,W
04E5:  ANDLW  7F
04E6:  BSF    03.5
04E7:  BCF    03.6
04E8:  MOVWF  66
04E9:  BCF    03.5
04EA:  BSF    03.6
04EB:  MOVF   0D,W
04EC:  BSF    03.5
04ED:  BCF    03.6
04EE:  MOVWF  67
04EF:  BCF    03.5
04F0:  BSF    03.6
04F1:  MOVF   0F,W
04F2:  BSF    03.5
04F3:  BCF    03.6
04F4:  MOVWF  68
04F5:  MOVF   66,W
04F6:  BCF    03.5
04F7:  BTFSS  0C.4
04F8:  GOTO   4F7
04F9:  MOVWF  19
04FA:  BSF    03.5
04FB:  MOVF   67,W
04FC:  BCF    03.5
04FD:  BSF    03.6
04FE:  MOVWF  0D
04FF:  BSF    03.5
0500:  BCF    03.6
0501:  MOVF   68,W
0502:  BCF    03.5
0503:  BSF    03.6
0504:  MOVWF  0F
0505:  INCF   0D,F
0506:  BTFSC  03.2
0507:  INCF   0F,F
0508:  BCF    03.0
0509:  BSF    03.5
050A:  BCF    03.6
050B:  DECFSZ 65,F
050C:  GOTO   50E
050D:  GOTO   510
050E:  BCF    03.5
050F:  GOTO   496
0510:  BCF    03.5
0511:  RETURN
0512:  BSF    03.5
0513:  BTFSC  66.7
0514:  GOTO   528
0515:  MOVLW  0F
0516:  MOVWF  77
0517:  SWAPF  65,W
0518:  ANDWF  77,F
0519:  MOVLW  0A
051A:  SUBWF  77,W
051B:  BTFSC  03.0
051C:  GOTO   520
051D:  MOVLW  30
051E:  ADDWF  77,F
051F:  GOTO   522
0520:  MOVF   66,W
0521:  ADDWF  77,F
0522:  MOVF   77,W
0523:  BCF    03.5
0524:  BTFSS  0C.4
0525:  GOTO   524
0526:  MOVWF  19
0527:  BSF    03.5
0528:  MOVLW  0F
0529:  ANDWF  65,F
052A:  MOVLW  0A
052B:  SUBWF  65,W
052C:  BTFSC  03.0
052D:  GOTO   530
052E:  MOVLW  30
052F:  GOTO   532
0530:  BCF    66.7
0531:  MOVF   66,W
0532:  ADDWF  65,F
0533:  MOVF   65,W
0534:  BCF    03.5
0535:  BTFSS  0C.4
0536:  GOTO   535
0537:  MOVWF  19
0538:  RETURN
*
0589:  BCF    03.5
058A:  MOVF   0B,W
058B:  BSF    03.5
058C:  MOVWF  53
058D:  BCF    03.5
058E:  BCF    0B.7
058F:  BSF    03.5
0590:  BSF    03.6
0591:  BSF    0C.7
0592:  BSF    0C.0
0593:  NOP
0594:  NOP
0595:  BCF    03.6
0596:  BTFSS  53.7
0597:  GOTO   59B
0598:  BCF    03.5
0599:  BSF    0B.7
059A:  BSF    03.5
059B:  BTFSC  03.0
059C:  GOTO   5D4
059D:  BCF    03.5
059E:  BSF    03.6
059F:  MOVF   0C,W
05A0:  ANDLW  7F
05A1:  BSF    03.5
05A2:  BCF    03.6
05A3:  MOVWF  53
05A4:  BCF    03.5
05A5:  BSF    03.6
05A6:  MOVF   0D,W
05A7:  BSF    03.5
05A8:  BCF    03.6
05A9:  MOVWF  54
05AA:  BCF    03.5
05AB:  BSF    03.6
05AC:  MOVF   0F,W
05AD:  BSF    03.5
05AE:  BCF    03.6
05AF:  MOVWF  55
05B0:  MOVF   53,W
05B1:  MOVWF  56
05B2:  BCF    03.5
05B3:  CALL   2B5
05B4:  BSF    03.5
05B5:  MOVF   54,W
05B6:  BCF    03.5
05B7:  BSF    03.6
05B8:  MOVWF  0D
05B9:  BSF    03.5
05BA:  BCF    03.6
05BB:  MOVF   55,W
05BC:  BCF    03.5
05BD:  BSF    03.6
05BE:  MOVWF  0F
05BF:  BCF    03.6
05C0:  MOVF   0B,W
05C1:  BSF    03.5
05C2:  MOVWF  56
05C3:  BCF    03.5
05C4:  BCF    0B.7
05C5:  BSF    03.5
05C6:  BSF    03.6
05C7:  BSF    0C.7
05C8:  BSF    0C.0
05C9:  NOP
05CA:  NOP
05CB:  BCF    03.6
05CC:  BTFSS  56.7
05CD:  GOTO   5D1
05CE:  BCF    03.5
05CF:  BSF    0B.7
05D0:  BSF    03.5
05D1:  DECFSZ 52,F
05D2:  GOTO   5D4
05D3:  GOTO   5FF
05D4:  BCF    03.5
05D5:  BSF    03.6
05D6:  RLF    0C,W
05D7:  RLF    0E,W
05D8:  ANDLW  7F
05D9:  BSF    03.5
05DA:  BCF    03.6
05DB:  MOVWF  53
05DC:  BCF    03.5
05DD:  BSF    03.6
05DE:  MOVF   0D,W
05DF:  BSF    03.5
05E0:  BCF    03.6
05E1:  MOVWF  54
05E2:  BCF    03.5
05E3:  BSF    03.6
05E4:  MOVF   0F,W
05E5:  BSF    03.5
05E6:  BCF    03.6
05E7:  MOVWF  55
05E8:  MOVF   53,W
05E9:  MOVWF  56
05EA:  BCF    03.5
05EB:  CALL   2B5
05EC:  BSF    03.5
05ED:  MOVF   54,W
05EE:  BCF    03.5
05EF:  BSF    03.6
05F0:  MOVWF  0D
05F1:  BSF    03.5
05F2:  BCF    03.6
05F3:  MOVF   55,W
05F4:  BCF    03.5
05F5:  BSF    03.6
05F6:  MOVWF  0F
05F7:  INCF   0D,F
05F8:  BTFSC  03.2
05F9:  INCF   0F,F
05FA:  BCF    03.0
05FB:  BSF    03.5
05FC:  BCF    03.6
05FD:  DECFSZ 52,F
05FE:  GOTO   589
*
0603:  BTFSC  53.7
0604:  GOTO   617
0605:  MOVLW  0F
0606:  MOVWF  77
0607:  SWAPF  52,W
0608:  ANDWF  77,F
0609:  MOVLW  0A
060A:  SUBWF  77,W
060B:  BTFSC  03.0
060C:  GOTO   610
060D:  MOVLW  30
060E:  ADDWF  77,F
060F:  GOTO   612
0610:  MOVF   53,W
0611:  ADDWF  77,F
0612:  MOVF   77,W
0613:  MOVWF  56
0614:  BCF    03.5
0615:  CALL   2B5
0616:  BSF    03.5
0617:  MOVLW  0F
0618:  ANDWF  52,F
0619:  MOVLW  0A
061A:  SUBWF  52,W
061B:  BTFSC  03.0
061C:  GOTO   61F
061D:  MOVLW  30
061E:  GOTO   621
061F:  BCF    53.7
0620:  MOVF   53,W
0621:  ADDWF  52,F
0622:  MOVF   52,W
0623:  MOVWF  56
0624:  BCF    03.5
0625:  CALL   2B5
*
07A3:  MOVF   71,W
07A4:  MOVWF  04
07A5:  BCF    03.7
07A6:  BTFSC  72.0
07A7:  BSF    03.7
07A8:  BSF    03.5
07A9:  MOVF   54,W
07AA:  MOVWF  00
07AB:  INCF   04,F
07AC:  CLRF   00
07AD:  INCF   71,F
07AE:  BTFSC  03.2
07AF:  INCF   72,F
07B0:  BCF    03.5
07B1:  RETURN
07B2:  BSF    03.5
07B3:  BTFSC  53.7
07B4:  GOTO   7C7
07B5:  MOVLW  0F
07B6:  MOVWF  77
07B7:  SWAPF  52,W
07B8:  ANDWF  77,F
07B9:  MOVLW  0A
07BA:  SUBWF  77,W
07BB:  BTFSC  03.0
07BC:  GOTO   7C0
07BD:  MOVLW  30
07BE:  ADDWF  77,F
07BF:  GOTO   7C2
07C0:  MOVF   53,W
07C1:  ADDWF  77,F
07C2:  MOVF   77,W
07C3:  MOVWF  54
07C4:  BCF    03.5
07C5:  CALL   7A3
07C6:  BSF    03.5
07C7:  MOVLW  0F
07C8:  ANDWF  52,F
07C9:  MOVLW  0A
07CA:  SUBWF  52,W
07CB:  BTFSC  03.0
07CC:  GOTO   7CF
07CD:  MOVLW  30
07CE:  GOTO   7D1
07CF:  BCF    53.7
07D0:  MOVF   53,W
07D1:  ADDWF  52,F
07D2:  MOVF   52,W
07D3:  MOVWF  54
07D4:  BCF    03.5
07D5:  CALL   7A3
07D6:  RETURN
07D7:  MOVF   00,F
07D8:  BTFSC  03.2
07D9:  GOTO   7F4
07DA:  BSF    03.5
07DB:  CLRF   52
07DC:  MOVF   04,W
07DD:  MOVWF  51
07DE:  BCF    52.0
07DF:  BTFSC  03.7
07E0:  BSF    52.0
07E1:  MOVF   00,W
07E2:  BCF    03.5
07E3:  BTFSS  0C.4
07E4:  GOTO   7E3
07E5:  MOVWF  19
07E6:  BSF    03.5
07E7:  MOVF   51,W
07E8:  MOVWF  04
07E9:  BCF    03.7
07EA:  BTFSC  52.0
07EB:  BSF    03.7
07EC:  INCF   04,F
07ED:  BTFSS  03.2
07EE:  GOTO   7F2
07EF:  BCF    03.5
07F0:  INCF   05,F
07F1:  BSF    03.5
07F2:  BCF    03.5
07F3:  GOTO   7D7
07F4:  RETURN
....................  
.................... #list 
....................  
.................... //#include<18F45K22.h> 
.................... #fuses NOPROTECT,NOLVP,NOWDT 
.................... #use delay(crystal=4000000) 
*
016C:  MOVLW  2A
016D:  MOVWF  04
016E:  BSF    03.7
016F:  MOVF   00,W
0170:  BTFSC  03.2
0171:  GOTO   180
0172:  MOVLW  01
0173:  MOVWF  78
0174:  CLRF   77
0175:  DECFSZ 77,F
0176:  GOTO   175
0177:  DECFSZ 78,F
0178:  GOTO   174
0179:  MOVLW  4A
017A:  MOVWF  77
017B:  DECFSZ 77,F
017C:  GOTO   17B
017D:  GOTO   17E
017E:  DECFSZ 00,F
017F:  GOTO   172
0180:  RETURN
.................... #use rs232( baud=19200, xmit=PIN_C6, rcv=PIN_C7, bits=8,ERRORS) 
....................  
.................... //LCD module connections 
.................... #define LCD_RS_PIN PIN_D0 
.................... #define LCD_RW_PIN PIN_D1 
.................... #define LCD_ENABLE_PIN PIN_D2 
.................... #define LCD_DATA4 PIN_D4 
.................... #define LCD_DATA5 PIN_D5 
.................... #define LCD_DATA6 PIN_D6 
.................... #define LCD_DATA7 PIN_D7 
.................... //End LCD module connections 
....................  
.................... #define CS PIN_A5 
....................  
....................  
....................  
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
01F1:  BSF    08.4
....................    output_float(LCD_DATA5); 
01F2:  BSF    08.5
....................    output_float(LCD_DATA6); 
01F3:  BSF    08.6
....................    output_float(LCD_DATA7); 
01F4:  BSF    08.7
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
01F5:  BCF    03.5
01F6:  BSF    08.1
01F7:  BSF    03.5
01F8:  BCF    08.1
....................    delay_cycles(1); 
01F9:  NOP
....................    lcd_output_enable(1); 
01FA:  BCF    03.5
01FB:  BSF    08.2
01FC:  BSF    03.5
01FD:  BCF    08.2
....................    delay_cycles(1); 
01FE:  NOP
....................    high = lcd_read_nibble(); 
01FF:  BCF    03.5
0200:  CALL   1B6
0201:  MOVF   78,W
0202:  BSF    03.5
0203:  MOVWF  5E
....................        
....................    lcd_output_enable(0); 
0204:  BCF    03.5
0205:  BCF    08.2
0206:  BSF    03.5
0207:  BCF    08.2
....................    delay_cycles(1); 
0208:  NOP
....................    lcd_output_enable(1); 
0209:  BCF    03.5
020A:  BSF    08.2
020B:  BSF    03.5
020C:  BCF    08.2
....................    delay_us(1); 
020D:  NOP
....................    low = lcd_read_nibble(); 
020E:  BCF    03.5
020F:  CALL   1B6
0210:  MOVF   78,W
0211:  BSF    03.5
0212:  MOVWF  5D
....................        
....................    lcd_output_enable(0); 
0213:  BCF    03.5
0214:  BCF    08.2
0215:  BSF    03.5
0216:  BCF    08.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0217:  BCF    08.4
....................    output_drive(LCD_DATA5); 
0218:  BCF    08.5
....................    output_drive(LCD_DATA6); 
0219:  BCF    08.6
....................    output_drive(LCD_DATA7); 
021A:  BCF    08.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
021B:  SWAPF  5E,W
021C:  MOVWF  77
021D:  MOVLW  F0
021E:  ANDWF  77,F
021F:  MOVF   77,W
0220:  IORWF  5D,W
0221:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
01B6:  BSF    03.5
01B7:  CLRF   5F
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
01B8:  BSF    08.4
01B9:  MOVLW  00
01BA:  BCF    03.5
01BB:  BTFSC  08.4
01BC:  MOVLW  01
01BD:  BSF    03.5
01BE:  IORWF  5F,F
....................    n |= input(LCD_DATA5) << 1; 
01BF:  BSF    08.5
01C0:  MOVLW  00
01C1:  BCF    03.5
01C2:  BTFSC  08.5
01C3:  MOVLW  01
01C4:  MOVWF  77
01C5:  BCF    03.0
01C6:  RLF    77,F
01C7:  MOVF   77,W
01C8:  BSF    03.5
01C9:  IORWF  5F,F
....................    n |= input(LCD_DATA6) << 2; 
01CA:  BSF    08.6
01CB:  MOVLW  00
01CC:  BCF    03.5
01CD:  BTFSC  08.6
01CE:  MOVLW  01
01CF:  MOVWF  77
01D0:  RLF    77,F
01D1:  RLF    77,F
01D2:  MOVLW  FC
01D3:  ANDWF  77,F
01D4:  MOVF   77,W
01D5:  BSF    03.5
01D6:  IORWF  5F,F
....................    n |= input(LCD_DATA7) << 3; 
01D7:  BSF    08.7
01D8:  MOVLW  00
01D9:  BCF    03.5
01DA:  BTFSC  08.7
01DB:  MOVLW  01
01DC:  MOVWF  77
01DD:  RLF    77,F
01DE:  RLF    77,F
01DF:  RLF    77,F
01E0:  MOVLW  F8
01E1:  ANDWF  77,F
01E2:  MOVF   77,W
01E3:  BSF    03.5
01E4:  IORWF  5F,F
....................     
....................    return(n); 
01E5:  MOVF   5F,W
01E6:  MOVWF  78
....................   #else 
01E7:  BCF    03.5
01E8:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
0181:  BSF    03.5
0182:  BTFSC  5E.0
0183:  GOTO   188
0184:  BCF    03.5
0185:  BCF    08.4
0186:  GOTO   18A
0187:  BSF    03.5
0188:  BCF    03.5
0189:  BSF    08.4
018A:  BSF    03.5
018B:  BCF    08.4
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
018C:  BTFSC  5E.1
018D:  GOTO   192
018E:  BCF    03.5
018F:  BCF    08.5
0190:  GOTO   194
0191:  BSF    03.5
0192:  BCF    03.5
0193:  BSF    08.5
0194:  BSF    03.5
0195:  BCF    08.5
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
0196:  BTFSC  5E.2
0197:  GOTO   19C
0198:  BCF    03.5
0199:  BCF    08.6
019A:  GOTO   19E
019B:  BSF    03.5
019C:  BCF    03.5
019D:  BSF    08.6
019E:  BSF    03.5
019F:  BCF    08.6
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
01A0:  BTFSC  5E.3
01A1:  GOTO   1A6
01A2:  BCF    03.5
01A3:  BCF    08.7
01A4:  GOTO   1A8
01A5:  BSF    03.5
01A6:  BCF    03.5
01A7:  BSF    08.7
01A8:  BSF    03.5
01A9:  BCF    08.7
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
01AA:  NOP
....................    lcd_output_enable(1); 
01AB:  BCF    03.5
01AC:  BSF    08.2
01AD:  BSF    03.5
01AE:  BCF    08.2
....................    delay_us(2); 
01AF:  GOTO   1B0
....................    lcd_output_enable(0); 
01B0:  BCF    03.5
01B1:  BCF    08.2
01B2:  BSF    03.5
01B3:  BCF    08.2
01B4:  BCF    03.5
01B5:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
01E9:  BSF    03.5
01EA:  BCF    08.2
....................    lcd_rs_tris(); 
01EB:  BCF    08.0
....................    lcd_rw_tris(); 
01EC:  BCF    08.1
....................   #endif 
....................  
....................    lcd_output_rs(0); 
01ED:  BCF    03.5
01EE:  BCF    08.0
01EF:  BSF    03.5
01F0:  BCF    08.0
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
0222:  MOVF   78,W
0223:  MOVWF  5D
0224:  BTFSC  5D.7
0225:  GOTO   1F1
....................    lcd_output_rs(address); 
0226:  MOVF   5B,F
0227:  BTFSS  03.2
0228:  GOTO   22D
0229:  BCF    03.5
022A:  BCF    08.0
022B:  GOTO   22F
022C:  BSF    03.5
022D:  BCF    03.5
022E:  BSF    08.0
022F:  BSF    03.5
0230:  BCF    08.0
....................    delay_cycles(1); 
0231:  NOP
....................    lcd_output_rw(0); 
0232:  BCF    03.5
0233:  BCF    08.1
0234:  BSF    03.5
0235:  BCF    08.1
....................    delay_cycles(1); 
0236:  NOP
....................    lcd_output_enable(0); 
0237:  BCF    03.5
0238:  BCF    08.2
0239:  BSF    03.5
023A:  BCF    08.2
....................    lcd_send_nibble(n >> 4); 
023B:  SWAPF  5C,W
023C:  MOVWF  5D
023D:  MOVLW  0F
023E:  ANDWF  5D,F
023F:  MOVF   5D,W
0240:  MOVWF  5E
0241:  BCF    03.5
0242:  CALL   181
....................    lcd_send_nibble(n & 0xf); 
0243:  BSF    03.5
0244:  MOVF   5C,W
0245:  ANDLW  0F
0246:  MOVWF  5D
0247:  MOVWF  5E
0248:  BCF    03.5
0249:  CALL   181
024A:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
024B:  MOVLW  28
024C:  BSF    03.5
024D:  MOVWF  52
024E:  MOVLW  0C
024F:  MOVWF  53
0250:  MOVLW  01
0251:  MOVWF  54
0252:  MOVLW  06
0253:  MOVWF  55
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
0254:  BCF    03.5
0255:  BCF    08.2
0256:  BSF    03.5
0257:  BCF    08.2
....................    lcd_output_rs(0); 
0258:  BCF    03.5
0259:  BCF    08.0
025A:  BSF    03.5
025B:  BCF    08.0
....................    lcd_output_rw(0); 
025C:  BCF    03.5
025D:  BCF    08.1
025E:  BSF    03.5
025F:  BCF    08.1
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0260:  BCF    08.4
....................    output_drive(LCD_DATA5); 
0261:  BCF    08.5
....................    output_drive(LCD_DATA6); 
0262:  BCF    08.6
....................    output_drive(LCD_DATA7); 
0263:  BCF    08.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
0264:  BCF    08.2
....................    lcd_rs_tris(); 
0265:  BCF    08.0
....................    lcd_rw_tris(); 
0266:  BCF    08.1
....................  #endif 
....................      
....................    delay_ms(15); 
0267:  MOVLW  0F
0268:  BCF    03.5
0269:  BSF    03.6
026A:  MOVWF  2A
026B:  BCF    03.6
026C:  CALL   16C
....................    for(i=1;i<=3;++i) 
026D:  MOVLW  01
026E:  BSF    03.5
026F:  MOVWF  51
0270:  MOVF   51,W
0271:  SUBLW  03
0272:  BTFSS  03.0
0273:  GOTO   280
....................    { 
....................        lcd_send_nibble(3); 
0274:  MOVLW  03
0275:  MOVWF  5E
0276:  BCF    03.5
0277:  CALL   181
....................        delay_ms(5); 
0278:  MOVLW  05
0279:  BSF    03.6
027A:  MOVWF  2A
027B:  BCF    03.6
027C:  CALL   16C
027D:  BSF    03.5
027E:  INCF   51,F
027F:  GOTO   270
....................    } 
....................     
....................    lcd_send_nibble(2); 
0280:  MOVLW  02
0281:  MOVWF  5E
0282:  BCF    03.5
0283:  CALL   181
....................    delay_ms(5); 
0284:  MOVLW  05
0285:  BSF    03.6
0286:  MOVWF  2A
0287:  BCF    03.6
0288:  CALL   16C
....................    for(i=0;i<=3;++i) 
0289:  BSF    03.5
028A:  CLRF   51
028B:  MOVF   51,W
028C:  SUBLW  03
028D:  BTFSS  03.0
028E:  GOTO   29D
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
028F:  MOVLW  D2
0290:  ADDWF  51,W
0291:  MOVWF  04
0292:  BCF    03.7
0293:  MOVF   00,W
0294:  MOVWF  56
0295:  CLRF   5B
0296:  MOVF   56,W
0297:  MOVWF  5C
0298:  BCF    03.5
0299:  CALL   1E9
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
029A:  BSF    03.5
029B:  INCF   51,F
029C:  GOTO   28B
029D:  BCF    03.5
029E:  BSF    0A.3
029F:  BCF    0A.4
02A0:  GOTO   665 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
02A1:  BSF    03.5
02A2:  DECFSZ 58,W
02A3:  GOTO   2A5
02A4:  GOTO   2A8
....................       address=LCD_LINE_TWO; 
02A5:  MOVLW  40
02A6:  MOVWF  59
02A7:  GOTO   2A9
....................    else 
....................       address=0; 
02A8:  CLRF   59
....................       
....................    address+=x-1; 
02A9:  MOVLW  01
02AA:  SUBWF  57,W
02AB:  ADDWF  59,F
....................    lcd_send_byte(0,0x80|address); 
02AC:  MOVF   59,W
02AD:  IORLW  80
02AE:  MOVWF  5A
02AF:  CLRF   5B
02B0:  MOVF   5A,W
02B1:  MOVWF  5C
02B2:  BCF    03.5
02B3:  CALL   1E9
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
02B4:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
02B5:  BSF    03.5
02B6:  MOVF   56,W
02B7:  XORLW  07
02B8:  BCF    03.5
02B9:  BTFSC  03.2
02BA:  GOTO   2C5
02BB:  XORLW  0B
02BC:  BTFSC  03.2
02BD:  GOTO   2CC
02BE:  XORLW  06
02BF:  BTFSC  03.2
02C0:  GOTO   2D8
02C1:  XORLW  02
02C2:  BTFSC  03.2
02C3:  GOTO   2E0
02C4:  GOTO   2E7
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
02C5:  MOVLW  01
02C6:  BSF    03.5
02C7:  MOVWF  57
02C8:  MOVWF  58
02C9:  BCF    03.5
02CA:  CALL   2A1
02CB:  GOTO   2EE
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
02CC:  BSF    03.5
02CD:  CLRF   5B
02CE:  MOVLW  01
02CF:  MOVWF  5C
02D0:  BCF    03.5
02D1:  CALL   1E9
....................                      delay_ms(2); 
02D2:  MOVLW  02
02D3:  BSF    03.6
02D4:  MOVWF  2A
02D5:  BCF    03.6
02D6:  CALL   16C
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
02D7:  GOTO   2EE
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
02D8:  MOVLW  01
02D9:  BSF    03.5
02DA:  MOVWF  57
02DB:  MOVLW  02
02DC:  MOVWF  58
02DD:  BCF    03.5
02DE:  CALL   2A1
02DF:  GOTO   2EE
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
02E0:  BSF    03.5
02E1:  CLRF   5B
02E2:  MOVLW  10
02E3:  MOVWF  5C
02E4:  BCF    03.5
02E5:  CALL   1E9
02E6:  GOTO   2EE
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
02E7:  MOVLW  01
02E8:  BSF    03.5
02E9:  MOVWF  5B
02EA:  MOVF   56,W
02EB:  MOVWF  5C
02EC:  BCF    03.5
02ED:  CALL   1E9
....................      #endif 
....................    } 
02EE:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
0E18:  BCF    03.5
0E19:  CLRF   21
0E1A:  CLRF   22
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... //spi modes 
.................... #define SPI_MODE_0  (SPI_L_TO_H | SPI_XMIT_L_TO_H) 
.................... #define SPI_MODE_1  (SPI_L_TO_H) 
.................... #define SPI_MODE_2  (SPI_H_TO_L) 
.................... #define SPI_MODE_3  (SPI_H_TO_L | SPI_XMIT_L_TO_H) 
....................  
.................... #include "rfid.h" 
.................... /*  
....................  * File:   rfid.h 
....................  * Author: Shashikant 
....................  * 
....................  * Created on 2 July, 2018, 1:34 PM 
....................  */ 
....................  
.................... #ifndef RFID_H 
.................... #define	RFID_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................  
....................  
....................  
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* RFID_H */ 
....................  
.................... #define     MAX_LEN               16        // Maximum length of an array. CHECK IF IT IS MAXIMUM LENGTH/SIZE OF FIFO!!!!!!!!!!! 
....................  
.................... //MF522 MFRC522 error codes. 
.................... #define     MI_OK                 0         // Everything A-OK. 
.................... #define     MI_NOTAGERR           1         // No tag error 
.................... #define     MI_ERR                2         // General error 
....................  
.................... //MF522 Command word 
.................... #define     MFRC522_IDLE          0x00      // NO action; Cancel the current command 
.................... #define     MFRC522_MEM           0x01      // Store 25 byte into the internal buffer. 
.................... #define     MFRC522_GENID         0x02      // Generates a 10 byte random ID number. 
.................... #define     MFRC522_CALCCRC       0x03      // CRC Calculate or selftest. 
.................... #define     MFRC522_TRANSMIT      0x04      // Transmit data 
.................... #define     MFRC522_NOCMDCH       0x07      // No command change. 
.................... #define     MFRC522_RECEIVE       0x08      // Receive Data 
.................... #define     MFRC522_TRANSCEIVE    0x0C      // Transmit and receive data, 
.................... #define     MFRC522_AUTHENT       0x0E      // Authentication Key 
.................... #define     MFRC522_SOFTRESET     0x0F      // Reset 
....................  
.................... //Mifare_One tag command word 
.................... #define     MF1_REQIDL            0x26      // find the antenna area does not enter hibernation 
.................... #define     MF1_REQALL            0x52      // find all the tags antenna area 
.................... #define     MF1_ANTICOLL          0x93      // anti-collision 
.................... #define     MF1_SELECTTAG         0x93      // election tag 
.................... #define     MF1_AUTHENT1A         0x60      // authentication key A 
.................... #define     MF1_AUTHENT1B         0x61      // authentication key B 
.................... #define     MF1_READ              0x30      // Read Block 
.................... #define     MF1_WRITE             0xA0      // write block 
.................... #define     MF1_DECREMENT         0xC0      // debit 
.................... #define     MF1_INCREMENT         0xC1      // recharge 
.................... #define     MF1_RESTORE           0xC2      // transfer block data to the buffer 
.................... #define     MF1_TRANSFER          0xB0      // save the data in the buffer 
.................... #define     MF1_HALT              0x50      // Sleep 
....................  
....................  
.................... //------------------ MFRC522 registers--------------- 
.................... //Page 0:Command and Status 
.................... #define     Reserved00            0x00 
.................... #define     CommandReg            0x01 
.................... #define     CommIEnReg            0x02 
.................... #define     DivIEnReg             0x03 
.................... #define     CommIrqReg            0x04 
.................... #define     DivIrqReg             0x05 
.................... #define     ErrorReg              0x06 
.................... #define     Status1Reg            0x07 
.................... #define     Status2Reg            0x08 
.................... #define     FIFODataReg           0x09 
.................... #define     FIFOLevelReg          0x0A 
.................... #define     WaterLevelReg         0x0B 
.................... #define     ControlReg            0x0C 
.................... #define     BitFramingReg         0x0D 
.................... #define     CollReg               0x0E 
.................... #define     Reserved01            0x0F 
.................... //Page 1:Command 
.................... #define     Reserved10            0x10 
.................... #define     ModeReg               0x11 
.................... #define     TxModeReg             0x12 
.................... #define     RxModeReg             0x13 
.................... #define     TxControlReg          0x14 
.................... #define     TxAutoReg             0x15 
.................... #define     TxSelReg              0x16 
.................... #define     RxSelReg              0x17 
.................... #define     RxThresholdReg        0x18 
.................... #define     DemodReg              0x19 
.................... #define     Reserved11            0x1A 
.................... #define     Reserved12            0x1B 
.................... #define     MifareReg             0x1C 
.................... #define     Reserved13            0x1D 
.................... #define     Reserved14            0x1E 
.................... #define     SerialSpeedReg        0x1F 
.................... //Page 2:CFG 
.................... #define     Reserved20            0x20 
.................... #define     CRCResultRegM         0x21 
.................... #define     CRCResultRegL         0x22 
.................... #define     Reserved21            0x23 
.................... #define     ModWidthReg           0x24 
.................... #define     Reserved22            0x25 
.................... #define     RFCfgReg              0x26 
.................... #define     GsNReg                0x27 
.................... #define     CWGsPReg              0x28 
.................... #define     ModGsPReg             0x29 
.................... #define     TModeReg              0x2A 
.................... #define     TPrescalerReg         0x2B 
.................... #define     TReloadRegH           0x2C 
.................... #define     TReloadRegL           0x2D 
.................... #define     TCounterValueRegH     0x2E 
.................... #define     TCounterValueRegL     0x2F 
.................... //Page 3:TestRegister 
.................... #define     Reserved30            0x30 
.................... #define     TestSel1Reg           0x31 
.................... #define     TestSel2Reg           0x32 
.................... #define     TestPinEnReg          0x33 
.................... #define     TestPinValueReg       0x34 
.................... #define     TestBusReg            0x35 
.................... #define     AutoTestReg           0x36 
.................... #define     VersionReg            0x37 
.................... #define     AnalogTestReg         0x38 
.................... #define     TestDAC1Reg           0x39 
.................... #define     TestDAC2Reg           0x3A 
.................... #define     TestADCReg            0x3B 
.................... #define     Reserved31            0x3C 
.................... #define     Reserved32            0x3D 
.................... #define     Reserved33            0x3E 
.................... #define     Reserved34            0x3F 
.................... //-----------------------------------------------  
....................  
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Writes value to a register. 
....................   @param   addr  The address a register. 
....................   @param   val   The value to write to a register. 
....................  */ 
.................... /**************************************************************************/ 
.................... void writeToRegister(byte addr, byte val) { 
....................   output_low(CS); 
*
03D9:  BSF    03.5
03DA:  BCF    05.5
03DB:  BCF    03.5
03DC:  BCF    05.5
....................   //Address format: 0XXXXXX0 
....................   spi_write((addr<<1)&0x7E); 
03DD:  BCF    03.0
03DE:  BSF    03.6
03DF:  RLF    2E,W
03E0:  ANDLW  7E
03E1:  MOVWF  30
03E2:  BCF    03.6
03E3:  MOVF   13,W
03E4:  BSF    03.6
03E5:  MOVF   30,W
03E6:  BCF    03.6
03E7:  MOVWF  13
03E8:  BSF    03.5
03E9:  RRF    14,W
03EA:  BTFSS  03.0
03EB:  GOTO   3E9
....................   spi_write(val); 
03EC:  BCF    03.5
03ED:  MOVF   13,W
03EE:  BSF    03.6
03EF:  MOVF   2F,W
03F0:  BCF    03.6
03F1:  MOVWF  13
03F2:  BSF    03.5
03F3:  RRF    14,W
03F4:  BTFSS  03.0
03F5:  GOTO   3F3
....................   output_high(CS); 
03F6:  BCF    05.5
03F7:  BCF    03.5
03F8:  BSF    05.5
03F9:  RETURN
.................... } 
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Reads the value at a register. 
....................   @param   addr  The address a register. 
....................   @returns The byte at the register. 
....................  */ 
.................... /**************************************************************************/ 
.................... byte readFromRegister(byte addr) { 
....................   byte val; 
....................   output_low(CS); 
03FA:  BSF    03.5
03FB:  BCF    05.5
03FC:  BCF    03.5
03FD:  BCF    05.5
....................   spi_write(((addr<<1)&0x7E) | 0x80); 
03FE:  BCF    03.0
03FF:  BSF    03.6
0400:  RLF    2D,W
0401:  ANDLW  7E
0402:  IORLW  80
0403:  MOVWF  2F
0404:  BCF    03.6
0405:  MOVF   13,W
0406:  BSF    03.6
0407:  MOVF   2F,W
0408:  BCF    03.6
0409:  MOVWF  13
040A:  BSF    03.5
040B:  RRF    14,W
040C:  BTFSS  03.0
040D:  GOTO   40B
....................   val =spi_read(0x00); 
040E:  BCF    03.5
040F:  MOVF   13,W
0410:  CLRF   13
0411:  BSF    03.5
0412:  RRF    14,W
0413:  BTFSS  03.0
0414:  GOTO   412
0415:  BCF    03.5
0416:  MOVF   13,W
0417:  BSF    03.6
0418:  MOVWF  2E
....................   output_high(CS); 
0419:  BSF    03.5
041A:  BCF    03.6
041B:  BCF    05.5
041C:  BCF    03.5
041D:  BSF    05.5
....................   return val; 
041E:  BSF    03.6
041F:  MOVF   2E,W
0420:  MOVWF  78
0421:  BCF    03.6
0422:  RETURN
.................... } 
....................  
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Adds a bitmask to a register. 
....................   @param   addr   The address a register. 
....................   @param   mask  The mask to update the register with. 
....................  */ 
.................... /**************************************************************************/ 
.................... void setBitMask(byte addr, byte mask) { 
....................   byte current; 
....................   current = readFromRegister(addr); 
0423:  BSF    03.6
0424:  MOVF   2A,W
0425:  MOVWF  2D
0426:  BCF    03.6
0427:  CALL   3FA
0428:  MOVF   78,W
0429:  BSF    03.6
042A:  MOVWF  2C
....................   writeToRegister(addr, current | mask); 
042B:  MOVF   2C,W
042C:  IORWF  2B,W
042D:  MOVWF  2D
042E:  MOVF   2A,W
042F:  MOVWF  2E
0430:  MOVF   2D,W
0431:  MOVWF  2F
0432:  BCF    03.6
0433:  CALL   3D9
0434:  RETURN
.................... } 
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Removes a bitmask from the register. 
....................   @param   reg   The address a register. 
....................   @param   mask  The mask to update the register with. 
....................  */ 
.................... /**************************************************************************/ 
.................... void clearBitMask(byte addr, byte mask) { 
....................   byte current; 
....................   current = readFromRegister(addr); 
*
0651:  BSF    03.6
0652:  MOVF   2A,W
0653:  MOVWF  2D
0654:  BCF    03.6
0655:  CALL   3FA
0656:  MOVF   78,W
0657:  BSF    03.6
0658:  MOVWF  2C
....................   writeToRegister(addr, current & (~mask)); 
0659:  MOVF   2B,W
065A:  XORLW  FF
065B:  ANDWF  2C,W
065C:  MOVWF  2D
065D:  MOVF   2A,W
065E:  MOVWF  2E
065F:  MOVF   2D,W
0660:  MOVWF  2F
0661:  BCF    03.6
0662:  CALL   3D9
0663:  RETURN
.................... } 
....................  
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Sends a SOFTRESET command to the MFRC522 chip. 
....................  */ 
.................... /**************************************************************************/ 
.................... void reset() { 
....................   writeToRegister(CommandReg, MFRC522_SOFTRESET); 
*
0439:  MOVLW  01
043A:  BSF    03.6
043B:  MOVWF  2E
043C:  MOVLW  0F
043D:  MOVWF  2F
043E:  BCF    03.6
043F:  CALL   3D9
.................... } 
....................  
....................  
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Does the setup for the MFRC522. 
....................  */ 
.................... /**************************************************************************/ 
.................... void MFRC_begin() { 
....................   output_high(CS); 
*
0435:  BSF    03.5
0436:  BCF    05.5
0437:  BCF    03.5
0438:  BSF    05.5
....................   reset(); 
....................   //Timer: TPrescaler*TreloadVal/6.78MHz = 24ms 
....................   writeToRegister(TModeReg, 0x8D);    
*
0440:  MOVLW  2A
0441:  BSF    03.6
0442:  MOVWF  2E
0443:  MOVLW  8D
0444:  MOVWF  2F
0445:  BCF    03.6
0446:  CALL   3D9
....................   delay_ms(20); // Tauto=1; f(Timer) = 6.78MHz/TPreScaler 
0447:  MOVLW  14
0448:  BSF    03.6
0449:  MOVWF  2A
044A:  BCF    03.6
044B:  CALL   16C
....................   writeToRegister(TPrescalerReg, 0x3E);  // TModeReg[3..0] + TPrescalerReg 
044C:  MOVLW  2B
044D:  BSF    03.6
044E:  MOVWF  2E
044F:  MOVLW  3E
0450:  MOVWF  2F
0451:  BCF    03.6
0452:  CALL   3D9
....................   delay_ms(20); 
0453:  MOVLW  14
0454:  BSF    03.6
0455:  MOVWF  2A
0456:  BCF    03.6
0457:  CALL   16C
....................   writeToRegister(TReloadRegL, 30); 
0458:  MOVLW  2D
0459:  BSF    03.6
045A:  MOVWF  2E
045B:  MOVLW  1E
045C:  MOVWF  2F
045D:  BCF    03.6
045E:  CALL   3D9
....................   delay_ms(20); 
045F:  MOVLW  14
0460:  BSF    03.6
0461:  MOVWF  2A
0462:  BCF    03.6
0463:  CALL   16C
....................   writeToRegister(TReloadRegH, 0); 
0464:  MOVLW  2C
0465:  BSF    03.6
0466:  MOVWF  2E
0467:  CLRF   2F
0468:  BCF    03.6
0469:  CALL   3D9
....................   delay_ms(20); 
046A:  MOVLW  14
046B:  BSF    03.6
046C:  MOVWF  2A
046D:  BCF    03.6
046E:  CALL   16C
....................   writeToRegister(TxAutoReg, 0x40);      // 100%ASK 
046F:  MOVLW  15
0470:  BSF    03.6
0471:  MOVWF  2E
0472:  MOVLW  40
0473:  MOVWF  2F
0474:  BCF    03.6
0475:  CALL   3D9
....................   delay_ms(20); 
0476:  MOVLW  14
0477:  BSF    03.6
0478:  MOVWF  2A
0479:  BCF    03.6
047A:  CALL   16C
....................   writeToRegister(ModeReg, 0x3D);        // CRC initial value 0x6363 
047B:  MOVLW  11
047C:  BSF    03.6
047D:  MOVWF  2E
047E:  MOVLW  3D
047F:  MOVWF  2F
0480:  BCF    03.6
0481:  CALL   3D9
....................   delay_ms(20); 
0482:  MOVLW  14
0483:  BSF    03.6
0484:  MOVWF  2A
0485:  BCF    03.6
0486:  CALL   16C
....................  //writeToRegister(TxControlReg, 0x82);      
....................   delay_ms(20); 
0487:  MOVLW  14
0488:  BSF    03.6
0489:  MOVWF  2A
048A:  BCF    03.6
048B:  CALL   16C
....................  setBitMask(TxControlReg, 0x03);        // Turn antenna on. 
048C:  MOVLW  14
048D:  BSF    03.6
048E:  MOVWF  2A
048F:  MOVLW  03
0490:  MOVWF  2B
0491:  BCF    03.6
0492:  CALL   423
0493:  BSF    0A.3
0494:  BCF    0A.4
0495:  GOTO   681 (RETURN)
.................... } 
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Checks the firmware version of the chip. 
....................   @returns The firmware version of the MFRC522 chip. 
....................  */ 
.................... /**************************************************************************/ 
.................... byte getFirmwareVersion() { 
....................   byte response; 
....................   response = readFromRegister(VersionReg); 
....................   return response; 
.................... } 
....................  
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................  
....................   @brief   Sends a command to a tag. 
....................  
....................   @param   cmd     The command to the MFRC522 to send a command to the tag. 
....................   @param   data    The data that is needed to complete the command. 
....................   @param   dlen    The length of the data. 
....................   @param   result  The result returned by the tag. 
....................   @param   rlen    The number of valid bits in the resulting value. 
....................  
....................   @returns Returns the status of the calculation. 
....................            MI_ERR        if something went wrong, 
....................            MI_NOTAGERR   if there was no tag to send the command to. 
....................            MI_OK         if everything went OK. 
....................  
....................  */ 
.................... /**************************************************************************/ 
....................  
.................... int commandTag(byte cmd, byte *data, int dlen, byte *result, int *rlen) { 
*
0664:  MOVLW  02
0665:  BSF    03.6
0666:  MOVWF  24
0667:  CLRF   25
0668:  CLRF   26
....................   int status = MI_ERR; 
....................   byte irqEn = 0x00; 
....................   byte waitIRq = 0x00; 
....................   byte lastBits, n; 
....................   int i; 
....................  
....................   switch (cmd) { 
0669:  MOVF   1C,W
066A:  XORLW  0E
066B:  BCF    03.6
066C:  BTFSC  03.2
066D:  GOTO   672
066E:  XORLW  02
066F:  BTFSC  03.2
0670:  GOTO   678
0671:  GOTO   67F
....................   case MFRC522_AUTHENT: 
....................     irqEn = 0x12; 
0672:  MOVLW  12
0673:  BSF    03.6
0674:  MOVWF  25
....................     waitIRq = 0x10; 
0675:  MOVLW  10
0676:  MOVWF  26
....................     break; 
0677:  GOTO   680
....................   case MFRC522_TRANSCEIVE: 
....................     irqEn = 0x77; 
0678:  MOVLW  77
0679:  BSF    03.6
067A:  MOVWF  25
....................     waitIRq = 0x30; 
067B:  MOVLW  30
067C:  MOVWF  26
....................     break; 
067D:  GOTO   680
067E:  BCF    03.6
....................   default: 
....................     break; 
067F:  BSF    03.6
....................   } 
....................  
....................   writeToRegister(CommIEnReg, irqEn|0x80);    // interrupt request 
0680:  MOVF   25,W
0681:  IORLW  80
0682:  MOVWF  2A
0683:  MOVLW  02
0684:  MOVWF  2E
0685:  MOVF   2A,W
0686:  MOVWF  2F
0687:  BCF    03.6
0688:  CALL   3D9
....................   clearBitMask(CommIrqReg, 0x80);             // Clear all interrupt requests bits. 
0689:  MOVLW  04
068A:  BSF    03.6
068B:  MOVWF  2A
068C:  MOVLW  80
068D:  MOVWF  2B
068E:  BCF    03.6
068F:  CALL   651
....................   setBitMask(FIFOLevelReg, 0x80);             // FlushBuffer=1, FIFO initialization. 
0690:  MOVLW  0A
0691:  BSF    03.6
0692:  MOVWF  2A
0693:  MOVLW  80
0694:  MOVWF  2B
0695:  BCF    03.6
0696:  CALL   423
....................  
....................   writeToRegister(CommandReg, MFRC522_IDLE);  // No action, cancel the current command. 
0697:  MOVLW  01
0698:  BSF    03.6
0699:  MOVWF  2E
069A:  CLRF   2F
069B:  BCF    03.6
069C:  CALL   3D9
....................  
....................   // Write to FIFO 
....................   for (i=0; i < dlen; i++) { 
069D:  BSF    03.6
069E:  CLRF   29
069F:  MOVF   1F,W
06A0:  SUBWF  29,W
06A1:  BTFSC  03.0
06A2:  GOTO   6B4
....................     writeToRegister(FIFODataReg, data[i]); 
06A3:  MOVF   29,W
06A4:  ADDWF  1D,W
06A5:  MOVWF  04
06A6:  BCF    03.7
06A7:  BTFSC  1E.0
06A8:  BSF    03.7
06A9:  MOVF   00,W
06AA:  MOVWF  2A
06AB:  MOVLW  09
06AC:  MOVWF  2E
06AD:  MOVF   2A,W
06AE:  MOVWF  2F
06AF:  BCF    03.6
06B0:  CALL   3D9
06B1:  BSF    03.6
06B2:  INCF   29,F
06B3:  GOTO   69F
....................   } 
....................  
....................   // Execute the command. 
....................   writeToRegister(CommandReg, cmd); 
06B4:  MOVLW  01
06B5:  MOVWF  2E
06B6:  MOVF   1C,W
06B7:  MOVWF  2F
06B8:  BCF    03.6
06B9:  CALL   3D9
....................   if (cmd == MFRC522_TRANSCEIVE) { 
06BA:  BSF    03.6
06BB:  MOVF   1C,W
06BC:  SUBLW  0C
06BD:  BTFSS  03.2
06BE:  GOTO   6C6
....................     setBitMask(BitFramingReg, 0x80);  // StartSend=1, transmission of data starts 
06BF:  MOVLW  0D
06C0:  MOVWF  2A
06C1:  MOVLW  80
06C2:  MOVWF  2B
06C3:  BCF    03.6
06C4:  CALL   423
06C5:  BSF    03.6
....................   } 
....................  
....................   // Waiting for the command to complete so we can receive data. 
....................   i = 25; // Max wait time is 25ms. 
06C6:  MOVLW  19
06C7:  MOVWF  29
....................   do { 
....................     delay_ms(1); 
06C8:  MOVLW  01
06C9:  MOVWF  2A
06CA:  BCF    03.6
06CB:  CALL   16C
....................     // CommIRqReg[7..0] 
....................     // Set1 TxIRq RxIRq IdleIRq HiAlerIRq LoAlertIRq ErrIRq TimerIRq 
....................     n = readFromRegister(CommIrqReg); 
06CC:  MOVLW  04
06CD:  BSF    03.6
06CE:  MOVWF  2D
06CF:  BCF    03.6
06D0:  CALL   3FA
06D1:  MOVF   78,W
06D2:  BSF    03.6
06D3:  MOVWF  28
....................     i--; 
06D4:  DECF   29,F
....................   } while ((i!=0) && !(n&0x01) && !(n&waitIRq)); 
06D5:  MOVF   29,F
06D6:  BTFSC  03.2
06D7:  GOTO   6DE
06D8:  BTFSC  28.0
06D9:  GOTO   6DE
06DA:  MOVF   28,W
06DB:  ANDWF  26,W
06DC:  BTFSC  03.2
06DD:  GOTO   6C8
....................  
....................   clearBitMask(BitFramingReg, 0x80);  // StartSend=0 
06DE:  MOVLW  0D
06DF:  MOVWF  2A
06E0:  MOVLW  80
06E1:  MOVWF  2B
06E2:  BCF    03.6
06E3:  CALL   651
....................  
....................   if (i != 0) { // Request did not time out. 
06E4:  BSF    03.6
06E5:  MOVF   29,F
06E6:  BTFSC  03.2
06E7:  GOTO   75B
....................     if(!(readFromRegister(ErrorReg) & 0x1D)) {  // BufferOvfl Collerr CRCErr ProtocolErr 
06E8:  MOVLW  06
06E9:  MOVWF  2D
06EA:  BCF    03.6
06EB:  CALL   3FA
06EC:  MOVF   78,W
06ED:  ANDLW  1D
06EE:  BTFSS  03.2
06EF:  GOTO   758
....................       status = MI_OK; 
06F0:  BSF    03.6
06F1:  CLRF   24
....................       if (n & irqEn & 0x01) { 
06F2:  MOVF   28,W
06F3:  ANDWF  25,W
06F4:  ANDLW  01
06F5:  BTFSC  03.2
06F6:  GOTO   6F9
....................         status = MI_NOTAGERR; 
06F7:  MOVLW  01
06F8:  MOVWF  24
....................       } 
....................  
....................       if (cmd == MFRC522_TRANSCEIVE) { 
06F9:  MOVF   1C,W
06FA:  SUBLW  0C
06FB:  BTFSS  03.2
06FC:  GOTO   756
....................         n = readFromRegister(FIFOLevelReg); 
06FD:  MOVLW  0A
06FE:  MOVWF  2D
06FF:  BCF    03.6
0700:  CALL   3FA
0701:  MOVF   78,W
0702:  BSF    03.6
0703:  MOVWF  28
....................         lastBits = readFromRegister(ControlReg) & 0x07; 
0704:  MOVLW  0C
0705:  MOVWF  2D
0706:  BCF    03.6
0707:  CALL   3FA
0708:  MOVF   78,W
0709:  ANDLW  07
070A:  BSF    03.6
070B:  MOVWF  27
....................         if (lastBits) { 
070C:  MOVF   27,F
070D:  BTFSC  03.2
070E:  GOTO   720
....................           *rlen = (n-1)*8 + lastBits; 
070F:  MOVF   22,W
0710:  MOVWF  04
0711:  BCF    03.7
0712:  BTFSC  23.0
0713:  BSF    03.7
0714:  MOVLW  01
0715:  SUBWF  28,W
0716:  MOVWF  77
0717:  RLF    77,F
0718:  RLF    77,F
0719:  RLF    77,F
071A:  MOVLW  F8
071B:  ANDWF  77,F
071C:  MOVF   77,W
071D:  ADDWF  27,W
071E:  MOVWF  00
....................         } else { 
071F:  GOTO   72D
....................           *rlen = n*8; 
0720:  MOVF   22,W
0721:  MOVWF  04
0722:  BCF    03.7
0723:  BTFSC  23.0
0724:  BSF    03.7
0725:  RLF    28,W
0726:  MOVWF  77
0727:  RLF    77,F
0728:  RLF    77,F
0729:  MOVLW  F8
072A:  ANDWF  77,F
072B:  MOVF   77,W
072C:  MOVWF  00
....................         } 
....................  
....................         if (n == 0) { 
072D:  MOVF   28,F
072E:  BTFSS  03.2
072F:  GOTO   732
....................           n = 1; 
0730:  MOVLW  01
0731:  MOVWF  28
....................         } 
....................  
....................         if (n > MAX_LEN) { 
0732:  MOVF   28,W
0733:  SUBLW  10
0734:  BTFSC  03.0
0735:  GOTO   738
....................           n = MAX_LEN; 
0736:  MOVLW  10
0737:  MOVWF  28
....................         } 
....................  
....................         // Reading the recieved data from FIFO. 
....................         for (i=0; i<n; i++) { 
0738:  CLRF   29
0739:  MOVF   28,W
073A:  SUBWF  29,W
073B:  BTFSC  03.0
073C:  GOTO   756
....................           result[i] = readFromRegister(FIFODataReg); 
073D:  MOVF   29,W
073E:  ADDWF  20,W
073F:  MOVWF  78
0740:  MOVF   21,W
0741:  MOVWF  7A
0742:  BTFSC  03.0
0743:  INCF   7A,F
0744:  MOVF   78,W
0745:  MOVWF  2A
0746:  MOVF   7A,W
0747:  MOVWF  2B
0748:  MOVLW  09
0749:  MOVWF  2D
074A:  BCF    03.6
074B:  CALL   3FA
074C:  BSF    03.6
074D:  MOVF   2A,W
074E:  MOVWF  04
074F:  BCF    03.7
0750:  BTFSC  2B.0
0751:  BSF    03.7
0752:  MOVF   78,W
0753:  MOVWF  00
0754:  INCF   29,F
0755:  GOTO   739
....................         } 
....................       } 
....................     } else { 
0756:  GOTO   75B
0757:  BCF    03.6
....................       status = MI_ERR; 
0758:  MOVLW  02
0759:  BSF    03.6
075A:  MOVWF  24
....................     } 
....................   } 
....................   return status; 
075B:  MOVF   24,W
075C:  MOVWF  78
075D:  BCF    03.6
075E:  RETURN
.................... } 
....................  
....................  
.................... /**************************************************************************/ 
.................... /* 
....................  
....................   @brief   Checks to see if there is a tag in the vicinity. 
....................  
....................   @param   mode  The mode we are requsting in. 
....................   @param   type  If we find a tag, this will be the type of that tag. 
....................                  0x4400 = Mifare_UltraLight 
....................                  0x0400 = Mifare_One(S50) 
....................                  0x0200 = Mifare_One(S70) 
....................                  0x0800 = Mifare_Pro(X) 
....................                  0x4403 = Mifare_DESFire 
....................  
....................   @returns Returns the status of the request. 
....................            MI_ERR        if something went wrong, 
....................            MI_NOTAGERR   if there was no tag to send the command to. 
....................            MI_OK         if everything went OK. 
....................  
....................  */ 
.................... /**************************************************************************/ 
.................... int requestTag(byte mode, byte *data) { 
....................   int status, len; 
....................   writeToRegister(BitFramingReg, 0x07);  // TxLastBists = BitFramingReg[2..0] 
075F:  MOVLW  0D
0760:  BSF    03.6
0761:  MOVWF  2E
0762:  MOVLW  07
0763:  MOVWF  2F
0764:  BCF    03.6
0765:  CALL   3D9
....................  
....................   data[0] = mode; 
0766:  BSF    03.5
0767:  MOVF   52,W
0768:  MOVWF  04
0769:  BCF    03.7
076A:  BTFSC  53.0
076B:  BSF    03.7
076C:  MOVF   51,W
076D:  MOVWF  00
....................   status = commandTag(MFRC522_TRANSCEIVE, data, 1, data, &len); 
076E:  MOVLW  0C
076F:  BCF    03.5
0770:  BSF    03.6
0771:  MOVWF  1C
0772:  BSF    03.5
0773:  BCF    03.6
0774:  MOVF   53,W
0775:  BCF    03.5
0776:  BSF    03.6
0777:  MOVWF  1E
0778:  BSF    03.5
0779:  BCF    03.6
077A:  MOVF   52,W
077B:  BCF    03.5
077C:  BSF    03.6
077D:  MOVWF  1D
077E:  MOVLW  01
077F:  MOVWF  1F
0780:  BSF    03.5
0781:  BCF    03.6
0782:  MOVF   53,W
0783:  BCF    03.5
0784:  BSF    03.6
0785:  MOVWF  21
0786:  BSF    03.5
0787:  BCF    03.6
0788:  MOVF   52,W
0789:  BCF    03.5
078A:  BSF    03.6
078B:  MOVWF  20
078C:  CLRF   23
078D:  MOVLW  D5
078E:  MOVWF  22
078F:  BCF    03.6
0790:  CALL   664
0791:  MOVF   78,W
0792:  BSF    03.5
0793:  MOVWF  54
....................  
....................   if ((status != MI_OK) || (len != 0x10)) { 
0794:  MOVF   54,F
0795:  BTFSS  03.2
0796:  GOTO   79B
0797:  MOVF   55,W
0798:  SUBLW  10
0799:  BTFSC  03.2
079A:  GOTO   79D
....................     status = MI_ERR; 
079B:  MOVLW  02
079C:  MOVWF  54
....................   } 
....................  
....................   return status; 
079D:  MOVF   54,W
079E:  MOVWF  78
079F:  BCF    03.5
07A0:  BSF    0A.3
07A1:  BCF    0A.4
07A2:  GOTO   68E (RETURN)
.................... } 
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................  
....................   @brief   Handles collisions that might occur if there are multiple 
....................            tags available. 
....................  
....................   @param   serial  The serial nb of the tag. 
....................  
....................   @returns Returns the status of the collision detection. 
....................            MI_ERR        if something went wrong, 
....................            MI_NOTAGERR   if there was no tag to send the command to. 
....................            MI_OK         if everything went OK. 
....................  
....................  */ 
.................... /**************************************************************************/ 
.................... int antiCollision(byte *serial) { 
*
0800:  BSF    03.5
0801:  CLRF   56
....................   int status, i, len; 
....................   byte check = 0x00; 
....................  
....................   writeToRegister(BitFramingReg, 0x00);  // TxLastBits = BitFramingReg[2..0] 
0802:  MOVLW  0D
0803:  BCF    03.5
0804:  BSF    03.6
0805:  MOVWF  2E
0806:  CLRF   2F
0807:  BCF    0A.3
0808:  BCF    03.6
0809:  CALL   3D9
080A:  BSF    0A.3
....................  
....................   serial[0] = MF1_ANTICOLL; 
080B:  BSF    03.5
080C:  MOVF   51,W
080D:  MOVWF  04
080E:  BCF    03.7
080F:  BTFSC  52.0
0810:  BSF    03.7
0811:  MOVLW  93
0812:  MOVWF  00
....................   serial[1] = 0x20; 
0813:  MOVLW  01
0814:  ADDWF  51,W
0815:  MOVWF  04
0816:  BCF    03.7
0817:  BTFSC  52.0
0818:  BSF    03.7
0819:  MOVLW  20
081A:  MOVWF  00
....................   status = commandTag(MFRC522_TRANSCEIVE, serial, 2, serial, &len); 
081B:  MOVLW  0C
081C:  BCF    03.5
081D:  BSF    03.6
081E:  MOVWF  1C
081F:  BSF    03.5
0820:  BCF    03.6
0821:  MOVF   52,W
0822:  BCF    03.5
0823:  BSF    03.6
0824:  MOVWF  1E
0825:  BSF    03.5
0826:  BCF    03.6
0827:  MOVF   51,W
0828:  BCF    03.5
0829:  BSF    03.6
082A:  MOVWF  1D
082B:  MOVLW  02
082C:  MOVWF  1F
082D:  BSF    03.5
082E:  BCF    03.6
082F:  MOVF   52,W
0830:  BCF    03.5
0831:  BSF    03.6
0832:  MOVWF  21
0833:  BSF    03.5
0834:  BCF    03.6
0835:  MOVF   51,W
0836:  BCF    03.5
0837:  BSF    03.6
0838:  MOVWF  20
0839:  CLRF   23
083A:  MOVLW  D5
083B:  MOVWF  22
083C:  BCF    0A.3
083D:  BCF    03.6
083E:  CALL   664
083F:  BSF    0A.3
0840:  MOVF   78,W
0841:  BSF    03.5
0842:  MOVWF  53
....................   len = len / 8; // len is in bits, and we want each byte. 
0843:  RRF    55,F
0844:  RRF    55,F
0845:  RRF    55,F
0846:  MOVLW  1F
0847:  ANDWF  55,F
....................   if (status == MI_OK) { 
0848:  MOVF   53,F
0849:  BTFSS  03.2
084A:  GOTO   067
....................     // The checksum of the tag is the ^ of all the values. 
....................     for (i = 0; i < len-1; i++) { 
084B:  CLRF   54
084C:  MOVLW  01
084D:  SUBWF  55,W
084E:  SUBWF  54,W
084F:  BTFSC  03.0
0850:  GOTO   05B
....................       check ^= serial[i]; 
0851:  MOVF   54,W
0852:  ADDWF  51,W
0853:  MOVWF  04
0854:  BCF    03.7
0855:  BTFSC  52.0
0856:  BSF    03.7
0857:  MOVF   00,W
0858:  XORWF  56,F
0859:  INCF   54,F
085A:  GOTO   04C
....................     } 
....................     // The checksum should be the same as the one provided from the 
....................     // tag (serial[4]). 
....................     if (check != serial[i]) { 
085B:  MOVF   54,W
085C:  ADDWF  51,W
085D:  MOVWF  04
085E:  BCF    03.7
085F:  BTFSC  52.0
0860:  BSF    03.7
0861:  MOVF   00,W
0862:  SUBWF  56,W
0863:  BTFSC  03.2
0864:  GOTO   067
....................       status = MI_ERR; 
0865:  MOVLW  02
0866:  MOVWF  53
....................     } 
....................   } 
....................  
....................   return status; 
0867:  MOVF   53,W
0868:  MOVWF  78
0869:  BCF    03.5
086A:  BSF    0A.3
086B:  BCF    0A.4
086C:  GOTO   6A3 (RETURN)
.................... } 
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................  
....................   @brief   Calculates the CRC value for some data that should be sent to 
....................            a tag. 
....................  
....................   @param   data    The data to calculate the value for. 
....................   @param   len     The length of the data. 
....................   @param   result  The result of the CRC calculation. 
....................  
....................  */ 
.................... /**************************************************************************/ 
.................... void calculateCRC(byte *data, int len, byte *result) { 
....................   int i; 
....................   byte n; 
....................  
....................   clearBitMask(DivIrqReg, 0x04);   // CRCIrq = 0 
086D:  MOVLW  05
086E:  BSF    03.6
086F:  MOVWF  2A
0870:  MOVLW  04
0871:  MOVWF  2B
0872:  BCF    0A.3
0873:  BCF    03.6
0874:  CALL   651
0875:  BSF    0A.3
....................   setBitMask(FIFOLevelReg, 0x80);  // Clear the FIFO pointer 
0876:  MOVLW  0A
0877:  BSF    03.6
0878:  MOVWF  2A
0879:  MOVLW  80
087A:  MOVWF  2B
087B:  BCF    0A.3
087C:  BCF    03.6
087D:  CALL   423
087E:  BSF    0A.3
....................  
....................   //Writing data to the FIFO. 
....................   for (i = 0; i < len; i++) { 
087F:  BSF    03.6
0880:  CLRF   15
0881:  MOVF   12,W
0882:  SUBWF  15,W
0883:  BTFSC  03.0
0884:  GOTO   098
....................     writeToRegister(FIFODataReg, data[i]); 
0885:  MOVF   15,W
0886:  ADDWF  10,W
0887:  MOVWF  04
0888:  BCF    03.7
0889:  BTFSC  11.0
088A:  BSF    03.7
088B:  MOVF   00,W
088C:  MOVWF  17
088D:  MOVLW  09
088E:  MOVWF  2E
088F:  MOVF   17,W
0890:  MOVWF  2F
0891:  BCF    0A.3
0892:  BCF    03.6
0893:  CALL   3D9
0894:  BSF    0A.3
0895:  BSF    03.6
0896:  INCF   15,F
0897:  GOTO   081
....................   } 
....................   writeToRegister(CommandReg, MFRC522_CALCCRC); 
0898:  MOVLW  01
0899:  MOVWF  2E
089A:  MOVLW  03
089B:  MOVWF  2F
089C:  BCF    0A.3
089D:  BCF    03.6
089E:  CALL   3D9
089F:  BSF    0A.3
....................  
....................   // Wait for the CRC calculation to complete. 
....................   i = 0xFF; 
08A0:  MOVLW  FF
08A1:  BSF    03.6
08A2:  MOVWF  15
....................   do { 
....................     n = readFromRegister(DivIrqReg); 
08A3:  MOVLW  05
08A4:  MOVWF  2D
08A5:  BCF    0A.3
08A6:  BCF    03.6
08A7:  CALL   3FA
08A8:  BSF    0A.3
08A9:  MOVF   78,W
08AA:  BSF    03.6
08AB:  MOVWF  16
....................     i--; 
08AC:  DECF   15,F
....................   } while ((i != 0) && !(n & 0x04));  //CRCIrq = 1 
08AD:  MOVF   15,F
08AE:  BTFSC  03.2
08AF:  GOTO   0B2
08B0:  BTFSS  16.2
08B1:  GOTO   0A3
....................  
....................   // Read the result from the CRC calculation. 
....................   result[0] = readFromRegister(CRCResultRegL); 
08B2:  MOVF   13,W
08B3:  MOVWF  17
08B4:  MOVF   14,W
08B5:  MOVWF  18
08B6:  MOVLW  22
08B7:  MOVWF  2D
08B8:  BCF    0A.3
08B9:  BCF    03.6
08BA:  CALL   3FA
08BB:  BSF    0A.3
08BC:  BSF    03.6
08BD:  MOVF   17,W
08BE:  MOVWF  04
08BF:  BCF    03.7
08C0:  BTFSC  18.0
08C1:  BSF    03.7
08C2:  MOVF   78,W
08C3:  MOVWF  00
....................   result[1] = readFromRegister(CRCResultRegM); 
08C4:  MOVLW  01
08C5:  ADDWF  13,W
08C6:  MOVWF  17
08C7:  MOVF   14,W
08C8:  MOVWF  18
08C9:  BTFSC  03.0
08CA:  INCF   18,F
08CB:  MOVLW  21
08CC:  MOVWF  2D
08CD:  BCF    0A.3
08CE:  BCF    03.6
08CF:  CALL   3FA
08D0:  BSF    0A.3
08D1:  BSF    03.6
08D2:  MOVF   17,W
08D3:  MOVWF  04
08D4:  BCF    03.7
08D5:  BTFSC  18.0
08D6:  BSF    03.7
08D7:  MOVF   78,W
08D8:  MOVWF  00
08D9:  BCF    03.6
08DA:  RETURN
.................... } 
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Selects a tag for processing. 
....................   @param   serial  The serial number of the tag that is to be selected. 
....................   @returns The SAK response from the tag. 
....................  */ 
.................... /**************************************************************************/ 
.................... byte selectTag(byte *serial) { 
....................   int i, status, len; 
....................   byte sak; 
....................   byte buffer[9]; 
....................  
....................   buffer[0] = MF1_SELECTTAG; 
08DB:  MOVLW  93
08DC:  BSF    03.5
08DD:  MOVWF  57
....................   buffer[1] = 0x70; 
08DE:  MOVLW  70
08DF:  MOVWF  58
....................   for (i = 0; i < 5; i++) { 
08E0:  CLRF   53
08E1:  MOVF   53,W
08E2:  SUBLW  04
08E3:  BTFSS  03.0
08E4:  GOTO   101
....................     buffer[i+2] = serial[i]; 
08E5:  MOVLW  02
08E6:  ADDWF  53,W
08E7:  ADDLW  D7
08E8:  MOVWF  78
08E9:  CLRF   7A
08EA:  BTFSC  03.0
08EB:  INCF   7A,F
08EC:  MOVF   78,W
08ED:  MOVWF  60
08EE:  MOVF   7A,W
08EF:  MOVWF  61
08F0:  MOVF   53,W
08F1:  ADDWF  51,W
08F2:  MOVWF  04
08F3:  BCF    03.7
08F4:  BTFSC  52.0
08F5:  BSF    03.7
08F6:  MOVF   00,W
08F7:  MOVWF  62
08F8:  MOVF   60,W
08F9:  MOVWF  04
08FA:  BCF    03.7
08FB:  BTFSC  61.0
08FC:  BSF    03.7
08FD:  MOVF   62,W
08FE:  MOVWF  00
08FF:  INCF   53,F
0900:  GOTO   0E1
....................   } 
....................   calculateCRC(buffer, 7, &buffer[7]); 
0901:  BCF    03.5
0902:  BSF    03.6
0903:  CLRF   11
0904:  MOVLW  D7
0905:  MOVWF  10
0906:  MOVLW  07
0907:  MOVWF  12
0908:  CLRF   14
0909:  MOVLW  DE
090A:  MOVWF  13
090B:  BCF    03.6
090C:  CALL   06D
....................  
....................   status = commandTag(MFRC522_TRANSCEIVE, buffer, 9, buffer, &len); 
090D:  MOVLW  0C
090E:  BSF    03.6
090F:  MOVWF  1C
0910:  CLRF   1E
0911:  MOVLW  D7
0912:  MOVWF  1D
0913:  MOVLW  09
0914:  MOVWF  1F
0915:  CLRF   21
0916:  MOVLW  D7
0917:  MOVWF  20
0918:  CLRF   23
0919:  MOVLW  D5
091A:  MOVWF  22
091B:  BCF    0A.3
091C:  BCF    03.6
091D:  CALL   664
091E:  BSF    0A.3
091F:  MOVF   78,W
0920:  BSF    03.5
0921:  MOVWF  54
....................  
....................   if ((status == MI_OK) && (len == 0x18)) { 
0922:  MOVF   54,F
0923:  BTFSS  03.2
0924:  GOTO   12C
0925:  MOVF   55,W
0926:  SUBLW  18
0927:  BTFSS  03.2
0928:  GOTO   12C
....................     sak = buffer[0]; 
0929:  MOVF   57,W
092A:  MOVWF  56
....................   } 
092B:  GOTO   12D
....................   else { 
....................     sak = 0; 
092C:  CLRF   56
....................   } 
....................  
....................   return sak; 
092D:  MOVF   56,W
092E:  MOVWF  78
092F:  BCF    03.5
0930:  BSF    0A.3
0931:  BCF    0A.4
0932:  GOTO   6FE (RETURN)
.................... } 
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Handles the authentication between the tag and the reader. 
....................   @param   mode    What authentication key to use. 
....................   @param   block   The block that we want to read. 
....................   @param   key     The authentication key. 
....................   @param   serial  The serial of the tag. 
....................   @returns Returns the status of the collision detection. 
....................            MI_ERR        if something went wrong, 
....................            MI_OK         if everything went OK. 
....................  */ 
.................... /**************************************************************************/ 
.................... int authenticate(byte mode, byte block, byte *key, byte *serial) { 
....................   int i, status, len; 
....................   byte buffer[12]; 
....................  
....................   //Verify the command block address + sector + password + tag serial number 
....................   buffer[0] = mode;          // 0th byte is the mode 
0933:  BSF    03.5
0934:  MOVF   65,W
0935:  BCF    03.5
0936:  BSF    03.6
0937:  MOVWF  10
....................   buffer[1] = block;         // 1st byte is the block to address. 
0938:  BSF    03.5
0939:  BCF    03.6
093A:  MOVF   66,W
093B:  BCF    03.5
093C:  BSF    03.6
093D:  MOVWF  11
....................   for (i = 0; i < 6; i++) {  // 2nd to 7th byte is the authentication key. 
093E:  BSF    03.5
093F:  BCF    03.6
0940:  CLRF   6B
0941:  MOVF   6B,W
0942:  SUBLW  05
0943:  BTFSS  03.0
0944:  GOTO   16A
....................     buffer[i+2] = key[i]; 
0945:  MOVLW  02
0946:  ADDWF  6B,W
0947:  ADDLW  10
0948:  MOVWF  78
0949:  MOVLW  01
094A:  MOVWF  7A
094B:  BTFSC  03.0
094C:  INCF   7A,F
094D:  MOVF   78,W
094E:  BCF    03.5
094F:  BSF    03.6
0950:  MOVWF  1C
0951:  MOVF   7A,W
0952:  MOVWF  1D
0953:  BSF    03.5
0954:  BCF    03.6
0955:  MOVF   6B,W
0956:  ADDWF  67,W
0957:  MOVWF  04
0958:  BCF    03.7
0959:  BTFSC  68.0
095A:  BSF    03.7
095B:  MOVF   00,W
095C:  BCF    03.5
095D:  BSF    03.6
095E:  MOVWF  1E
095F:  MOVF   1C,W
0960:  MOVWF  04
0961:  BCF    03.7
0962:  BTFSC  1D.0
0963:  BSF    03.7
0964:  MOVF   1E,W
0965:  MOVWF  00
0966:  BSF    03.5
0967:  BCF    03.6
0968:  INCF   6B,F
0969:  GOTO   141
....................   } 
....................   for (i = 0; i < 4; i++) {  // 8th to 11th byte is the serial of the tag. 
096A:  CLRF   6B
096B:  MOVF   6B,W
096C:  SUBLW  03
096D:  BTFSS  03.0
096E:  GOTO   194
....................     buffer[i+8] = serial[i]; 
096F:  MOVLW  08
0970:  ADDWF  6B,W
0971:  ADDLW  10
0972:  MOVWF  78
0973:  MOVLW  01
0974:  MOVWF  7A
0975:  BTFSC  03.0
0976:  INCF   7A,F
0977:  MOVF   78,W
0978:  BCF    03.5
0979:  BSF    03.6
097A:  MOVWF  1C
097B:  MOVF   7A,W
097C:  MOVWF  1D
097D:  BSF    03.5
097E:  BCF    03.6
097F:  MOVF   6B,W
0980:  ADDWF  69,W
0981:  MOVWF  04
0982:  BCF    03.7
0983:  BTFSC  6A.0
0984:  BSF    03.7
0985:  MOVF   00,W
0986:  BCF    03.5
0987:  BSF    03.6
0988:  MOVWF  1E
0989:  MOVF   1C,W
098A:  MOVWF  04
098B:  BCF    03.7
098C:  BTFSC  1D.0
098D:  BSF    03.7
098E:  MOVF   1E,W
098F:  MOVWF  00
0990:  BSF    03.5
0991:  BCF    03.6
0992:  INCF   6B,F
0993:  GOTO   16B
....................   } 
....................  
....................   status = commandTag(MFRC522_AUTHENT, buffer, 12, buffer, &len); 
0994:  MOVLW  0E
0995:  BCF    03.5
0996:  BSF    03.6
0997:  MOVWF  1C
0998:  MOVLW  01
0999:  MOVWF  1E
099A:  MOVLW  10
099B:  MOVWF  1D
099C:  MOVLW  0C
099D:  MOVWF  1F
099E:  MOVLW  01
099F:  MOVWF  21
09A0:  MOVLW  10
09A1:  MOVWF  20
09A2:  CLRF   23
09A3:  MOVLW  ED
09A4:  MOVWF  22
09A5:  BCF    0A.3
09A6:  BCF    03.6
09A7:  CALL   664
09A8:  BSF    0A.3
09A9:  MOVF   78,W
09AA:  BSF    03.5
09AB:  MOVWF  6C
....................  
....................   if ((status != MI_OK) || (!(readFromRegister(Status2Reg) & 0x08))) { 
09AC:  MOVF   6C,F
09AD:  BTFSS  03.2
09AE:  GOTO   1BA
09AF:  MOVLW  08
09B0:  BCF    03.5
09B1:  BSF    03.6
09B2:  MOVWF  2D
09B3:  BCF    0A.3
09B4:  BCF    03.6
09B5:  CALL   3FA
09B6:  BSF    0A.3
09B7:  BTFSC  78.3
09B8:  GOTO   1BD
09B9:  BSF    03.5
....................     status = MI_ERR; 
09BA:  MOVLW  02
09BB:  MOVWF  6C
09BC:  BCF    03.5
....................   } 
....................  
....................   return status; 
09BD:  BSF    03.5
09BE:  MOVF   6C,W
09BF:  MOVWF  78
09C0:  BCF    03.5
09C1:  RETURN
.................... } 
....................  
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Tries to read from the current (authenticated) tag. 
....................   @param   block   The block that we want to read. 
....................   @param   result  The resulting value returned from the tag. 
....................   @returns Returns the status of the collision detection. 
....................            MI_ERR        if something went wrong, 
....................            MI_OK         if everything went OK. 
....................  */ 
.................... /**************************************************************************/ 
.................... int readFromTag(byte block, byte *result) { 
....................   int status, len; 
....................  
....................   result[0] = MF1_READ; 
09C2:  BSF    03.5
09C3:  MOVF   66,W
09C4:  MOVWF  04
09C5:  BCF    03.7
09C6:  BTFSC  67.0
09C7:  BSF    03.7
09C8:  MOVLW  30
09C9:  MOVWF  00
....................   result[1] = block; 
09CA:  MOVLW  01
09CB:  ADDWF  66,W
09CC:  MOVWF  04
09CD:  BCF    03.7
09CE:  BTFSC  67.0
09CF:  BSF    03.7
09D0:  MOVF   65,W
09D1:  MOVWF  00
....................   calculateCRC(result, 2, &result[2]); 
09D2:  MOVLW  02
09D3:  ADDWF  66,W
09D4:  MOVWF  78
09D5:  MOVF   67,W
09D6:  MOVWF  7A
09D7:  BTFSC  03.0
09D8:  INCF   7A,F
09D9:  MOVF   78,W
09DA:  MOVWF  6A
09DB:  MOVF   7A,W
09DC:  MOVWF  6B
09DD:  MOVF   67,W
09DE:  BCF    03.5
09DF:  BSF    03.6
09E0:  MOVWF  11
09E1:  BSF    03.5
09E2:  BCF    03.6
09E3:  MOVF   66,W
09E4:  BCF    03.5
09E5:  BSF    03.6
09E6:  MOVWF  10
09E7:  MOVLW  02
09E8:  MOVWF  12
09E9:  BSF    03.5
09EA:  BCF    03.6
09EB:  MOVF   6B,W
09EC:  BCF    03.5
09ED:  BSF    03.6
09EE:  MOVWF  14
09EF:  BSF    03.5
09F0:  BCF    03.6
09F1:  MOVF   6A,W
09F2:  BCF    03.5
09F3:  BSF    03.6
09F4:  MOVWF  13
09F5:  BCF    03.6
09F6:  CALL   06D
....................   status = commandTag(MFRC522_TRANSCEIVE, result, 4, result, &len); 
09F7:  MOVLW  0C
09F8:  BSF    03.6
09F9:  MOVWF  1C
09FA:  BSF    03.5
09FB:  BCF    03.6
09FC:  MOVF   67,W
09FD:  BCF    03.5
09FE:  BSF    03.6
09FF:  MOVWF  1E
0A00:  BSF    03.5
0A01:  BCF    03.6
0A02:  MOVF   66,W
0A03:  BCF    03.5
0A04:  BSF    03.6
0A05:  MOVWF  1D
0A06:  MOVLW  04
0A07:  MOVWF  1F
0A08:  BSF    03.5
0A09:  BCF    03.6
0A0A:  MOVF   67,W
0A0B:  BCF    03.5
0A0C:  BSF    03.6
0A0D:  MOVWF  21
0A0E:  BSF    03.5
0A0F:  BCF    03.6
0A10:  MOVF   66,W
0A11:  BCF    03.5
0A12:  BSF    03.6
0A13:  MOVWF  20
0A14:  CLRF   23
0A15:  MOVLW  E9
0A16:  MOVWF  22
0A17:  BCF    0A.3
0A18:  BCF    03.6
0A19:  CALL   664
0A1A:  BSF    0A.3
0A1B:  MOVF   78,W
0A1C:  BSF    03.5
0A1D:  MOVWF  68
....................  
....................   if ((status != MI_OK) || (len != 0x90)) { 
0A1E:  MOVF   68,F
0A1F:  BTFSS  03.2
0A20:  GOTO   225
0A21:  MOVF   69,W
0A22:  SUBLW  90
0A23:  BTFSC  03.2
0A24:  GOTO   227
....................     status = MI_ERR; 
0A25:  MOVLW  02
0A26:  MOVWF  68
....................   } 
....................  
....................   return status; 
0A27:  MOVF   68,W
0A28:  MOVWF  78
0A29:  BCF    03.5
0A2A:  RETURN
.................... } 
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Tries to write to a block on the current tag. 
....................   @param   block  The block that we want to write to. 
....................   @param   data   The data that we should write to the block. 
....................   @returns Returns the status of the collision detection. 
....................            MI_ERR        if something went wrong, 
....................            MI_OK         if everything went OK. 
....................  */ 
.................... /**************************************************************************/ 
.................... int writeToTag(byte block, byte *data) { 
....................   int status, i, len; 
....................   byte buffer[18]; 
....................  
....................   buffer[0] = MF1_WRITE; 
*
0C8F:  MOVLW  A0
0C90:  BSF    03.5
0C91:  MOVWF  5C
....................   buffer[1] = block; 
0C92:  MOVF   56,W
0C93:  MOVWF  5D
....................   calculateCRC(buffer, 2, &buffer[2]); 
0C94:  BCF    03.5
0C95:  BSF    03.6
0C96:  CLRF   11
0C97:  MOVLW  DC
0C98:  MOVWF  10
0C99:  MOVLW  02
0C9A:  MOVWF  12
0C9B:  CLRF   14
0C9C:  MOVLW  DE
0C9D:  MOVWF  13
0C9E:  BCF    03.6
0C9F:  CALL   06D
....................   status = commandTag(MFRC522_TRANSCEIVE, buffer, 4, buffer, &len); 
0CA0:  MOVLW  0C
0CA1:  BSF    03.6
0CA2:  MOVWF  1C
0CA3:  CLRF   1E
0CA4:  MOVLW  DC
0CA5:  MOVWF  1D
0CA6:  MOVLW  04
0CA7:  MOVWF  1F
0CA8:  CLRF   21
0CA9:  MOVLW  DC
0CAA:  MOVWF  20
0CAB:  CLRF   23
0CAC:  MOVLW  DB
0CAD:  MOVWF  22
0CAE:  BCF    0A.3
0CAF:  BCF    03.6
0CB0:  CALL   664
0CB1:  BSF    0A.3
0CB2:  MOVF   78,W
0CB3:  BSF    03.5
0CB4:  MOVWF  59
....................  
....................   if ((status != MI_OK) || (len != 4) || ((buffer[0] & 0x0F) != 0x0A)) { 
0CB5:  MOVF   59,F
0CB6:  BTFSS  03.2
0CB7:  GOTO   4C1
0CB8:  MOVF   5B,W
0CB9:  SUBLW  04
0CBA:  BTFSS  03.2
0CBB:  GOTO   4C1
0CBC:  MOVF   5C,W
0CBD:  ANDLW  0F
0CBE:  SUBLW  0A
0CBF:  BTFSC  03.2
0CC0:  GOTO   4C3
....................     status = MI_ERR; 
0CC1:  MOVLW  02
0CC2:  MOVWF  59
....................   } 
....................  
....................  
....................   if (status == MI_OK) { 
0CC3:  MOVF   59,F
0CC4:  BTFSS  03.2
0CC5:  GOTO   51D
....................        
....................     for (i = 0; i < 16; i++) { 
0CC6:  CLRF   5A
0CC7:  MOVF   5A,W
0CC8:  SUBLW  0F
0CC9:  BTFSS  03.0
0CCA:  GOTO   4EE
....................       buffer[i] = data[i]; 
0CCB:  MOVLW  DC
0CCC:  ADDWF  5A,W
0CCD:  MOVWF  78
0CCE:  CLRF   7A
0CCF:  BTFSC  03.0
0CD0:  INCF   7A,F
0CD1:  MOVF   78,W
0CD2:  BCF    03.5
0CD3:  BSF    03.6
0CD4:  MOVWF  10
0CD5:  MOVF   7A,W
0CD6:  MOVWF  11
0CD7:  BSF    03.5
0CD8:  BCF    03.6
0CD9:  MOVF   5A,W
0CDA:  ADDWF  57,W
0CDB:  MOVWF  04
0CDC:  BCF    03.7
0CDD:  BTFSC  58.0
0CDE:  BSF    03.7
0CDF:  MOVF   00,W
0CE0:  BCF    03.5
0CE1:  BSF    03.6
0CE2:  MOVWF  12
0CE3:  MOVF   10,W
0CE4:  MOVWF  04
0CE5:  BCF    03.7
0CE6:  BTFSC  11.0
0CE7:  BSF    03.7
0CE8:  MOVF   12,W
0CE9:  MOVWF  00
0CEA:  BSF    03.5
0CEB:  BCF    03.6
0CEC:  INCF   5A,F
0CED:  GOTO   4C7
....................     } 
....................     calculateCRC(buffer, 16, &buffer[16]); 
0CEE:  BCF    03.5
0CEF:  BSF    03.6
0CF0:  CLRF   11
0CF1:  MOVLW  DC
0CF2:  MOVWF  10
0CF3:  MOVLW  10
0CF4:  MOVWF  12
0CF5:  CLRF   14
0CF6:  MOVLW  EC
0CF7:  MOVWF  13
0CF8:  BCF    03.6
0CF9:  CALL   06D
....................     status = commandTag(MFRC522_TRANSCEIVE, buffer, 18, buffer, &len); 
0CFA:  MOVLW  0C
0CFB:  BSF    03.6
0CFC:  MOVWF  1C
0CFD:  CLRF   1E
0CFE:  MOVLW  DC
0CFF:  MOVWF  1D
0D00:  MOVLW  12
0D01:  MOVWF  1F
0D02:  CLRF   21
0D03:  MOVLW  DC
0D04:  MOVWF  20
0D05:  CLRF   23
0D06:  MOVLW  DB
0D07:  MOVWF  22
0D08:  BCF    0A.3
0D09:  BCF    03.6
0D0A:  CALL   664
0D0B:  BSF    0A.3
0D0C:  MOVF   78,W
0D0D:  BSF    03.5
0D0E:  MOVWF  59
....................  
....................     if ((status != MI_OK) || (len != 4) || ((buffer[0] & 0x0F) != 0x0A)) { 
0D0F:  MOVF   59,F
0D10:  BTFSS  03.2
0D11:  GOTO   51B
0D12:  MOVF   5B,W
0D13:  SUBLW  04
0D14:  BTFSS  03.2
0D15:  GOTO   51B
0D16:  MOVF   5C,W
0D17:  ANDLW  0F
0D18:  SUBLW  0A
0D19:  BTFSC  03.2
0D1A:  GOTO   51D
....................       status = MI_ERR; 
0D1B:  MOVLW  02
0D1C:  MOVWF  59
....................     } 
....................   } 
....................  
....................   return status; 
0D1D:  MOVF   59,W
0D1E:  MOVWF  78
0D1F:  BCF    03.5
0D20:  RETURN
.................... } 
....................  
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Sends a halt command to the current tag. 
....................   @returns Returns the result of the halt. 
....................            MI_ERR        If the command didn't complete properly. 
....................            MI_OK         If the command completed. 
....................  */ 
.................... /**************************************************************************/ 
.................... int haltTag() { 
....................   int status, len; 
....................   byte buffer[4]; 
....................  
....................   buffer[0] = MF1_HALT; 
*
0DCB:  MOVLW  50
0DCC:  BSF    03.5
0DCD:  MOVWF  53
....................   buffer[1] = 0; 
0DCE:  CLRF   54
....................   calculateCRC(buffer, 2, &buffer[2]); 
0DCF:  BCF    03.5
0DD0:  BSF    03.6
0DD1:  CLRF   11
0DD2:  MOVLW  D3
0DD3:  MOVWF  10
0DD4:  MOVLW  02
0DD5:  MOVWF  12
0DD6:  CLRF   14
0DD7:  MOVLW  D5
0DD8:  MOVWF  13
0DD9:  BCF    03.6
0DDA:  CALL   06D
....................   status = commandTag(MFRC522_TRANSCEIVE, buffer, 4, buffer, &len); 
0DDB:  MOVLW  0C
0DDC:  BSF    03.6
0DDD:  MOVWF  1C
0DDE:  CLRF   1E
0DDF:  MOVLW  D3
0DE0:  MOVWF  1D
0DE1:  MOVLW  04
0DE2:  MOVWF  1F
0DE3:  CLRF   21
0DE4:  MOVLW  D3
0DE5:  MOVWF  20
0DE6:  CLRF   23
0DE7:  MOVLW  D2
0DE8:  MOVWF  22
0DE9:  BCF    0A.3
0DEA:  BCF    03.6
0DEB:  CALL   664
0DEC:  BSF    0A.3
0DED:  MOVF   78,W
0DEE:  BSF    03.5
0DEF:  MOVWF  51
....................   clearBitMask(Status2Reg, 0x08);  // turn off encryption 
0DF0:  MOVLW  08
0DF1:  BCF    03.5
0DF2:  BSF    03.6
0DF3:  MOVWF  2A
0DF4:  MOVWF  2B
0DF5:  BCF    0A.3
0DF6:  BCF    03.6
0DF7:  CALL   651
0DF8:  BSF    0A.3
....................   return status; 
0DF9:  BSF    03.5
0DFA:  MOVF   51,W
0DFB:  MOVWF  78
0DFC:  BCF    03.5
0DFD:  BSF    0A.3
0DFE:  BCF    0A.4
0DFF:  GOTO   779 (RETURN)
.................... } 
....................  
....................  
.................... //// 
.................... //  Mifare Card Types Depending upon the codes of SAK from AN1083.PDF 
.................... //// 
....................  
.................... enum MIFARE_CARD_TYPE { 
....................     UID_FAILED = 0x00, 
....................     UID_NOT_COMPLETE = 0x04, 
....................     MIFARE_DESFIRE = 0x24, //MIFARE DESFire CL1, MIFARE DESFire EV1 CL1  
....................     MIFARE_MINI = 0x09, 
....................     MIFARE_CLASSIC_1K = 0x08, 
....................     MIFARE_CLASSIC_4K = 0x18, 
....................     MIFARE_DESFIRE = 0x20 
.................... }; 
....................  
....................  
....................  
....................  
.................... byte FoundTag; // Variable used to check if Tag was found 
.................... byte ReadTag; // Variable used to store anti-collision value to read Tag information 
.................... byte TagData[MAX_LEN]; // Variable used to store Full Tag Data 
.................... byte serial[5]; 
.................... byte i; //for looping 
.................... byte j; //for looping again 
.................... byte status; // to store the return status of command operations 
.................... byte data[MAX_LEN]; //to store any data 
....................  
.................... char buffer2[20]; 
....................  
.................... //keys for the card 
.................... byte keyA[6] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}; 
*
0E1B:  MOVLW  FF
0E1C:  MOVWF  65
0E1D:  MOVWF  66
0E1E:  MOVWF  67
0E1F:  MOVWF  68
0E20:  MOVWF  69
0E21:  MOVWF  6A
.................... byte keyB[6] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}; 
0E22:  MOVWF  6B
0E23:  MOVWF  6C
0E24:  MOVWF  6D
0E25:  MOVWF  6E
0E26:  MOVWF  6F
0E27:  MOVWF  70
....................  
....................  
.................... //writeable data  
.................... byte writeableData[] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10}; 
0E28:  MOVLW  01
0E29:  BSF    03.5
0E2A:  MOVWF  20
0E2B:  MOVLW  02
0E2C:  MOVWF  21
0E2D:  MOVLW  03
0E2E:  MOVWF  22
0E2F:  MOVLW  04
0E30:  MOVWF  23
0E31:  MOVLW  05
0E32:  MOVWF  24
0E33:  MOVLW  06
0E34:  MOVWF  25
0E35:  MOVLW  07
0E36:  MOVWF  26
0E37:  MOVLW  08
0E38:  MOVWF  27
0E39:  MOVLW  09
0E3A:  MOVWF  28
0E3B:  MOVLW  0A
0E3C:  MOVWF  29
0E3D:  MOVLW  0B
0E3E:  MOVWF  2A
0E3F:  MOVLW  0C
0E40:  MOVWF  2B
0E41:  MOVLW  0D
0E42:  MOVWF  2C
0E43:  MOVLW  0E
0E44:  MOVWF  2D
0E45:  MOVLW  0F
0E46:  MOVWF  2E
0E47:  MOVLW  10
0E48:  MOVWF  2F
....................  
....................  
....................  
.................... ///////// 
.................... ///     Check RFID Hardware 
.................... ///////// 
....................  
.................... void CheckRFIDHardware() { 
....................  
....................     char version; ///Version of RFID read/writer is stored 0x92 is version 2.0 
....................     ///Version 1.0 is 0x91 
....................  
....................     lcd_putc("\f Checking RFID..."); 
*
0539:  MOVLW  04
053A:  BSF    03.6
053B:  MOVWF  0D
053C:  MOVLW  00
053D:  MOVWF  0F
053E:  BCF    03.6
053F:  CALL   2EF
....................     printf("\r\nChecking If Rfid Is Connected"); 
0540:  MOVLW  0E
0541:  BSF    03.6
0542:  MOVWF  0D
0543:  MOVLW  00
0544:  MOVWF  0F
0545:  BCF    03.6
0546:  CALL   363
....................  
....................     //Request from the register 
....................     version = readFromRegister(VersionReg); 
0547:  MOVLW  37
0548:  BSF    03.6
0549:  MOVWF  2D
054A:  BCF    03.6
054B:  CALL   3FA
054C:  MOVF   78,W
054D:  BSF    03.5
054E:  MOVWF  51
....................     delay_ms(100); 
054F:  MOVLW  64
0550:  BCF    03.5
0551:  BSF    03.6
0552:  MOVWF  2A
0553:  BCF    03.6
0554:  CALL   16C
....................  
....................  
....................     //response is 00 then hardware is not connected 
....................     if (!version) { 
0555:  BSF    03.5
0556:  MOVF   51,F
0557:  BTFSS  03.2
0558:  GOTO   574
....................         lcd_putc("\f RFID Not Found \n Check Again.."); 
0559:  MOVLW  1E
055A:  BCF    03.5
055B:  BSF    03.6
055C:  MOVWF  0D
055D:  MOVLW  00
055E:  MOVWF  0F
055F:  BCF    03.6
0560:  CALL   2EF
....................         printf("\r\nRFID Hw not Found"); 
0561:  MOVLW  2F
0562:  BSF    03.6
0563:  MOVWF  0D
0564:  MOVLW  00
0565:  MOVWF  0F
0566:  BCF    03.6
0567:  CALL   363
....................         delay_ms(5000); 
0568:  MOVLW  14
0569:  BSF    03.5
056A:  MOVWF  52
056B:  MOVLW  FA
056C:  BCF    03.5
056D:  BSF    03.6
056E:  MOVWF  2A
056F:  BCF    03.6
0570:  CALL   16C
0571:  BSF    03.5
0572:  DECFSZ 52,F
0573:  GOTO   56B
....................     } 
....................     if (version) { 
0574:  MOVF   51,F
0575:  BTFSC  03.2
0576:  GOTO   64D
....................         lcd_putc("\f RFID Found"); 
0577:  MOVLW  39
0578:  BCF    03.5
0579:  BSF    03.6
057A:  MOVWF  0D
057B:  MOVLW  00
057C:  MOVWF  0F
057D:  BCF    03.6
057E:  CALL   2EF
....................         printf(lcd_putc, "\nV: %x", version); 
057F:  MOVLW  40
0580:  BSF    03.6
0581:  MOVWF  0D
0582:  MOVLW  00
0583:  MOVWF  0F
0584:  BCF    03.0
0585:  MOVLW  04
0586:  BSF    03.5
0587:  BCF    03.6
0588:  MOVWF  52
*
05FF:  MOVF   51,W
0600:  MOVWF  52
0601:  MOVLW  57
0602:  MOVWF  53
....................         printf("\r\nRFID Found and HW version is: 0x%2X\r\n", version); 
*
0626:  MOVLW  44
0627:  BSF    03.6
0628:  MOVWF  0D
0629:  MOVLW  00
062A:  MOVWF  0F
062B:  BCF    03.0
062C:  MOVLW  22
062D:  BSF    03.5
062E:  BCF    03.6
062F:  MOVWF  65
0630:  BCF    03.5
0631:  CALL   496
0632:  BSF    03.5
0633:  MOVF   51,W
0634:  MOVWF  65
0635:  MOVLW  37
0636:  MOVWF  66
0637:  BCF    03.5
0638:  CALL   512
0639:  MOVLW  0D
063A:  BTFSS  0C.4
063B:  GOTO   63A
063C:  MOVWF  19
063D:  MOVLW  0A
063E:  BTFSS  0C.4
063F:  GOTO   63E
0640:  MOVWF  19
....................         delay_ms(1000); 
0641:  MOVLW  04
0642:  BSF    03.5
0643:  MOVWF  52
0644:  MOVLW  FA
0645:  BCF    03.5
0646:  BSF    03.6
0647:  MOVWF  2A
0648:  BCF    03.6
0649:  CALL   16C
064A:  BSF    03.5
064B:  DECFSZ 52,F
064C:  GOTO   644
....................     } 
064D:  BCF    03.5
064E:  BSF    0A.3
064F:  BCF    0A.4
0650:  GOTO   684 (RETURN)
....................  
.................... } 
....................  
....................  
.................... ////// 
.................... ///     Function to read all the data from the card 
.................... ///     Read all the data from the mifare card and out puts to serial terminal     
.................... ///// 
....................  
.................... void readAll(void) { 
....................  
....................     //s50 has 64 blocks of memory 
....................     for (i = 0; i < 64; i++) { 
*
0A2B:  CLRF   3E
0A2C:  MOVF   3E,W
0A2D:  SUBLW  3F
0A2E:  BTFSS  03.0
0A2F:  GOTO   362
....................         // Try to authenticate each block first with the A key. 
....................         status = authenticate(MF1_AUTHENT1A, i, keyA, serial); 
0A30:  MOVLW  60
0A31:  BSF    03.5
0A32:  MOVWF  65
0A33:  BCF    03.5
0A34:  MOVF   3E,W
0A35:  BSF    03.5
0A36:  MOVWF  66
0A37:  CLRF   68
0A38:  MOVLW  65
0A39:  MOVWF  67
0A3A:  CLRF   6A
0A3B:  MOVLW  39
0A3C:  MOVWF  69
0A3D:  BCF    03.5
0A3E:  CALL   133
0A3F:  MOVF   78,W
0A40:  MOVWF  40
....................         if (MI_OK == status) { 
0A41:  MOVF   40,F
0A42:  BTFSS  03.2
0A43:  GOTO   2C2
....................             printf("Authenticated block 0x%2X with A\r\n",i); 
0A44:  MOVLW  58
0A45:  BSF    03.6
0A46:  MOVWF  0D
0A47:  MOVLW  00
0A48:  MOVWF  0F
0A49:  BCF    03.0
0A4A:  MOVLW  16
0A4B:  BSF    03.5
0A4C:  BCF    03.6
0A4D:  MOVWF  65
0A4E:  BCF    0A.3
0A4F:  BCF    03.5
0A50:  CALL   496
0A51:  BSF    0A.3
0A52:  MOVF   3E,W
0A53:  BSF    03.5
0A54:  MOVWF  65
0A55:  MOVLW  37
0A56:  MOVWF  66
0A57:  BCF    0A.3
0A58:  BCF    03.5
0A59:  CALL   512
0A5A:  BSF    0A.3
0A5B:  MOVLW  64
0A5C:  BSF    03.6
0A5D:  MOVWF  0D
0A5E:  MOVLW  00
0A5F:  MOVWF  0F
0A60:  BSF    03.0
0A61:  MOVLW  09
0A62:  BSF    03.5
0A63:  BCF    03.6
0A64:  MOVWF  65
0A65:  BCF    0A.3
0A66:  BCF    03.5
0A67:  CALL   496
0A68:  BSF    0A.3
....................             printf("\r\n"); //a new line each block 
0A69:  MOVLW  0D
0A6A:  BTFSS  0C.4
0A6B:  GOTO   26A
0A6C:  MOVWF  19
0A6D:  MOVLW  0A
0A6E:  BTFSS  0C.4
0A6F:  GOTO   26E
0A70:  MOVWF  19
....................             //now read the block i  
....................             status = readFromTag(i, data); 
0A71:  MOVF   3E,W
0A72:  BSF    03.5
0A73:  MOVWF  65
0A74:  CLRF   67
0A75:  MOVLW  41
0A76:  MOVWF  66
0A77:  BCF    03.5
0A78:  CALL   1C2
0A79:  MOVF   78,W
0A7A:  MOVWF  40
....................             if (MI_OK == status) { 
0A7B:  MOVF   40,F
0A7C:  BTFSS  03.2
0A7D:  GOTO   2B8
....................                 for (j = 0; j < 15; j++) { 
0A7E:  CLRF   3F
0A7F:  MOVF   3F,W
0A80:  SUBLW  0E
0A81:  BTFSS  03.0
0A82:  GOTO   2A6
....................                     printf("0x%2X, ", data[j]); 
0A83:  MOVLW  41
0A84:  ADDWF  3F,W
0A85:  MOVWF  04
0A86:  BCF    03.7
0A87:  MOVF   00,W
0A88:  BSF    03.5
0A89:  MOVWF  51
0A8A:  MOVLW  30
0A8B:  BCF    03.5
0A8C:  BTFSS  0C.4
0A8D:  GOTO   28C
0A8E:  MOVWF  19
0A8F:  MOVLW  78
0A90:  BTFSS  0C.4
0A91:  GOTO   290
0A92:  MOVWF  19
0A93:  BSF    03.5
0A94:  MOVF   51,W
0A95:  MOVWF  65
0A96:  MOVLW  37
0A97:  MOVWF  66
0A98:  BCF    0A.3
0A99:  BCF    03.5
0A9A:  CALL   512
0A9B:  BSF    0A.3
0A9C:  MOVLW  2C
0A9D:  BTFSS  0C.4
0A9E:  GOTO   29D
0A9F:  MOVWF  19
0AA0:  MOVLW  20
0AA1:  BTFSS  0C.4
0AA2:  GOTO   2A1
0AA3:  MOVWF  19
0AA4:  INCF   3F,F
0AA5:  GOTO   27F
....................                 } 
....................                 printf("0x%2X", data[15]); 
0AA6:  MOVLW  30
0AA7:  BTFSS  0C.4
0AA8:  GOTO   2A7
0AA9:  MOVWF  19
0AAA:  MOVLW  78
0AAB:  BTFSS  0C.4
0AAC:  GOTO   2AB
0AAD:  MOVWF  19
0AAE:  MOVF   50,W
0AAF:  BSF    03.5
0AB0:  MOVWF  65
0AB1:  MOVLW  37
0AB2:  MOVWF  66
0AB3:  BCF    0A.3
0AB4:  BCF    03.5
0AB5:  CALL   512
0AB6:  BSF    0A.3
....................             } else { 
0AB7:  GOTO   2C1
....................                 printf("Read failed\r\n"); 
0AB8:  MOVLW  6A
0AB9:  BSF    03.6
0ABA:  MOVWF  0D
0ABB:  MOVLW  00
0ABC:  MOVWF  0F
0ABD:  BCF    0A.3
0ABE:  BCF    03.6
0ABF:  CALL   363
0AC0:  BSF    0A.3
....................             } 
....................  
....................         } else { 
0AC1:  GOTO   360
....................             //try to authenticate with key B 
....................             status = authenticate(MF1_AUTHENT1B, i, keyB, serial); 
0AC2:  MOVLW  61
0AC3:  BSF    03.5
0AC4:  MOVWF  65
0AC5:  BCF    03.5
0AC6:  MOVF   3E,W
0AC7:  BSF    03.5
0AC8:  MOVWF  66
0AC9:  CLRF   68
0ACA:  MOVLW  6B
0ACB:  MOVWF  67
0ACC:  CLRF   6A
0ACD:  MOVLW  39
0ACE:  MOVWF  69
0ACF:  BCF    03.5
0AD0:  CALL   133
0AD1:  MOVF   78,W
0AD2:  MOVWF  40
....................             if (MI_OK == status) { 
0AD3:  MOVF   40,F
0AD4:  BTFSS  03.2
0AD5:  GOTO   349
....................                 printf("Authenticated block 0x%2X with key B",i); 
0AD6:  MOVLW  71
0AD7:  BSF    03.6
0AD8:  MOVWF  0D
0AD9:  MOVLW  00
0ADA:  MOVWF  0F
0ADB:  BCF    03.0
0ADC:  MOVLW  16
0ADD:  BSF    03.5
0ADE:  BCF    03.6
0ADF:  MOVWF  65
0AE0:  BCF    0A.3
0AE1:  BCF    03.5
0AE2:  CALL   496
0AE3:  BSF    0A.3
0AE4:  MOVF   3E,W
0AE5:  BSF    03.5
0AE6:  MOVWF  65
0AE7:  MOVLW  37
0AE8:  MOVWF  66
0AE9:  BCF    0A.3
0AEA:  BCF    03.5
0AEB:  CALL   512
0AEC:  BSF    0A.3
0AED:  MOVLW  7D
0AEE:  BSF    03.6
0AEF:  MOVWF  0D
0AF0:  MOVLW  00
0AF1:  MOVWF  0F
0AF2:  BSF    03.0
0AF3:  MOVLW  0B
0AF4:  BSF    03.5
0AF5:  BCF    03.6
0AF6:  MOVWF  65
0AF7:  BCF    0A.3
0AF8:  BCF    03.5
0AF9:  CALL   496
0AFA:  BSF    0A.3
....................                 printf("\r\n"); //a new line each block 
0AFB:  MOVLW  0D
0AFC:  BTFSS  0C.4
0AFD:  GOTO   2FC
0AFE:  MOVWF  19
0AFF:  MOVLW  0A
0B00:  BTFSS  0C.4
0B01:  GOTO   300
0B02:  MOVWF  19
....................  
....................                 //read from block 
....................                 status = readFromTag(i, data); 
0B03:  MOVF   3E,W
0B04:  BSF    03.5
0B05:  MOVWF  65
0B06:  CLRF   67
0B07:  MOVLW  41
0B08:  MOVWF  66
0B09:  BCF    03.5
0B0A:  CALL   1C2
0B0B:  MOVF   78,W
0B0C:  MOVWF  40
....................  
....................                 if (MI_OK == status) { 
0B0D:  MOVF   40,F
0B0E:  BTFSS  03.2
0B0F:  GOTO   33F
....................                     for (j = 0; j < 15; j++) { 
0B10:  CLRF   3F
0B11:  MOVF   3F,W
0B12:  SUBLW  0E
0B13:  BTFSS  03.0
0B14:  GOTO   32D
....................                         printf("%2X, ", data[j]); 
0B15:  MOVLW  41
0B16:  ADDWF  3F,W
0B17:  MOVWF  04
0B18:  BCF    03.7
0B19:  MOVF   00,W
0B1A:  BSF    03.5
0B1B:  MOVWF  51
0B1C:  MOVWF  65
0B1D:  MOVLW  37
0B1E:  MOVWF  66
0B1F:  BCF    0A.3
0B20:  BCF    03.5
0B21:  CALL   512
0B22:  BSF    0A.3
0B23:  MOVLW  2C
0B24:  BTFSS  0C.4
0B25:  GOTO   324
0B26:  MOVWF  19
0B27:  MOVLW  20
0B28:  BTFSS  0C.4
0B29:  GOTO   328
0B2A:  MOVWF  19
0B2B:  INCF   3F,F
0B2C:  GOTO   311
....................                     } 
....................                     printf("%2X, ", data[15]); 
0B2D:  MOVF   50,W
0B2E:  BSF    03.5
0B2F:  MOVWF  65
0B30:  MOVLW  37
0B31:  MOVWF  66
0B32:  BCF    0A.3
0B33:  BCF    03.5
0B34:  CALL   512
0B35:  BSF    0A.3
0B36:  MOVLW  2C
0B37:  BTFSS  0C.4
0B38:  GOTO   337
0B39:  MOVWF  19
0B3A:  MOVLW  20
0B3B:  BTFSS  0C.4
0B3C:  GOTO   33B
0B3D:  MOVWF  19
....................                 } else { 
0B3E:  GOTO   348
....................                     printf("Read failed \r\n"); 
0B3F:  MOVLW  84
0B40:  BSF    03.6
0B41:  MOVWF  0D
0B42:  MOVLW  00
0B43:  MOVWF  0F
0B44:  BCF    0A.3
0B45:  BCF    03.6
0B46:  CALL   363
0B47:  BSF    0A.3
....................                 } 
....................  
....................             } else { 
0B48:  GOTO   360
....................                 printf("Access denied at block 0x%2X", i); 
0B49:  MOVLW  8C
0B4A:  BSF    03.6
0B4B:  MOVWF  0D
0B4C:  MOVLW  00
0B4D:  MOVWF  0F
0B4E:  BCF    03.0
0B4F:  MOVLW  19
0B50:  BSF    03.5
0B51:  BCF    03.6
0B52:  MOVWF  65
0B53:  BCF    0A.3
0B54:  BCF    03.5
0B55:  CALL   496
0B56:  BSF    0A.3
0B57:  MOVF   3E,W
0B58:  BSF    03.5
0B59:  MOVWF  65
0B5A:  MOVLW  37
0B5B:  MOVWF  66
0B5C:  BCF    0A.3
0B5D:  BCF    03.5
0B5E:  CALL   512
0B5F:  BSF    0A.3
....................             } 
....................         } 
0B60:  INCF   3E,F
0B61:  GOTO   22C
....................     } 
0B62:  BSF    0A.3
0B63:  BCF    0A.4
0B64:  GOTO   744 (RETURN)
....................  
....................  
.................... } 
....................  
....................  
.................... void readBlock(int sector, int block, byte* readData) { 
0B65:  BSF    03.5
0B66:  RLF    51,W
0B67:  MOVWF  77
0B68:  RLF    77,F
0B69:  MOVLW  FC
0B6A:  ANDWF  77,F
0B6B:  MOVF   77,W
0B6C:  ADDWF  52,W
0B6D:  MOVWF  55
....................      
....................     int readBlock = ( sector * 4 ) + block; 
....................      
....................     byte blockData[15]; 
....................  
....................     // Try to authenticate each block first with the A key. 
....................     status = authenticate(MF1_AUTHENT1A, readBlock, keyA, serial); 
0B6E:  MOVLW  60
0B6F:  MOVWF  65
0B70:  MOVF   55,W
0B71:  MOVWF  66
0B72:  CLRF   68
0B73:  MOVLW  65
0B74:  MOVWF  67
0B75:  CLRF   6A
0B76:  MOVLW  39
0B77:  MOVWF  69
0B78:  BCF    03.5
0B79:  CALL   133
0B7A:  MOVF   78,W
0B7B:  MOVWF  40
....................     if (MI_OK == status) { 
0B7C:  MOVF   40,F
0B7D:  BTFSS  03.2
0B7E:  GOTO   3F1
....................         printf("Authenticated block 0x%2X with A\r\n",i); 
0B7F:  MOVLW  9B
0B80:  BSF    03.6
0B81:  MOVWF  0D
0B82:  MOVLW  00
0B83:  MOVWF  0F
0B84:  BCF    03.0
0B85:  MOVLW  16
0B86:  BSF    03.5
0B87:  BCF    03.6
0B88:  MOVWF  65
0B89:  BCF    0A.3
0B8A:  BCF    03.5
0B8B:  CALL   496
0B8C:  BSF    0A.3
0B8D:  MOVF   3E,W
0B8E:  BSF    03.5
0B8F:  MOVWF  65
0B90:  MOVLW  37
0B91:  MOVWF  66
0B92:  BCF    0A.3
0B93:  BCF    03.5
0B94:  CALL   512
0B95:  BSF    0A.3
0B96:  MOVLW  A7
0B97:  BSF    03.6
0B98:  MOVWF  0D
0B99:  MOVLW  00
0B9A:  MOVWF  0F
0B9B:  BSF    03.0
0B9C:  MOVLW  09
0B9D:  BSF    03.5
0B9E:  BCF    03.6
0B9F:  MOVWF  65
0BA0:  BCF    0A.3
0BA1:  BCF    03.5
0BA2:  CALL   496
0BA3:  BSF    0A.3
....................         printf("\r\n"); //a new line each block 
0BA4:  MOVLW  0D
0BA5:  BTFSS  0C.4
0BA6:  GOTO   3A5
0BA7:  MOVWF  19
0BA8:  MOVLW  0A
0BA9:  BTFSS  0C.4
0BAA:  GOTO   3A9
0BAB:  MOVWF  19
....................         //now read the block i  
....................         status = readFromTag(readBlock, data); 
0BAC:  BSF    03.5
0BAD:  MOVF   55,W
0BAE:  MOVWF  65
0BAF:  CLRF   67
0BB0:  MOVLW  41
0BB1:  MOVWF  66
0BB2:  BCF    03.5
0BB3:  CALL   1C2
0BB4:  MOVF   78,W
0BB5:  MOVWF  40
....................         if (MI_OK == status) { 
0BB6:  MOVF   40,F
0BB7:  BTFSS  03.2
0BB8:  GOTO   3E7
....................             for (j = 0; j < 15; j++) {                 
0BB9:  CLRF   3F
0BBA:  MOVF   3F,W
0BBB:  SUBLW  0E
0BBC:  BTFSS  03.0
0BBD:  GOTO   3DC
....................                 readData[j] = data[j]; 
0BBE:  MOVF   3F,W
0BBF:  BSF    03.5
0BC0:  ADDWF  53,W
0BC1:  MOVWF  78
0BC2:  MOVF   54,W
0BC3:  MOVWF  7A
0BC4:  BTFSC  03.0
0BC5:  INCF   7A,F
0BC6:  MOVF   78,W
0BC7:  MOVWF  65
0BC8:  MOVF   7A,W
0BC9:  MOVWF  66
0BCA:  MOVLW  41
0BCB:  BCF    03.5
0BCC:  ADDWF  3F,W
0BCD:  MOVWF  04
0BCE:  BCF    03.7
0BCF:  MOVF   00,W
0BD0:  BSF    03.5
0BD1:  MOVWF  67
0BD2:  MOVF   65,W
0BD3:  MOVWF  04
0BD4:  BCF    03.7
0BD5:  BTFSC  66.0
0BD6:  BSF    03.7
0BD7:  MOVF   67,W
0BD8:  MOVWF  00
0BD9:  BCF    03.5
0BDA:  INCF   3F,F
0BDB:  GOTO   3BA
....................             } 
....................             readData[15] = data[15]; 
0BDC:  MOVLW  0F
0BDD:  BSF    03.5
0BDE:  ADDWF  53,W
0BDF:  MOVWF  04
0BE0:  BCF    03.7
0BE1:  BTFSC  54.0
0BE2:  BSF    03.7
0BE3:  BCF    03.5
0BE4:  MOVF   50,W
0BE5:  MOVWF  00
....................         } else { 
0BE6:  GOTO   3F0
....................             printf("Read failed\r\n"); 
0BE7:  MOVLW  AD
0BE8:  BSF    03.6
0BE9:  MOVWF  0D
0BEA:  MOVLW  00
0BEB:  MOVWF  0F
0BEC:  BCF    0A.3
0BED:  BCF    03.6
0BEE:  CALL   363
0BEF:  BSF    0A.3
....................         } 
....................  
....................     } else { 
0BF0:  GOTO   48C
....................         //try to authenticate with key B 
....................         status = authenticate(MF1_AUTHENT1B, readBlock, keyB, serial); 
0BF1:  MOVLW  61
0BF2:  BSF    03.5
0BF3:  MOVWF  65
0BF4:  MOVF   55,W
0BF5:  MOVWF  66
0BF6:  CLRF   68
0BF7:  MOVLW  6B
0BF8:  MOVWF  67
0BF9:  CLRF   6A
0BFA:  MOVLW  39
0BFB:  MOVWF  69
0BFC:  BCF    03.5
0BFD:  CALL   133
0BFE:  MOVF   78,W
0BFF:  MOVWF  40
....................         if (MI_OK == status) { 
0C00:  MOVF   40,F
0C01:  BTFSS  03.2
0C02:  GOTO   475
....................             printf("Authenticated block 0x%2X with key B",i); 
0C03:  MOVLW  B4
0C04:  BSF    03.6
0C05:  MOVWF  0D
0C06:  MOVLW  00
0C07:  MOVWF  0F
0C08:  BCF    03.0
0C09:  MOVLW  16
0C0A:  BSF    03.5
0C0B:  BCF    03.6
0C0C:  MOVWF  65
0C0D:  BCF    0A.3
0C0E:  BCF    03.5
0C0F:  CALL   496
0C10:  BSF    0A.3
0C11:  MOVF   3E,W
0C12:  BSF    03.5
0C13:  MOVWF  65
0C14:  MOVLW  37
0C15:  MOVWF  66
0C16:  BCF    0A.3
0C17:  BCF    03.5
0C18:  CALL   512
0C19:  BSF    0A.3
0C1A:  MOVLW  C0
0C1B:  BSF    03.6
0C1C:  MOVWF  0D
0C1D:  MOVLW  00
0C1E:  MOVWF  0F
0C1F:  BSF    03.0
0C20:  MOVLW  0B
0C21:  BSF    03.5
0C22:  BCF    03.6
0C23:  MOVWF  65
0C24:  BCF    0A.3
0C25:  BCF    03.5
0C26:  CALL   496
0C27:  BSF    0A.3
....................             printf("\r\n"); //a new line each block 
0C28:  MOVLW  0D
0C29:  BTFSS  0C.4
0C2A:  GOTO   429
0C2B:  MOVWF  19
0C2C:  MOVLW  0A
0C2D:  BTFSS  0C.4
0C2E:  GOTO   42D
0C2F:  MOVWF  19
....................  
....................             //read from block 
....................             status = readFromTag(i, data); 
0C30:  MOVF   3E,W
0C31:  BSF    03.5
0C32:  MOVWF  65
0C33:  CLRF   67
0C34:  MOVLW  41
0C35:  MOVWF  66
0C36:  BCF    03.5
0C37:  CALL   1C2
0C38:  MOVF   78,W
0C39:  MOVWF  40
....................  
....................             if (MI_OK == status) { 
0C3A:  MOVF   40,F
0C3B:  BTFSS  03.2
0C3C:  GOTO   46B
....................                 for (j = 0; j < 15; j++) {                 
0C3D:  CLRF   3F
0C3E:  MOVF   3F,W
0C3F:  SUBLW  0E
0C40:  BTFSS  03.0
0C41:  GOTO   460
....................                     readData[j] = data[j]; 
0C42:  MOVF   3F,W
0C43:  BSF    03.5
0C44:  ADDWF  53,W
0C45:  MOVWF  78
0C46:  MOVF   54,W
0C47:  MOVWF  7A
0C48:  BTFSC  03.0
0C49:  INCF   7A,F
0C4A:  MOVF   78,W
0C4B:  MOVWF  65
0C4C:  MOVF   7A,W
0C4D:  MOVWF  66
0C4E:  MOVLW  41
0C4F:  BCF    03.5
0C50:  ADDWF  3F,W
0C51:  MOVWF  04
0C52:  BCF    03.7
0C53:  MOVF   00,W
0C54:  BSF    03.5
0C55:  MOVWF  67
0C56:  MOVF   65,W
0C57:  MOVWF  04
0C58:  BCF    03.7
0C59:  BTFSC  66.0
0C5A:  BSF    03.7
0C5B:  MOVF   67,W
0C5C:  MOVWF  00
0C5D:  BCF    03.5
0C5E:  INCF   3F,F
0C5F:  GOTO   43E
....................                 } 
....................                 readData[15] = data[15]; 
0C60:  MOVLW  0F
0C61:  BSF    03.5
0C62:  ADDWF  53,W
0C63:  MOVWF  04
0C64:  BCF    03.7
0C65:  BTFSC  54.0
0C66:  BSF    03.7
0C67:  BCF    03.5
0C68:  MOVF   50,W
0C69:  MOVWF  00
....................             } else { 
0C6A:  GOTO   474
....................                 printf("Read failed \r\n"); 
0C6B:  MOVLW  C7
0C6C:  BSF    03.6
0C6D:  MOVWF  0D
0C6E:  MOVLW  00
0C6F:  MOVWF  0F
0C70:  BCF    0A.3
0C71:  BCF    03.6
0C72:  CALL   363
0C73:  BSF    0A.3
....................             } 
....................  
....................         } else { 
0C74:  GOTO   48C
....................             printf("Access denied at block 0x%2X", i); 
0C75:  MOVLW  CF
0C76:  BSF    03.6
0C77:  MOVWF  0D
0C78:  MOVLW  00
0C79:  MOVWF  0F
0C7A:  BCF    03.0
0C7B:  MOVLW  19
0C7C:  BSF    03.5
0C7D:  BCF    03.6
0C7E:  MOVWF  65
0C7F:  BCF    0A.3
0C80:  BCF    03.5
0C81:  CALL   496
0C82:  BSF    0A.3
0C83:  MOVF   3E,W
0C84:  BSF    03.5
0C85:  MOVWF  65
0C86:  MOVLW  37
0C87:  MOVWF  66
0C88:  BCF    0A.3
0C89:  BCF    03.5
0C8A:  CALL   512
0C8B:  BSF    0A.3
....................         } 
....................     } 
0C8C:  BSF    0A.3
0C8D:  BCF    0A.4
0C8E:  GOTO   74E (RETURN)
....................  
.................... } 
....................  
.................... void writeBlock(int sector, int block, byte* writeData){   
*
0D21:  BSF    03.5
0D22:  RLF    51,W
0D23:  MOVWF  77
0D24:  RLF    77,F
0D25:  MOVLW  FC
0D26:  ANDWF  77,F
0D27:  MOVF   77,W
0D28:  ADDWF  52,W
0D29:  MOVWF  55
....................      
....................     int writeBlock = ( sector * 4 ) + block; 
....................  
....................     status = authenticate(MF1_AUTHENT1A, writeBlock, keyA, serial); 
0D2A:  MOVLW  60
0D2B:  MOVWF  65
0D2C:  MOVF   55,W
0D2D:  MOVWF  66
0D2E:  CLRF   68
0D2F:  MOVLW  65
0D30:  MOVWF  67
0D31:  CLRF   6A
0D32:  MOVLW  39
0D33:  MOVWF  69
0D34:  BCF    03.5
0D35:  CALL   133
0D36:  MOVF   78,W
0D37:  MOVWF  40
....................  
....................     //authenticated with key A 
....................     if (MI_OK == status) { 
0D38:  MOVF   40,F
0D39:  BTFSS  03.2
0D3A:  GOTO   566
....................         printf("Authenticated with key A \r\n"); 
0D3B:  MOVLW  DE
0D3C:  BSF    03.6
0D3D:  MOVWF  0D
0D3E:  MOVLW  00
0D3F:  MOVWF  0F
0D40:  BCF    0A.3
0D41:  BCF    03.6
0D42:  CALL   363
0D43:  BSF    0A.3
....................         status = writeToTag(writeBlock, writeData); 
0D44:  BSF    03.5
0D45:  MOVF   55,W
0D46:  MOVWF  56
0D47:  MOVF   54,W
0D48:  MOVWF  58
0D49:  MOVF   53,W
0D4A:  MOVWF  57
0D4B:  BCF    03.5
0D4C:  CALL   48F
0D4D:  MOVF   78,W
0D4E:  MOVWF  40
....................         if (MI_OK == status) { 
0D4F:  MOVF   40,F
0D50:  BTFSS  03.2
0D51:  GOTO   55C
....................             printf("Write Successful\r\n"); 
0D52:  MOVLW  EC
0D53:  BSF    03.6
0D54:  MOVWF  0D
0D55:  MOVLW  00
0D56:  MOVWF  0F
0D57:  BCF    0A.3
0D58:  BCF    03.6
0D59:  CALL   363
0D5A:  BSF    0A.3
....................         }else{ 
0D5B:  GOTO   565
....................             printf("Write failed\r\n"); 
0D5C:  MOVLW  F6
0D5D:  BSF    03.6
0D5E:  MOVWF  0D
0D5F:  MOVLW  00
0D60:  MOVWF  0F
0D61:  BCF    0A.3
0D62:  BCF    03.6
0D63:  CALL   363
0D64:  BSF    0A.3
....................         } 
....................  
....................  
....................     } else { 
0D65:  GOTO   5C8
....................         //try to authenticate with key b 
....................         status = authenticate(MF1_AUTHENT1B, writeBlock, keyB, serial); 
0D66:  MOVLW  61
0D67:  BSF    03.5
0D68:  MOVWF  65
0D69:  MOVF   55,W
0D6A:  MOVWF  66
0D6B:  CLRF   68
0D6C:  MOVLW  6B
0D6D:  MOVWF  67
0D6E:  CLRF   6A
0D6F:  MOVLW  39
0D70:  MOVWF  69
0D71:  BCF    03.5
0D72:  CALL   133
0D73:  MOVF   78,W
0D74:  MOVWF  40
....................         if (MI_OK == status) { 
0D75:  MOVF   40,F
0D76:  BTFSS  03.2
0D77:  GOTO   5A3
....................             printf("Authenticated with key B \r\n"); 
0D78:  MOVLW  FE
0D79:  BSF    03.6
0D7A:  MOVWF  0D
0D7B:  MOVLW  00
0D7C:  MOVWF  0F
0D7D:  BCF    0A.3
0D7E:  BCF    03.6
0D7F:  CALL   363
0D80:  BSF    0A.3
....................             status = writeToTag(writeBlock, writeData); 
0D81:  BSF    03.5
0D82:  MOVF   55,W
0D83:  MOVWF  56
0D84:  MOVF   54,W
0D85:  MOVWF  58
0D86:  MOVF   53,W
0D87:  MOVWF  57
0D88:  BCF    03.5
0D89:  CALL   48F
0D8A:  MOVF   78,W
0D8B:  MOVWF  40
....................             if (MI_OK == status) { 
0D8C:  MOVF   40,F
0D8D:  BTFSS  03.2
0D8E:  GOTO   599
....................                 printf("Write Successful\r\n"); 
0D8F:  MOVLW  0C
0D90:  BSF    03.6
0D91:  MOVWF  0D
0D92:  MOVLW  01
0D93:  MOVWF  0F
0D94:  BCF    0A.3
0D95:  BCF    03.6
0D96:  CALL   363
0D97:  BSF    0A.3
....................             }else{ 
0D98:  GOTO   5A2
....................                 printf("Write Failed"); 
0D99:  MOVLW  16
0D9A:  BSF    03.6
0D9B:  MOVWF  0D
0D9C:  MOVLW  01
0D9D:  MOVWF  0F
0D9E:  BCF    0A.3
0D9F:  BCF    03.6
0DA0:  CALL   363
0DA1:  BSF    0A.3
....................             } 
....................  
....................         } else { 
0DA2:  GOTO   5C8
....................             printf("Couldn't access block 0x%X write failed", 2); 
0DA3:  MOVLW  1D
0DA4:  BSF    03.6
0DA5:  MOVWF  0D
0DA6:  MOVLW  01
0DA7:  MOVWF  0F
0DA8:  BCF    03.0
0DA9:  MOVLW  18
0DAA:  BSF    03.5
0DAB:  BCF    03.6
0DAC:  MOVWF  65
0DAD:  BCF    0A.3
0DAE:  BCF    03.5
0DAF:  CALL   496
0DB0:  BSF    0A.3
0DB1:  MOVLW  02
0DB2:  BSF    03.5
0DB3:  MOVWF  65
0DB4:  MOVLW  37
0DB5:  MOVWF  66
0DB6:  BCF    0A.3
0DB7:  BCF    03.5
0DB8:  CALL   512
0DB9:  BSF    0A.3
0DBA:  MOVLW  2A
0DBB:  BSF    03.6
0DBC:  MOVWF  0D
0DBD:  MOVLW  01
0DBE:  MOVWF  0F
0DBF:  BCF    03.0
0DC0:  MOVLW  0D
0DC1:  BSF    03.5
0DC2:  BCF    03.6
0DC3:  MOVWF  65
0DC4:  BCF    0A.3
0DC5:  BCF    03.5
0DC6:  CALL   496
0DC7:  BSF    0A.3
....................         } 
....................  
....................     } 
0DC8:  BSF    0A.3
0DC9:  BCF    0A.4
0DCA:  GOTO   778 (RETURN)
.................... } 
....................  
....................  
.................... void main() { 
*
0E00:  MOVF   03,W
0E01:  ANDLW  1F
0E02:  MOVWF  03
0E03:  CLRF   20
0E04:  MOVLW  0C
0E05:  BSF    03.5
0E06:  MOVWF  19
0E07:  MOVLW  A6
0E08:  MOVWF  18
0E09:  MOVLW  90
0E0A:  BCF    03.5
0E0B:  MOVWF  18
0E0C:  CLRF   72
0E0D:  CLRF   71
0E0E:  MOVLW  FF
0E0F:  MOVWF  73
0E10:  BSF    03.5
0E11:  BSF    1F.0
0E12:  BSF    1F.1
0E13:  BSF    1F.2
0E14:  BCF    1F.3
0E15:  MOVLW  07
0E16:  MOVWF  1C
0E17:  BCF    03.7
....................  
....................     //setup spi line  
....................  
....................     setup_spi(SPI_MASTER | SPI_MODE_0 | SPI_CLK_DIV_16); 
*
0E49:  BCF    03.5
0E4A:  BCF    14.5
0E4B:  BCF    73.5
0E4C:  MOVF   73,W
0E4D:  BSF    03.5
0E4E:  MOVWF  07
0E4F:  BSF    73.4
0E50:  MOVF   73,W
0E51:  MOVWF  07
0E52:  BCF    73.3
0E53:  MOVF   73,W
0E54:  MOVWF  07
0E55:  MOVLW  21
0E56:  BCF    03.5
0E57:  MOVWF  14
0E58:  MOVLW  40
0E59:  BSF    03.5
0E5A:  MOVWF  14
....................  
....................     delay_ms(20); 
0E5B:  MOVLW  14
0E5C:  BCF    03.5
0E5D:  BSF    03.6
0E5E:  MOVWF  2A
0E5F:  BCF    0A.3
0E60:  BCF    03.6
0E61:  CALL   16C
0E62:  BSF    0A.3
....................  
....................     //init lcd and put some string 
....................     lcd_init(); 
0E63:  BCF    0A.3
0E64:  GOTO   24B
0E65:  BSF    0A.3
....................  
....................     lcd_putc("\f Starting..."); 
0E66:  MOVLW  31
0E67:  BSF    03.6
0E68:  MOVWF  0D
0E69:  MOVLW  01
0E6A:  MOVWF  0F
0E6B:  BCF    0A.3
0E6C:  BCF    03.6
0E6D:  CALL   2EF
0E6E:  BSF    0A.3
....................  
....................     printf("\r\nstarting.."); //output to terminal     
0E6F:  MOVLW  38
0E70:  BSF    03.6
0E71:  MOVWF  0D
0E72:  MOVLW  01
0E73:  MOVWF  0F
0E74:  BCF    0A.3
0E75:  BCF    03.6
0E76:  CALL   363
0E77:  BSF    0A.3
....................  
....................     //initialize RFID Reader 
....................  
....................     delay_ms(100); 
0E78:  MOVLW  64
0E79:  BSF    03.6
0E7A:  MOVWF  2A
0E7B:  BCF    0A.3
0E7C:  BCF    03.6
0E7D:  CALL   16C
0E7E:  BSF    0A.3
....................     MFRC_begin(); 
0E7F:  BCF    0A.3
0E80:  GOTO   435
0E81:  BSF    0A.3
....................  
....................     //check if the card reader is connected. 
....................     CheckRFIDHardware(); 
0E82:  BCF    0A.3
0E83:  GOTO   539
0E84:  BSF    0A.3
....................  
....................     //in while loop keep checking for any new card 
....................     while (TRUE) { 
....................  
....................         //      //  Check to see if a Tag was detected 
....................         //     // If yes, then the variable FoundTag will contain "MI_OK" 
....................         FoundTag = requestTag(MF1_REQIDL, TagData); 
0E85:  MOVLW  26
0E86:  BSF    03.5
0E87:  MOVWF  51
0E88:  CLRF   53
0E89:  MOVLW  29
0E8A:  MOVWF  52
0E8B:  BCF    0A.3
0E8C:  BCF    03.5
0E8D:  GOTO   75F
0E8E:  BSF    0A.3
0E8F:  MOVF   78,W
0E90:  MOVWF  27
....................  
....................         // 
....................         //If tag found 
....................         if (FoundTag == MI_OK) { 
0E91:  MOVF   27,F
0E92:  BTFSS  03.2
0E93:  GOTO   779
....................  
....................             printf("\r\nFound Tag: "); 
0E94:  MOVLW  3F
0E95:  BSF    03.6
0E96:  MOVWF  0D
0E97:  MOVLW  01
0E98:  MOVWF  0F
0E99:  BCF    0A.3
0E9A:  BCF    03.6
0E9B:  CALL   363
0E9C:  BSF    0A.3
....................              
....................             //when multiple cards in horizon choose one. 
....................             ReadTag = antiCollision(TagData); 
0E9D:  BSF    03.5
0E9E:  CLRF   52
0E9F:  MOVLW  29
0EA0:  MOVWF  51
0EA1:  BCF    03.5
0EA2:  GOTO   000
0EA3:  MOVF   78,W
0EA4:  MOVWF  28
....................  
....................             ///has tag passed anti collision test? 
....................             if (ReadTag == MI_OK) { 
0EA5:  MOVF   28,F
0EA6:  BTFSS  03.2
0EA7:  GOTO   779
....................  
....................                 //then put out UUID  
....................                 for (i = 0; i <= 2; i++) { 
0EA8:  CLRF   3E
0EA9:  MOVF   3E,W
0EAA:  SUBLW  02
0EAB:  BTFSS  03.0
0EAC:  GOTO   6D6
....................                     sprintf(buffer2, "%2X", (TagData[i])); //display version in hexadecimal 
0EAD:  MOVLW  29
0EAE:  ADDWF  3E,W
0EAF:  MOVWF  04
0EB0:  BCF    03.7
0EB1:  MOVF   00,W
0EB2:  BSF    03.5
0EB3:  MOVWF  51
0EB4:  CLRF   72
0EB5:  MOVLW  51
0EB6:  MOVWF  71
0EB7:  MOVF   51,W
0EB8:  MOVWF  52
0EB9:  MOVLW  37
0EBA:  MOVWF  53
0EBB:  BCF    0A.3
0EBC:  BCF    03.5
0EBD:  CALL   7B2
0EBE:  BSF    0A.3
....................                     delay_ms(20); 
0EBF:  MOVLW  14
0EC0:  BSF    03.6
0EC1:  MOVWF  2A
0EC2:  BCF    0A.3
0EC3:  BCF    03.6
0EC4:  CALL   16C
0EC5:  BSF    0A.3
....................                     printf(buffer2); 
0EC6:  MOVLW  51
0EC7:  MOVWF  04
0EC8:  BCF    03.7
0EC9:  BCF    0A.3
0ECA:  CALL   7D7
0ECB:  BSF    0A.3
....................                     printf(", "); 
0ECC:  MOVLW  2C
0ECD:  BTFSS  0C.4
0ECE:  GOTO   6CD
0ECF:  MOVWF  19
0ED0:  MOVLW  20
0ED1:  BTFSS  0C.4
0ED2:  GOTO   6D1
0ED3:  MOVWF  19
0ED4:  INCF   3E,F
0ED5:  GOTO   6A9
....................                 } 
....................                 sprintf(buffer2, "%2X", (TagData[i])); //display version in hexadecimal 
0ED6:  MOVLW  29
0ED7:  ADDWF  3E,W
0ED8:  MOVWF  04
0ED9:  BCF    03.7
0EDA:  MOVF   00,W
0EDB:  BSF    03.5
0EDC:  MOVWF  51
0EDD:  CLRF   72
0EDE:  MOVLW  51
0EDF:  MOVWF  71
0EE0:  MOVF   51,W
0EE1:  MOVWF  52
0EE2:  MOVLW  37
0EE3:  MOVWF  53
0EE4:  BCF    0A.3
0EE5:  BCF    03.5
0EE6:  CALL   7B2
0EE7:  BSF    0A.3
....................                 printf(buffer2); 
0EE8:  MOVLW  51
0EE9:  MOVWF  04
0EEA:  BCF    03.7
0EEB:  BCF    0A.3
0EEC:  CALL   7D7
0EED:  BSF    0A.3
....................                  
....................                 //copy tag serial number to `serial` variable 
....................                 memcpy(serial, TagData, 5); 
0EEE:  MOVF   29,W
0EEF:  MOVWF  39
0EF0:  MOVF   2A,W
0EF1:  MOVWF  3A
0EF2:  MOVF   2B,W
0EF3:  MOVWF  3B
0EF4:  MOVF   2C,W
0EF5:  MOVWF  3C
0EF6:  MOVF   2D,W
0EF7:  MOVWF  3D
....................  
....................                 //now get SAK for card version check 
....................                 byte sak = selectTag(serial); 
0EF8:  BSF    03.5
0EF9:  CLRF   52
0EFA:  MOVLW  39
0EFB:  MOVWF  51
0EFC:  BCF    03.5
0EFD:  GOTO   0DB
0EFE:  MOVF   78,W
0EFF:  BSF    03.5
0F00:  MOVWF  30
....................  
....................                 printf("\r\nSAK: 0x%2x", sak); 
0F01:  MOVLW  46
0F02:  BCF    03.5
0F03:  BSF    03.6
0F04:  MOVWF  0D
0F05:  MOVLW  01
0F06:  MOVWF  0F
0F07:  BCF    03.0
0F08:  MOVLW  09
0F09:  BSF    03.5
0F0A:  BCF    03.6
0F0B:  MOVWF  65
0F0C:  BCF    0A.3
0F0D:  BCF    03.5
0F0E:  CALL   496
0F0F:  BSF    0A.3
0F10:  BSF    03.5
0F11:  MOVF   30,W
0F12:  MOVWF  65
0F13:  MOVLW  57
0F14:  MOVWF  66
0F15:  BCF    0A.3
0F16:  BCF    03.5
0F17:  CALL   512
0F18:  BSF    0A.3
....................  
....................  
....................                 if (UID_FAILED == sak) { 
0F19:  BSF    03.5
0F1A:  MOVF   30,F
0F1B:  BTFSS  03.2
0F1C:  GOTO   729
....................                     printf("\r\n Failed to read card"); 
0F1D:  MOVLW  4D
0F1E:  BCF    03.5
0F1F:  BSF    03.6
0F20:  MOVWF  0D
0F21:  MOVLW  01
0F22:  MOVWF  0F
0F23:  BCF    0A.3
0F24:  BCF    03.6
0F25:  CALL   363
0F26:  BSF    0A.3
....................                 }//UID was read incompletely 
0F27:  GOTO   779
0F28:  BSF    03.5
....................                 else if (UID_NOT_COMPLETE == sak) { 
0F29:  MOVF   30,W
0F2A:  SUBLW  04
0F2B:  BTFSS  03.2
0F2C:  GOTO   739
....................                     printf("\r\n Incomplete UID"); 
0F2D:  MOVLW  59
0F2E:  BCF    03.5
0F2F:  BSF    03.6
0F30:  MOVWF  0D
0F31:  MOVLW  01
0F32:  MOVWF  0F
0F33:  BCF    0A.3
0F34:  BCF    03.6
0F35:  CALL   363
0F36:  BSF    0A.3
....................                 } else { 
0F37:  GOTO   779
0F38:  BSF    03.5
....................                     printf("\r\n Is a Mifare Card"); 
0F39:  MOVLW  62
0F3A:  BCF    03.5
0F3B:  BSF    03.6
0F3C:  MOVWF  0D
0F3D:  MOVLW  01
0F3E:  MOVWF  0F
0F3F:  BCF    0A.3
0F40:  BCF    03.6
0F41:  CALL   363
0F42:  BSF    0A.3
....................                     //everything went well so far                         
....................                     //now start reading memory 
....................                      
.................... //                  //if you wan to read whole card 
....................                     readAll(); 
0F43:  GOTO   22B
....................                      
....................                     //MAX_LINE is 16 
....................                     byte readData[MAX_LEN]; 
....................                      
....................                      
....................                     //if you want to read 
....................                     // sector 6 
....................                     // block 3 
....................                     // data into readData array of size 16 bytes 
....................                     readBlock( 6, 3, readData ); 
0F44:  MOVLW  06
0F45:  BSF    03.5
0F46:  MOVWF  51
0F47:  MOVLW  03
0F48:  MOVWF  52
0F49:  CLRF   54
0F4A:  MOVLW  B1
0F4B:  MOVWF  53
0F4C:  BCF    03.5
0F4D:  GOTO   365
....................                      
....................                     //if you want to write something to card 
....................                     byte wdata[] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10}; 
0F4E:  MOVLW  01
0F4F:  BSF    03.5
0F50:  MOVWF  41
0F51:  MOVLW  02
0F52:  MOVWF  42
0F53:  MOVLW  03
0F54:  MOVWF  43
0F55:  MOVLW  04
0F56:  MOVWF  44
0F57:  MOVLW  05
0F58:  MOVWF  45
0F59:  MOVLW  06
0F5A:  MOVWF  46
0F5B:  MOVLW  07
0F5C:  MOVWF  47
0F5D:  MOVLW  08
0F5E:  MOVWF  48
0F5F:  MOVLW  09
0F60:  MOVWF  49
0F61:  MOVLW  0A
0F62:  MOVWF  4A
0F63:  MOVLW  0B
0F64:  MOVWF  4B
0F65:  MOVLW  0C
0F66:  MOVWF  4C
0F67:  MOVLW  0D
0F68:  MOVWF  4D
0F69:  MOVLW  0E
0F6A:  MOVWF  4E
0F6B:  MOVLW  0F
0F6C:  MOVWF  4F
0F6D:  MOVLW  10
0F6E:  MOVWF  50
....................                      
....................                     writeBlock(8, 2, wdata); 
0F6F:  MOVLW  08
0F70:  MOVWF  51
0F71:  MOVLW  02
0F72:  MOVWF  52
0F73:  CLRF   54
0F74:  MOVLW  C1
0F75:  MOVWF  53
0F76:  BCF    03.5
0F77:  GOTO   521
....................                      
....................                     //always halt tag once the card is processed 
....................                     haltTag(); 
0F78:  GOTO   5CB
....................                 } 
....................  
....................             } 
....................  
....................  
....................         } 
....................  
....................         delay_ms(2000); 
0F79:  MOVLW  08
0F7A:  BSF    03.5
0F7B:  MOVWF  51
0F7C:  MOVLW  FA
0F7D:  BCF    03.5
0F7E:  BSF    03.6
0F7F:  MOVWF  2A
0F80:  BCF    0A.3
0F81:  BCF    03.6
0F82:  CALL   16C
0F83:  BSF    0A.3
0F84:  BSF    03.5
0F85:  DECFSZ 51,F
0F86:  GOTO   77C
0F87:  BCF    03.5
0F88:  GOTO   685
....................         //     
....................     } 
....................  
....................     return; 
.................... } 
....................  
0F89:  SLEEP

Configuration Fuses:
   Word  1: 3F71   XT NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
