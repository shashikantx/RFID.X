CCS PCM C Compiler, Version 5.078, 43599               04-Jul-18 14:24

               Filename:   C:\Users\Shashikant\Documents\GitHub\RFID.X\build\default\debug\main.lst

               ROM used:   1542 words (19%)
                           Largest free fragment is 2048
               RAM used:   112 (31%) at main() level
                           127 (36%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 7

*
0000:  NOP
0001:  MOVLW  05
0002:  MOVWF  0A
0003:  GOTO   593
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.4
0028:  GOTO   02B
0029:  BTFSC  0B.1
002A:  GOTO   04C
002B:  MOVF   22,W
002C:  MOVWF  04
002D:  MOVF   23,W
002E:  MOVWF  77
002F:  MOVF   24,W
0030:  MOVWF  78
0031:  MOVF   25,W
0032:  MOVWF  79
0033:  MOVF   26,W
0034:  MOVWF  7A
0035:  MOVF   27,W
0036:  BSF    03.6
0037:  MOVWF  0D
0038:  BCF    03.6
0039:  MOVF   28,W
003A:  BSF    03.6
003B:  MOVWF  0F
003C:  BCF    03.6
003D:  MOVF   29,W
003E:  BSF    03.6
003F:  MOVWF  0C
0040:  BCF    03.6
0041:  MOVF   2A,W
0042:  BSF    03.6
0043:  MOVWF  0E
0044:  BCF    03.6
0045:  MOVF   20,W
0046:  MOVWF  0A
0047:  SWAPF  21,W
0048:  MOVWF  03
0049:  SWAPF  7F,F
004A:  SWAPF  7F,W
004B:  RETFIE
004C:  BCF    0A.3
004D:  BCF    0A.4
004E:  GOTO   04F
.................... /*  
....................  * File:   main.c 
....................  * Author: Shashikant 
....................  * 
....................  * Created on 2 July, 2018, 12:43 PM 
....................  */ 
....................  
.................... //Options 
.................... #include <16F877A.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
*
0054:  DATA 0C,10
0055:  DATA 43,34
0056:  DATA E5,31
0057:  DATA EB,34
0058:  DATA EE,33
0059:  DATA 20,29
005A:  DATA C6,24
005B:  DATA 44,17
005C:  DATA 2E,17
005D:  DATA 00,00
005E:  DATA 0D,05
005F:  DATA 43,34
0060:  DATA E5,31
0061:  DATA EB,34
0062:  DATA EE,33
0063:  DATA A0,24
0064:  DATA 66,10
0065:  DATA 52,33
0066:  DATA 69,32
0067:  DATA A0,24
0068:  DATA 73,10
0069:  DATA C3,37
006A:  DATA 6E,37
006B:  DATA E5,31
006C:  DATA F4,32
006D:  DATA 64,00
006E:  DATA 0C,10
006F:  DATA 52,23
0070:  DATA 49,22
0071:  DATA 20,27
0072:  DATA 6F,3A
0073:  DATA 20,23
0074:  DATA EF,3A
0075:  DATA 6E,32
0076:  DATA 20,05
0077:  DATA A0,21
0078:  DATA E8,32
0079:  DATA E3,35
007A:  DATA A0,20
007B:  DATA E7,30
007C:  DATA 69,37
007D:  DATA 2E,17
007E:  DATA 00,01
007F:  DATA 0D,05
0080:  DATA 52,23
0081:  DATA 49,22
0082:  DATA 20,24
0083:  DATA 77,10
0084:  DATA EE,37
0085:  DATA 74,10
0086:  DATA C6,37
0087:  DATA 75,37
0088:  DATA 64,00
0089:  DATA 0C,10
008A:  DATA 52,23
008B:  DATA 49,22
008C:  DATA 20,23
008D:  DATA EF,3A
008E:  DATA 6E,32
008F:  DATA 00,01
0090:  DATA 0A,2B
0091:  DATA 3A,10
0092:  DATA 25,3C
0093:  DATA 00,00
0094:  DATA 0D,05
0095:  DATA 52,23
0096:  DATA 49,22
0097:  DATA 20,23
0098:  DATA EF,3A
0099:  DATA 6E,32
009A:  DATA A0,30
009B:  DATA 6E,32
009C:  DATA 20,24
009D:  DATA 57,10
009E:  DATA F6,32
009F:  DATA F2,39
00A0:  DATA E9,37
00A1:  DATA 6E,10
00A2:  DATA E9,39
00A3:  DATA 3A,10
00A4:  DATA 25,19
00A5:  DATA D8,06
00A6:  DATA 0A,00
00A7:  DATA 0C,24
00A8:  DATA 6F,36
00A9:  DATA 64,10
00AA:  DATA D4,30
00AB:  DATA 67,10
00AC:  DATA 53,3A
00AD:  DATA 69,36
00AE:  DATA 6C,00
00AF:  DATA 0C,00
00B0:  DATA C4,30
00B1:  DATA F4,30
00B2:  DATA 3A,10
00B3:  DATA 00,01
00B4:  DATA 0C,10
00B5:  DATA 53,3A
00B6:  DATA 61,39
00B7:  DATA F4,34
00B8:  DATA EE,33
00B9:  DATA 2E,17
00BA:  DATA 2E,00
00BB:  DATA 0D,05
00BC:  DATA 73,3A
00BD:  DATA 61,39
00BE:  DATA F4,34
00BF:  DATA EE,33
00C0:  DATA 2E,17
00C1:  DATA 00,01
*
0243:  MOVF   0B,W
0244:  BSF    03.5
0245:  MOVWF  48
0246:  BCF    03.5
0247:  BCF    0B.7
0248:  BSF    03.5
0249:  BSF    03.6
024A:  BSF    0C.7
024B:  BSF    0C.0
024C:  NOP
024D:  NOP
024E:  BCF    03.6
024F:  BTFSS  48.7
0250:  GOTO   254
0251:  BCF    03.5
0252:  BSF    0B.7
0253:  BSF    03.5
0254:  BCF    03.5
0255:  BSF    03.6
0256:  MOVF   0C,W
0257:  ANDLW  7F
0258:  BTFSC  03.2
0259:  GOTO   2B5
025A:  BSF    03.5
025B:  BCF    03.6
025C:  MOVWF  48
025D:  BCF    03.5
025E:  BSF    03.6
025F:  MOVF   0D,W
0260:  BSF    03.5
0261:  BCF    03.6
0262:  MOVWF  49
0263:  BCF    03.5
0264:  BSF    03.6
0265:  MOVF   0F,W
0266:  BSF    03.5
0267:  BCF    03.6
0268:  MOVWF  4A
0269:  MOVF   48,W
026A:  MOVWF  4C
026B:  BCF    03.5
026C:  CALL   209
026D:  BSF    03.5
026E:  MOVF   49,W
026F:  BCF    03.5
0270:  BSF    03.6
0271:  MOVWF  0D
0272:  BSF    03.5
0273:  BCF    03.6
0274:  MOVF   4A,W
0275:  BCF    03.5
0276:  BSF    03.6
0277:  MOVWF  0F
0278:  BCF    03.6
0279:  MOVF   0B,W
027A:  BSF    03.5
027B:  MOVWF  4B
027C:  BCF    03.5
027D:  BCF    0B.7
027E:  BSF    03.5
027F:  BSF    03.6
0280:  BSF    0C.7
0281:  BSF    0C.0
0282:  NOP
0283:  NOP
0284:  BCF    03.6
0285:  BTFSS  4B.7
0286:  GOTO   28A
0287:  BCF    03.5
0288:  BSF    0B.7
0289:  BSF    03.5
028A:  BCF    03.5
028B:  BSF    03.6
028C:  RLF    0C,W
028D:  RLF    0E,W
028E:  ANDLW  7F
028F:  BTFSC  03.2
0290:  GOTO   2B5
0291:  BSF    03.5
0292:  BCF    03.6
0293:  MOVWF  48
0294:  BCF    03.5
0295:  BSF    03.6
0296:  MOVF   0D,W
0297:  BSF    03.5
0298:  BCF    03.6
0299:  MOVWF  49
029A:  BCF    03.5
029B:  BSF    03.6
029C:  MOVF   0F,W
029D:  BSF    03.5
029E:  BCF    03.6
029F:  MOVWF  4A
02A0:  MOVF   48,W
02A1:  MOVWF  4C
02A2:  BCF    03.5
02A3:  CALL   209
02A4:  BSF    03.5
02A5:  MOVF   49,W
02A6:  BCF    03.5
02A7:  BSF    03.6
02A8:  MOVWF  0D
02A9:  BSF    03.5
02AA:  BCF    03.6
02AB:  MOVF   4A,W
02AC:  BCF    03.5
02AD:  BSF    03.6
02AE:  MOVWF  0F
02AF:  INCF   0D,F
02B0:  BTFSC  03.2
02B1:  INCF   0F,F
02B2:  BCF    03.6
02B3:  GOTO   243
02B4:  BSF    03.6
02B5:  BCF    03.6
02B6:  RETURN
02B7:  MOVF   0B,W
02B8:  BSF    03.5
02B9:  MOVWF  48
02BA:  BCF    03.5
02BB:  BCF    0B.7
02BC:  BSF    03.5
02BD:  BSF    03.6
02BE:  BSF    0C.7
02BF:  BSF    0C.0
02C0:  NOP
02C1:  NOP
02C2:  BCF    03.6
02C3:  BTFSS  48.7
02C4:  GOTO   2C8
02C5:  BCF    03.5
02C6:  BSF    0B.7
02C7:  BSF    03.5
02C8:  BCF    03.5
02C9:  BSF    03.6
02CA:  MOVF   0C,W
02CB:  ANDLW  7F
02CC:  BTFSC  03.2
02CD:  GOTO   32B
02CE:  BSF    03.5
02CF:  BCF    03.6
02D0:  MOVWF  48
02D1:  BCF    03.5
02D2:  BSF    03.6
02D3:  MOVF   0D,W
02D4:  BSF    03.5
02D5:  BCF    03.6
02D6:  MOVWF  49
02D7:  BCF    03.5
02D8:  BSF    03.6
02D9:  MOVF   0F,W
02DA:  BSF    03.5
02DB:  BCF    03.6
02DC:  MOVWF  4A
02DD:  MOVF   48,W
02DE:  BCF    03.5
02DF:  BTFSS  0C.4
02E0:  GOTO   2DF
02E1:  MOVWF  19
02E2:  BSF    03.5
02E3:  MOVF   49,W
02E4:  BCF    03.5
02E5:  BSF    03.6
02E6:  MOVWF  0D
02E7:  BSF    03.5
02E8:  BCF    03.6
02E9:  MOVF   4A,W
02EA:  BCF    03.5
02EB:  BSF    03.6
02EC:  MOVWF  0F
02ED:  BCF    03.6
02EE:  MOVF   0B,W
02EF:  BSF    03.5
02F0:  MOVWF  4B
02F1:  BCF    03.5
02F2:  BCF    0B.7
02F3:  BSF    03.5
02F4:  BSF    03.6
02F5:  BSF    0C.7
02F6:  BSF    0C.0
02F7:  NOP
02F8:  NOP
02F9:  BCF    03.6
02FA:  BTFSS  4B.7
02FB:  GOTO   2FF
02FC:  BCF    03.5
02FD:  BSF    0B.7
02FE:  BSF    03.5
02FF:  BCF    03.5
0300:  BSF    03.6
0301:  RLF    0C,W
0302:  RLF    0E,W
0303:  ANDLW  7F
0304:  BTFSC  03.2
0305:  GOTO   32B
0306:  BSF    03.5
0307:  BCF    03.6
0308:  MOVWF  48
0309:  BCF    03.5
030A:  BSF    03.6
030B:  MOVF   0D,W
030C:  BSF    03.5
030D:  BCF    03.6
030E:  MOVWF  49
030F:  BCF    03.5
0310:  BSF    03.6
0311:  MOVF   0F,W
0312:  BSF    03.5
0313:  BCF    03.6
0314:  MOVWF  4A
0315:  MOVF   48,W
0316:  BCF    03.5
0317:  BTFSS  0C.4
0318:  GOTO   317
0319:  MOVWF  19
031A:  BSF    03.5
031B:  MOVF   49,W
031C:  BCF    03.5
031D:  BSF    03.6
031E:  MOVWF  0D
031F:  BSF    03.5
0320:  BCF    03.6
0321:  MOVF   4A,W
0322:  BCF    03.5
0323:  BSF    03.6
0324:  MOVWF  0F
0325:  INCF   0D,F
0326:  BTFSC  03.2
0327:  INCF   0F,F
0328:  BCF    03.6
0329:  GOTO   2B7
032A:  BSF    03.6
032B:  BCF    03.6
032C:  RETURN
*
0430:  BCF    03.5
0431:  MOVF   0B,W
0432:  BSF    03.5
0433:  MOVWF  49
0434:  BCF    03.5
0435:  BCF    0B.7
0436:  BSF    03.5
0437:  BSF    03.6
0438:  BSF    0C.7
0439:  BSF    0C.0
043A:  NOP
043B:  NOP
043C:  BCF    03.6
043D:  BTFSS  49.7
043E:  GOTO   442
043F:  BCF    03.5
0440:  BSF    0B.7
0441:  BSF    03.5
0442:  BTFSC  03.0
0443:  GOTO   47B
0444:  BCF    03.5
0445:  BSF    03.6
0446:  MOVF   0C,W
0447:  ANDLW  7F
0448:  BSF    03.5
0449:  BCF    03.6
044A:  MOVWF  49
044B:  BCF    03.5
044C:  BSF    03.6
044D:  MOVF   0D,W
044E:  BSF    03.5
044F:  BCF    03.6
0450:  MOVWF  4A
0451:  BCF    03.5
0452:  BSF    03.6
0453:  MOVF   0F,W
0454:  BSF    03.5
0455:  BCF    03.6
0456:  MOVWF  4B
0457:  MOVF   49,W
0458:  MOVWF  4C
0459:  BCF    03.5
045A:  CALL   209
045B:  BSF    03.5
045C:  MOVF   4A,W
045D:  BCF    03.5
045E:  BSF    03.6
045F:  MOVWF  0D
0460:  BSF    03.5
0461:  BCF    03.6
0462:  MOVF   4B,W
0463:  BCF    03.5
0464:  BSF    03.6
0465:  MOVWF  0F
0466:  BCF    03.6
0467:  MOVF   0B,W
0468:  BSF    03.5
0469:  MOVWF  4C
046A:  BCF    03.5
046B:  BCF    0B.7
046C:  BSF    03.5
046D:  BSF    03.6
046E:  BSF    0C.7
046F:  BSF    0C.0
0470:  NOP
0471:  NOP
0472:  BCF    03.6
0473:  BTFSS  4C.7
0474:  GOTO   478
0475:  BCF    03.5
0476:  BSF    0B.7
0477:  BSF    03.5
0478:  DECFSZ 48,F
0479:  GOTO   47B
047A:  GOTO   4A6
047B:  BCF    03.5
047C:  BSF    03.6
047D:  RLF    0C,W
047E:  RLF    0E,W
047F:  ANDLW  7F
0480:  BSF    03.5
0481:  BCF    03.6
0482:  MOVWF  49
0483:  BCF    03.5
0484:  BSF    03.6
0485:  MOVF   0D,W
0486:  BSF    03.5
0487:  BCF    03.6
0488:  MOVWF  4A
0489:  BCF    03.5
048A:  BSF    03.6
048B:  MOVF   0F,W
048C:  BSF    03.5
048D:  BCF    03.6
048E:  MOVWF  4B
048F:  MOVF   49,W
0490:  MOVWF  4C
0491:  BCF    03.5
0492:  CALL   209
0493:  BSF    03.5
0494:  MOVF   4A,W
0495:  BCF    03.5
0496:  BSF    03.6
0497:  MOVWF  0D
0498:  BSF    03.5
0499:  BCF    03.6
049A:  MOVF   4B,W
049B:  BCF    03.5
049C:  BSF    03.6
049D:  MOVWF  0F
049E:  INCF   0D,F
049F:  BTFSC  03.2
04A0:  INCF   0F,F
04A1:  BCF    03.0
04A2:  BSF    03.5
04A3:  BCF    03.6
04A4:  DECFSZ 48,F
04A5:  GOTO   430
*
04AC:  BTFSC  49.7
04AD:  GOTO   4C0
04AE:  MOVLW  0F
04AF:  MOVWF  77
04B0:  SWAPF  48,W
04B1:  ANDWF  77,F
04B2:  MOVLW  0A
04B3:  SUBWF  77,W
04B4:  BTFSC  03.0
04B5:  GOTO   4B9
04B6:  MOVLW  30
04B7:  ADDWF  77,F
04B8:  GOTO   4BB
04B9:  MOVF   49,W
04BA:  ADDWF  77,F
04BB:  MOVF   77,W
04BC:  MOVWF  4C
04BD:  BCF    03.5
04BE:  CALL   209
04BF:  BSF    03.5
04C0:  MOVLW  0F
04C1:  ANDWF  48,F
04C2:  MOVLW  0A
04C3:  SUBWF  48,W
04C4:  BTFSC  03.0
04C5:  GOTO   4C8
04C6:  MOVLW  30
04C7:  GOTO   4CA
04C8:  BCF    49.7
04C9:  MOVF   49,W
04CA:  ADDWF  48,F
04CB:  MOVF   48,W
04CC:  MOVWF  4C
04CD:  BCF    03.5
04CE:  CALL   209
04CF:  NOP
*
04DA:  BCF    03.5
04DB:  MOVF   0B,W
04DC:  BSF    03.5
04DD:  MOVWF  49
04DE:  BCF    03.5
04DF:  BCF    0B.7
04E0:  BSF    03.5
04E1:  BSF    03.6
04E2:  BSF    0C.7
04E3:  BSF    0C.0
04E4:  NOP
04E5:  NOP
04E6:  BCF    03.6
04E7:  BTFSS  49.7
04E8:  GOTO   4EC
04E9:  BCF    03.5
04EA:  BSF    0B.7
04EB:  BSF    03.5
04EC:  BTFSC  03.0
04ED:  GOTO   526
04EE:  BCF    03.5
04EF:  BSF    03.6
04F0:  MOVF   0C,W
04F1:  ANDLW  7F
04F2:  BSF    03.5
04F3:  BCF    03.6
04F4:  MOVWF  49
04F5:  BCF    03.5
04F6:  BSF    03.6
04F7:  MOVF   0D,W
04F8:  BSF    03.5
04F9:  BCF    03.6
04FA:  MOVWF  4A
04FB:  BCF    03.5
04FC:  BSF    03.6
04FD:  MOVF   0F,W
04FE:  BSF    03.5
04FF:  BCF    03.6
0500:  MOVWF  4B
0501:  MOVF   49,W
0502:  BCF    03.5
0503:  BTFSS  0C.4
0504:  GOTO   503
0505:  MOVWF  19
0506:  BSF    03.5
0507:  MOVF   4A,W
0508:  BCF    03.5
0509:  BSF    03.6
050A:  MOVWF  0D
050B:  BSF    03.5
050C:  BCF    03.6
050D:  MOVF   4B,W
050E:  BCF    03.5
050F:  BSF    03.6
0510:  MOVWF  0F
0511:  BCF    03.6
0512:  MOVF   0B,W
0513:  BSF    03.5
0514:  MOVWF  4C
0515:  BCF    03.5
0516:  BCF    0B.7
0517:  BSF    03.5
0518:  BSF    03.6
0519:  BSF    0C.7
051A:  BSF    0C.0
051B:  NOP
051C:  NOP
051D:  BCF    03.6
051E:  BTFSS  4C.7
051F:  GOTO   523
0520:  BCF    03.5
0521:  BSF    0B.7
0522:  BSF    03.5
0523:  DECFSZ 48,F
0524:  GOTO   526
0525:  GOTO   552
0526:  BCF    03.5
0527:  BSF    03.6
0528:  RLF    0C,W
0529:  RLF    0E,W
052A:  ANDLW  7F
052B:  BSF    03.5
052C:  BCF    03.6
052D:  MOVWF  49
052E:  BCF    03.5
052F:  BSF    03.6
0530:  MOVF   0D,W
0531:  BSF    03.5
0532:  BCF    03.6
0533:  MOVWF  4A
0534:  BCF    03.5
0535:  BSF    03.6
0536:  MOVF   0F,W
0537:  BSF    03.5
0538:  BCF    03.6
0539:  MOVWF  4B
053A:  MOVF   49,W
053B:  BCF    03.5
053C:  BTFSS  0C.4
053D:  GOTO   53C
053E:  MOVWF  19
053F:  BSF    03.5
0540:  MOVF   4A,W
0541:  BCF    03.5
0542:  BSF    03.6
0543:  MOVWF  0D
0544:  BSF    03.5
0545:  BCF    03.6
0546:  MOVF   4B,W
0547:  BCF    03.5
0548:  BSF    03.6
0549:  MOVWF  0F
054A:  INCF   0D,F
054B:  BTFSC  03.2
054C:  INCF   0F,F
054D:  BCF    03.0
054E:  BSF    03.5
054F:  BCF    03.6
0550:  DECFSZ 48,F
0551:  GOTO   4DA
*
0558:  BTFSC  49.7
0559:  GOTO   56D
055A:  MOVLW  0F
055B:  MOVWF  77
055C:  SWAPF  48,W
055D:  ANDWF  77,F
055E:  MOVLW  0A
055F:  SUBWF  77,W
0560:  BTFSC  03.0
0561:  GOTO   565
0562:  MOVLW  30
0563:  ADDWF  77,F
0564:  GOTO   567
0565:  MOVF   49,W
0566:  ADDWF  77,F
0567:  MOVF   77,W
0568:  BCF    03.5
0569:  BTFSS  0C.4
056A:  GOTO   569
056B:  MOVWF  19
056C:  BSF    03.5
056D:  MOVLW  0F
056E:  ANDWF  48,F
056F:  MOVLW  0A
0570:  SUBWF  48,W
0571:  BTFSC  03.0
0572:  GOTO   575
0573:  MOVLW  30
0574:  GOTO   577
0575:  BCF    49.7
0576:  MOVF   49,W
0577:  ADDWF  48,F
0578:  MOVF   48,W
0579:  BCF    03.5
057A:  BTFSS  0C.4
057B:  GOTO   57A
057C:  MOVWF  19
....................  
.................... #list 
....................  
.................... //#include<18F45K22.h> 
.................... #fuses NOPROTECT,NOLVP 
.................... #use delay(crystal=4000000) 
*
00C2:  MOVLW  CD
00C3:  MOVWF  04
00C4:  BCF    03.7
00C5:  MOVF   00,W
00C6:  BTFSC  03.2
00C7:  GOTO   0D6
00C8:  MOVLW  01
00C9:  MOVWF  78
00CA:  CLRF   77
00CB:  DECFSZ 77,F
00CC:  GOTO   0CB
00CD:  DECFSZ 78,F
00CE:  GOTO   0CA
00CF:  MOVLW  4A
00D0:  MOVWF  77
00D1:  DECFSZ 77,F
00D2:  GOTO   0D1
00D3:  GOTO   0D4
00D4:  DECFSZ 00,F
00D5:  GOTO   0C8
00D6:  RETURN
.................... #use rs232( baud=9600, xmit=PIN_C6, rcv=PIN_C7, bits=8,ERRORS) 
....................  
.................... //LCD module connections 
.................... #define LCD_RS_PIN PIN_D0 
.................... #define LCD_RW_PIN PIN_D1 
.................... #define LCD_ENABLE_PIN PIN_D2 
.................... #define LCD_DATA4 PIN_D4 
.................... #define LCD_DATA5 PIN_D5 
.................... #define LCD_DATA6 PIN_D6 
.................... #define LCD_DATA7 PIN_D7 
.................... //End LCD module connections 
....................  
.................... #define CS PIN_A5 
....................  
....................  
....................  
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
0147:  BSF    08.4
....................    output_float(LCD_DATA5); 
0148:  BSF    08.5
....................    output_float(LCD_DATA6); 
0149:  BSF    08.6
....................    output_float(LCD_DATA7); 
014A:  BSF    08.7
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
014B:  BCF    03.5
014C:  BSF    08.1
014D:  BSF    03.5
014E:  BCF    08.1
....................    delay_cycles(1); 
014F:  NOP
....................    lcd_output_enable(1); 
0150:  BCF    03.5
0151:  BSF    08.2
0152:  BSF    03.5
0153:  BCF    08.2
....................    delay_cycles(1); 
0154:  NOP
....................    high = lcd_read_nibble(); 
0155:  BCF    03.5
0156:  CALL   10C
0157:  MOVF   78,W
0158:  BSF    03.5
0159:  MOVWF  54
....................        
....................    lcd_output_enable(0); 
015A:  BCF    03.5
015B:  BCF    08.2
015C:  BSF    03.5
015D:  BCF    08.2
....................    delay_cycles(1); 
015E:  NOP
....................    lcd_output_enable(1); 
015F:  BCF    03.5
0160:  BSF    08.2
0161:  BSF    03.5
0162:  BCF    08.2
....................    delay_us(1); 
0163:  NOP
....................    low = lcd_read_nibble(); 
0164:  BCF    03.5
0165:  CALL   10C
0166:  MOVF   78,W
0167:  BSF    03.5
0168:  MOVWF  53
....................        
....................    lcd_output_enable(0); 
0169:  BCF    03.5
016A:  BCF    08.2
016B:  BSF    03.5
016C:  BCF    08.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
016D:  BCF    08.4
....................    output_drive(LCD_DATA5); 
016E:  BCF    08.5
....................    output_drive(LCD_DATA6); 
016F:  BCF    08.6
....................    output_drive(LCD_DATA7); 
0170:  BCF    08.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0171:  SWAPF  54,W
0172:  MOVWF  77
0173:  MOVLW  F0
0174:  ANDWF  77,F
0175:  MOVF   77,W
0176:  IORWF  53,W
0177:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
010C:  BSF    03.5
010D:  CLRF   55
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
010E:  BSF    08.4
010F:  MOVLW  00
0110:  BCF    03.5
0111:  BTFSC  08.4
0112:  MOVLW  01
0113:  BSF    03.5
0114:  IORWF  55,F
....................    n |= input(LCD_DATA5) << 1; 
0115:  BSF    08.5
0116:  MOVLW  00
0117:  BCF    03.5
0118:  BTFSC  08.5
0119:  MOVLW  01
011A:  MOVWF  77
011B:  BCF    03.0
011C:  RLF    77,F
011D:  MOVF   77,W
011E:  BSF    03.5
011F:  IORWF  55,F
....................    n |= input(LCD_DATA6) << 2; 
0120:  BSF    08.6
0121:  MOVLW  00
0122:  BCF    03.5
0123:  BTFSC  08.6
0124:  MOVLW  01
0125:  MOVWF  77
0126:  RLF    77,F
0127:  RLF    77,F
0128:  MOVLW  FC
0129:  ANDWF  77,F
012A:  MOVF   77,W
012B:  BSF    03.5
012C:  IORWF  55,F
....................    n |= input(LCD_DATA7) << 3; 
012D:  BSF    08.7
012E:  MOVLW  00
012F:  BCF    03.5
0130:  BTFSC  08.7
0131:  MOVLW  01
0132:  MOVWF  77
0133:  RLF    77,F
0134:  RLF    77,F
0135:  RLF    77,F
0136:  MOVLW  F8
0137:  ANDWF  77,F
0138:  MOVF   77,W
0139:  BSF    03.5
013A:  IORWF  55,F
....................     
....................    return(n); 
013B:  MOVF   55,W
013C:  MOVWF  78
....................   #else 
013D:  BCF    03.5
013E:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
00D7:  BSF    03.5
00D8:  BTFSC  54.0
00D9:  GOTO   0DE
00DA:  BCF    03.5
00DB:  BCF    08.4
00DC:  GOTO   0E0
00DD:  BSF    03.5
00DE:  BCF    03.5
00DF:  BSF    08.4
00E0:  BSF    03.5
00E1:  BCF    08.4
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
00E2:  BTFSC  54.1
00E3:  GOTO   0E8
00E4:  BCF    03.5
00E5:  BCF    08.5
00E6:  GOTO   0EA
00E7:  BSF    03.5
00E8:  BCF    03.5
00E9:  BSF    08.5
00EA:  BSF    03.5
00EB:  BCF    08.5
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
00EC:  BTFSC  54.2
00ED:  GOTO   0F2
00EE:  BCF    03.5
00EF:  BCF    08.6
00F0:  GOTO   0F4
00F1:  BSF    03.5
00F2:  BCF    03.5
00F3:  BSF    08.6
00F4:  BSF    03.5
00F5:  BCF    08.6
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
00F6:  BTFSC  54.3
00F7:  GOTO   0FC
00F8:  BCF    03.5
00F9:  BCF    08.7
00FA:  GOTO   0FE
00FB:  BSF    03.5
00FC:  BCF    03.5
00FD:  BSF    08.7
00FE:  BSF    03.5
00FF:  BCF    08.7
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
0100:  NOP
....................    lcd_output_enable(1); 
0101:  BCF    03.5
0102:  BSF    08.2
0103:  BSF    03.5
0104:  BCF    08.2
....................    delay_us(2); 
0105:  GOTO   106
....................    lcd_output_enable(0); 
0106:  BCF    03.5
0107:  BCF    08.2
0108:  BSF    03.5
0109:  BCF    08.2
010A:  BCF    03.5
010B:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
013F:  BSF    03.5
0140:  BCF    08.2
....................    lcd_rs_tris(); 
0141:  BCF    08.0
....................    lcd_rw_tris(); 
0142:  BCF    08.1
....................   #endif 
....................  
....................    lcd_output_rs(0); 
0143:  BCF    03.5
0144:  BCF    08.0
0145:  BSF    03.5
0146:  BCF    08.0
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
0178:  MOVF   78,W
0179:  MOVWF  53
017A:  BTFSC  53.7
017B:  GOTO   147
....................    lcd_output_rs(address); 
017C:  MOVF   51,F
017D:  BTFSS  03.2
017E:  GOTO   183
017F:  BCF    03.5
0180:  BCF    08.0
0181:  GOTO   185
0182:  BSF    03.5
0183:  BCF    03.5
0184:  BSF    08.0
0185:  BSF    03.5
0186:  BCF    08.0
....................    delay_cycles(1); 
0187:  NOP
....................    lcd_output_rw(0); 
0188:  BCF    03.5
0189:  BCF    08.1
018A:  BSF    03.5
018B:  BCF    08.1
....................    delay_cycles(1); 
018C:  NOP
....................    lcd_output_enable(0); 
018D:  BCF    03.5
018E:  BCF    08.2
018F:  BSF    03.5
0190:  BCF    08.2
....................    lcd_send_nibble(n >> 4); 
0191:  SWAPF  52,W
0192:  MOVWF  53
0193:  MOVLW  0F
0194:  ANDWF  53,F
0195:  MOVF   53,W
0196:  MOVWF  54
0197:  BCF    03.5
0198:  CALL   0D7
....................    lcd_send_nibble(n & 0xf); 
0199:  BSF    03.5
019A:  MOVF   52,W
019B:  ANDLW  0F
019C:  MOVWF  53
019D:  MOVWF  54
019E:  BCF    03.5
019F:  CALL   0D7
01A0:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
01A1:  MOVLW  28
01A2:  BSF    03.5
01A3:  MOVWF  49
01A4:  MOVLW  0C
01A5:  MOVWF  4A
01A6:  MOVLW  01
01A7:  MOVWF  4B
01A8:  MOVLW  06
01A9:  MOVWF  4C
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
01AA:  BCF    03.5
01AB:  BCF    08.2
01AC:  BSF    03.5
01AD:  BCF    08.2
....................    lcd_output_rs(0); 
01AE:  BCF    03.5
01AF:  BCF    08.0
01B0:  BSF    03.5
01B1:  BCF    08.0
....................    lcd_output_rw(0); 
01B2:  BCF    03.5
01B3:  BCF    08.1
01B4:  BSF    03.5
01B5:  BCF    08.1
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
01B6:  BCF    08.4
....................    output_drive(LCD_DATA5); 
01B7:  BCF    08.5
....................    output_drive(LCD_DATA6); 
01B8:  BCF    08.6
....................    output_drive(LCD_DATA7); 
01B9:  BCF    08.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
01BA:  BCF    08.2
....................    lcd_rs_tris(); 
01BB:  BCF    08.0
....................    lcd_rw_tris(); 
01BC:  BCF    08.1
....................  #endif 
....................      
....................    delay_ms(15); 
01BD:  MOVLW  0F
01BE:  MOVWF  4D
01BF:  BCF    03.5
01C0:  CALL   0C2
....................    for(i=1;i<=3;++i) 
01C1:  MOVLW  01
01C2:  BSF    03.5
01C3:  MOVWF  48
01C4:  MOVF   48,W
01C5:  SUBLW  03
01C6:  BTFSS  03.0
01C7:  GOTO   1D4
....................    { 
....................        lcd_send_nibble(3); 
01C8:  MOVLW  03
01C9:  MOVWF  54
01CA:  BCF    03.5
01CB:  CALL   0D7
....................        delay_ms(5); 
01CC:  MOVLW  05
01CD:  BSF    03.5
01CE:  MOVWF  4D
01CF:  BCF    03.5
01D0:  CALL   0C2
01D1:  BSF    03.5
01D2:  INCF   48,F
01D3:  GOTO   1C4
....................    } 
....................     
....................    lcd_send_nibble(2); 
01D4:  MOVLW  02
01D5:  MOVWF  54
01D6:  BCF    03.5
01D7:  CALL   0D7
....................    delay_ms(5); 
01D8:  MOVLW  05
01D9:  BSF    03.5
01DA:  MOVWF  4D
01DB:  BCF    03.5
01DC:  CALL   0C2
....................    for(i=0;i<=3;++i) 
01DD:  BSF    03.5
01DE:  CLRF   48
01DF:  MOVF   48,W
01E0:  SUBLW  03
01E1:  BTFSS  03.0
01E2:  GOTO   1F1
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
01E3:  MOVLW  C9
01E4:  ADDWF  48,W
01E5:  MOVWF  04
01E6:  BCF    03.7
01E7:  MOVF   00,W
01E8:  MOVWF  4D
01E9:  CLRF   51
01EA:  MOVF   4D,W
01EB:  MOVWF  52
01EC:  BCF    03.5
01ED:  CALL   13F
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
01EE:  BSF    03.5
01EF:  INCF   48,F
01F0:  GOTO   1DF
01F1:  BCF    03.5
01F2:  BCF    0A.3
01F3:  BCF    0A.4
01F4:  GOTO   5DB (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
01F5:  BSF    03.5
01F6:  DECFSZ 4E,W
01F7:  GOTO   1F9
01F8:  GOTO   1FC
....................       address=LCD_LINE_TWO; 
01F9:  MOVLW  40
01FA:  MOVWF  4F
01FB:  GOTO   1FD
....................    else 
....................       address=0; 
01FC:  CLRF   4F
....................       
....................    address+=x-1; 
01FD:  MOVLW  01
01FE:  SUBWF  4D,W
01FF:  ADDWF  4F,F
....................    lcd_send_byte(0,0x80|address); 
0200:  MOVF   4F,W
0201:  IORLW  80
0202:  MOVWF  50
0203:  CLRF   51
0204:  MOVF   50,W
0205:  MOVWF  52
0206:  BCF    03.5
0207:  CALL   13F
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0208:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
0209:  BSF    03.5
020A:  MOVF   4C,W
020B:  XORLW  07
020C:  BCF    03.5
020D:  BTFSC  03.2
020E:  GOTO   219
020F:  XORLW  0B
0210:  BTFSC  03.2
0211:  GOTO   220
0212:  XORLW  06
0213:  BTFSC  03.2
0214:  GOTO   22C
0215:  XORLW  02
0216:  BTFSC  03.2
0217:  GOTO   234
0218:  GOTO   23B
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
0219:  MOVLW  01
021A:  BSF    03.5
021B:  MOVWF  4D
021C:  MOVWF  4E
021D:  BCF    03.5
021E:  CALL   1F5
021F:  GOTO   242
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
0220:  BSF    03.5
0221:  CLRF   51
0222:  MOVLW  01
0223:  MOVWF  52
0224:  BCF    03.5
0225:  CALL   13F
....................                      delay_ms(2); 
0226:  MOVLW  02
0227:  BSF    03.5
0228:  MOVWF  4D
0229:  BCF    03.5
022A:  CALL   0C2
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
022B:  GOTO   242
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
022C:  MOVLW  01
022D:  BSF    03.5
022E:  MOVWF  4D
022F:  MOVLW  02
0230:  MOVWF  4E
0231:  BCF    03.5
0232:  CALL   1F5
0233:  GOTO   242
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
0234:  BSF    03.5
0235:  CLRF   51
0236:  MOVLW  10
0237:  MOVWF  52
0238:  BCF    03.5
0239:  CALL   13F
023A:  GOTO   242
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
023B:  MOVLW  01
023C:  BSF    03.5
023D:  MOVWF  51
023E:  MOVF   4C,W
023F:  MOVWF  52
0240:  BCF    03.5
0241:  CALL   13F
....................      #endif 
....................    } 
0242:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
05AE:  BCF    03.5
05AF:  CLRF   2C
05B0:  CLRF   2D
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... //spi modes 
.................... #define SPI_MODE_0  (SPI_L_TO_H | SPI_XMIT_L_TO_H) 
.................... #define SPI_MODE_1  (SPI_L_TO_H) 
.................... #define SPI_MODE_2  (SPI_H_TO_L) 
.................... #define SPI_MODE_3  (SPI_H_TO_L | SPI_XMIT_L_TO_H) 
....................  
.................... #include "rfid.h" 
.................... /*  
....................  * File:   rfid.h 
....................  * Author: Shashikant 
....................  * 
....................  * Created on 2 July, 2018, 1:34 PM 
....................  */ 
....................  
.................... #ifndef RFID_H 
.................... #define	RFID_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................  
....................  
....................  
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* RFID_H */ 
....................  
.................... #define     MAX_LEN               16        // Maximum length of an array. CHECK IF IT IS MAXIMUM LENGTH/SIZE OF FIFO!!!!!!!!!!! 
....................  
.................... //MF522 MFRC522 error codes. 
.................... #define     MI_OK                 0         // Everything A-OK. 
.................... #define     MI_NOTAGERR           1         // No tag error 
.................... #define     MI_ERR                2         // General error 
....................  
.................... //MF522 Command word 
.................... #define     MFRC522_IDLE          0x00      // NO action; Cancel the current command 
.................... #define     MFRC522_MEM           0x01      // Store 25 byte into the internal buffer. 
.................... #define     MFRC522_GENID         0x02      // Generates a 10 byte random ID number. 
.................... #define     MFRC522_CALCCRC       0x03      // CRC Calculate or selftest. 
.................... #define     MFRC522_TRANSMIT      0x04      // Transmit data 
.................... #define     MFRC522_NOCMDCH       0x07      // No command change. 
.................... #define     MFRC522_RECEIVE       0x08      // Receive Data 
.................... #define     MFRC522_TRANSCEIVE    0x0C      // Transmit and receive data, 
.................... #define     MFRC522_AUTHENT       0x0E      // Authentication Key 
.................... #define     MFRC522_SOFTRESET     0x0F      // Reset 
....................  
.................... //Mifare_One tag command word 
.................... #define     MF1_REQIDL            0x26      // find the antenna area does not enter hibernation 
.................... #define     MF1_REQALL            0x52      // find all the tags antenna area 
.................... #define     MF1_ANTICOLL          0x93      // anti-collision 
.................... #define     MF1_SELECTTAG         0x93      // election tag 
.................... #define     MF1_AUTHENT1A         0x60      // authentication key A 
.................... #define     MF1_AUTHENT1B         0x61      // authentication key B 
.................... #define     MF1_READ              0x30      // Read Block 
.................... #define     MF1_WRITE             0xA0      // write block 
.................... #define     MF1_DECREMENT         0xC0      // debit 
.................... #define     MF1_INCREMENT         0xC1      // recharge 
.................... #define     MF1_RESTORE           0xC2      // transfer block data to the buffer 
.................... #define     MF1_TRANSFER          0xB0      // save the data in the buffer 
.................... #define     MF1_HALT              0x50      // Sleep 
....................  
....................  
.................... //------------------ MFRC522 registers--------------- 
.................... //Page 0:Command and Status 
.................... #define     Reserved00            0x00 
.................... #define     CommandReg            0x01 
.................... #define     CommIEnReg            0x02 
.................... #define     DivIEnReg             0x03 
.................... #define     CommIrqReg            0x04 
.................... #define     DivIrqReg             0x05 
.................... #define     ErrorReg              0x06 
.................... #define     Status1Reg            0x07 
.................... #define     Status2Reg            0x08 
.................... #define     FIFODataReg           0x09 
.................... #define     FIFOLevelReg          0x0A 
.................... #define     WaterLevelReg         0x0B 
.................... #define     ControlReg            0x0C 
.................... #define     BitFramingReg         0x0D 
.................... #define     CollReg               0x0E 
.................... #define     Reserved01            0x0F 
.................... //Page 1:Command 
.................... #define     Reserved10            0x10 
.................... #define     ModeReg               0x11 
.................... #define     TxModeReg             0x12 
.................... #define     RxModeReg             0x13 
.................... #define     TxControlReg          0x14 
.................... #define     TxAutoReg             0x15 
.................... #define     TxSelReg              0x16 
.................... #define     RxSelReg              0x17 
.................... #define     RxThresholdReg        0x18 
.................... #define     DemodReg              0x19 
.................... #define     Reserved11            0x1A 
.................... #define     Reserved12            0x1B 
.................... #define     MifareReg             0x1C 
.................... #define     Reserved13            0x1D 
.................... #define     Reserved14            0x1E 
.................... #define     SerialSpeedReg        0x1F 
.................... //Page 2:CFG 
.................... #define     Reserved20            0x20 
.................... #define     CRCResultRegM         0x21 
.................... #define     CRCResultRegL         0x22 
.................... #define     Reserved21            0x23 
.................... #define     ModWidthReg           0x24 
.................... #define     Reserved22            0x25 
.................... #define     RFCfgReg              0x26 
.................... #define     GsNReg                0x27 
.................... #define     CWGsPReg              0x28 
.................... #define     ModGsPReg             0x29 
.................... #define     TModeReg              0x2A 
.................... #define     TPrescalerReg         0x2B 
.................... #define     TReloadRegH           0x2C 
.................... #define     TReloadRegL           0x2D 
.................... #define     TCounterValueRegH     0x2E 
.................... #define     TCounterValueRegL     0x2F 
.................... //Page 3:TestRegister 
.................... #define     Reserved30            0x30 
.................... #define     TestSel1Reg           0x31 
.................... #define     TestSel2Reg           0x32 
.................... #define     TestPinEnReg          0x33 
.................... #define     TestPinValueReg       0x34 
.................... #define     TestBusReg            0x35 
.................... #define     AutoTestReg           0x36 
.................... #define     VersionReg            0x37 
.................... #define     AnalogTestReg         0x38 
.................... #define     TestDAC1Reg           0x39 
.................... #define     TestDAC2Reg           0x3A 
.................... #define     TestADCReg            0x3B 
.................... #define     Reserved31            0x3C 
.................... #define     Reserved32            0x3D 
.................... #define     Reserved33            0x3E 
.................... #define     Reserved34            0x3F 
.................... //-----------------------------------------------  
....................  
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Writes value to a register. 
....................   @param   addr  The address a register. 
....................   @param   val   The value to write to a register. 
....................  */ 
.................... /**************************************************************************/ 
.................... void writeToRegister(byte addr, byte val) { 
....................   output_low(CS); 
*
032D:  BSF    03.5
032E:  BCF    05.5
032F:  BCF    03.5
0330:  BCF    05.5
....................   //Address format: 0XXXXXX0 
....................   spi_write((addr<<1)&0x7E); 
0331:  BCF    03.0
0332:  BSF    03.5
0333:  RLF    4C,W
0334:  ANDLW  7E
0335:  MOVWF  4E
0336:  BCF    03.5
0337:  MOVF   13,W
0338:  BSF    03.5
0339:  MOVF   4E,W
033A:  BCF    03.5
033B:  MOVWF  13
033C:  BSF    03.5
033D:  RRF    14,W
033E:  BTFSS  03.0
033F:  GOTO   33D
....................   spi_write(val); 
0340:  BCF    03.5
0341:  MOVF   13,W
0342:  BSF    03.5
0343:  MOVF   4D,W
0344:  BCF    03.5
0345:  MOVWF  13
0346:  BSF    03.5
0347:  RRF    14,W
0348:  BTFSS  03.0
0349:  GOTO   347
....................   output_high(CS); 
034A:  BCF    05.5
034B:  BCF    03.5
034C:  BSF    05.5
034D:  RETURN
.................... } 
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Reads the value at a register. 
....................   @param   addr  The address a register. 
....................   @returns The byte at the register. 
....................  */ 
.................... /**************************************************************************/ 
.................... byte readFromRegister(byte addr) { 
....................   byte val; 
....................   output_low(CS); 
034E:  BSF    03.5
034F:  BCF    05.5
0350:  BCF    03.5
0351:  BCF    05.5
....................   spi_write(((addr<<1)&0x7E) | 0x80); 
0352:  BCF    03.0
0353:  BSF    03.5
0354:  RLF    4B,W
0355:  ANDLW  7E
0356:  IORLW  80
0357:  MOVWF  4D
0358:  BCF    03.5
0359:  MOVF   13,W
035A:  BSF    03.5
035B:  MOVF   4D,W
035C:  BCF    03.5
035D:  MOVWF  13
035E:  BSF    03.5
035F:  RRF    14,W
0360:  BTFSS  03.0
0361:  GOTO   35F
....................   val =spi_read(0x00); 
0362:  BCF    03.5
0363:  MOVF   13,W
0364:  CLRF   13
0365:  BSF    03.5
0366:  RRF    14,W
0367:  BTFSS  03.0
0368:  GOTO   366
0369:  BCF    03.5
036A:  MOVF   13,W
036B:  BSF    03.5
036C:  MOVWF  4C
....................   output_high(CS); 
036D:  BCF    05.5
036E:  BCF    03.5
036F:  BSF    05.5
....................   return val; 
0370:  BSF    03.5
0371:  MOVF   4C,W
0372:  MOVWF  78
0373:  BCF    03.5
0374:  RETURN
.................... } 
....................  
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Adds a bitmask to a register. 
....................   @param   addr   The address a register. 
....................   @param   mask  The mask to update the register with. 
....................  */ 
.................... /**************************************************************************/ 
.................... void setBitMask(byte addr, byte mask) { 
....................   byte current; 
....................   current = readFromRegister(addr); 
*
03D2:  MOVF   48,W
03D3:  MOVWF  4B
03D4:  BCF    03.5
03D5:  CALL   34E
03D6:  MOVF   78,W
03D7:  BSF    03.5
03D8:  MOVWF  4A
....................   writeToRegister(addr, current | mask); 
03D9:  MOVF   4A,W
03DA:  IORWF  49,W
03DB:  MOVWF  4B
03DC:  MOVF   48,W
03DD:  MOVWF  4C
03DE:  MOVF   4B,W
03DF:  MOVWF  4D
03E0:  BCF    03.5
03E1:  CALL   32D
03E2:  NOP
.................... } 
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Removes a bitmask from the register. 
....................   @param   reg   The address a register. 
....................   @param   mask  The mask to update the register with. 
....................  */ 
.................... /**************************************************************************/ 
.................... void clearBitMask(byte addr, byte mask) { 
....................   byte current; 
....................   current = readFromRegister(addr); 
....................   writeToRegister(addr, current & (~mask)); 
.................... } 
....................  
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Sends a SOFTRESET command to the MFRC522 chip. 
....................  */ 
.................... /**************************************************************************/ 
.................... void reset() { 
....................   writeToRegister(CommandReg, MFRC522_SOFTRESET); 
*
0379:  MOVLW  01
037A:  BSF    03.5
037B:  MOVWF  4C
037C:  MOVLW  0F
037D:  MOVWF  4D
037E:  BCF    03.5
037F:  CALL   32D
0380:  NOP
.................... } 
....................  
....................  
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Does the setup for the MFRC522. 
....................  */ 
.................... /**************************************************************************/ 
.................... void MFRC_begin() { 
....................   output_high(CS); 
*
0375:  BSF    03.5
0376:  BCF    05.5
0377:  BCF    03.5
0378:  BSF    05.5
....................   reset(); 
....................   //Timer: TPrescaler*TreloadVal/6.78MHz = 24ms 
....................   writeToRegister(TModeReg, 0x8D);    
*
0381:  MOVLW  2A
0382:  BSF    03.5
0383:  MOVWF  4C
0384:  MOVLW  8D
0385:  MOVWF  4D
0386:  BCF    03.5
0387:  CALL   32D
....................   delay_ms(20); // Tauto=1; f(Timer) = 6.78MHz/TPreScaler 
0388:  MOVLW  14
0389:  BSF    03.5
038A:  MOVWF  4D
038B:  BCF    03.5
038C:  CALL   0C2
....................   writeToRegister(TPrescalerReg, 0x3E);  // TModeReg[3..0] + TPrescalerReg 
038D:  MOVLW  2B
038E:  BSF    03.5
038F:  MOVWF  4C
0390:  MOVLW  3E
0391:  MOVWF  4D
0392:  BCF    03.5
0393:  CALL   32D
....................   delay_ms(20); 
0394:  MOVLW  14
0395:  BSF    03.5
0396:  MOVWF  4D
0397:  BCF    03.5
0398:  CALL   0C2
....................   writeToRegister(TReloadRegL, 30); 
0399:  MOVLW  2D
039A:  BSF    03.5
039B:  MOVWF  4C
039C:  MOVLW  1E
039D:  MOVWF  4D
039E:  BCF    03.5
039F:  CALL   32D
....................   delay_ms(20); 
03A0:  MOVLW  14
03A1:  BSF    03.5
03A2:  MOVWF  4D
03A3:  BCF    03.5
03A4:  CALL   0C2
....................   writeToRegister(TReloadRegH, 0); 
03A5:  MOVLW  2C
03A6:  BSF    03.5
03A7:  MOVWF  4C
03A8:  CLRF   4D
03A9:  BCF    03.5
03AA:  CALL   32D
....................   delay_ms(20); 
03AB:  MOVLW  14
03AC:  BSF    03.5
03AD:  MOVWF  4D
03AE:  BCF    03.5
03AF:  CALL   0C2
....................   writeToRegister(TxAutoReg, 0x40);      // 100%ASK 
03B0:  MOVLW  15
03B1:  BSF    03.5
03B2:  MOVWF  4C
03B3:  MOVLW  40
03B4:  MOVWF  4D
03B5:  BCF    03.5
03B6:  CALL   32D
....................   delay_ms(20); 
03B7:  MOVLW  14
03B8:  BSF    03.5
03B9:  MOVWF  4D
03BA:  BCF    03.5
03BB:  CALL   0C2
....................   writeToRegister(ModeReg, 0x3D);        // CRC initial value 0x6363 
03BC:  MOVLW  11
03BD:  BSF    03.5
03BE:  MOVWF  4C
03BF:  MOVLW  3D
03C0:  MOVWF  4D
03C1:  BCF    03.5
03C2:  CALL   32D
....................   delay_ms(20); 
03C3:  MOVLW  14
03C4:  BSF    03.5
03C5:  MOVWF  4D
03C6:  BCF    03.5
03C7:  CALL   0C2
....................  //writeToRegister(TxControlReg, 0x82);      
....................   delay_ms(20); 
03C8:  MOVLW  14
03C9:  BSF    03.5
03CA:  MOVWF  4D
03CB:  BCF    03.5
03CC:  CALL   0C2
....................  setBitMask(TxControlReg, 0x03);        // Turn antenna on. 
03CD:  MOVLW  14
03CE:  BSF    03.5
03CF:  MOVWF  48
03D0:  MOVLW  03
03D1:  MOVWF  49
*
03E3:  BCF    0A.3
03E4:  BCF    0A.4
03E5:  GOTO   5EF (RETURN)
.................... } 
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Checks the firmware version of the chip. 
....................   @returns The firmware version of the MFRC522 chip. 
....................  */ 
.................... /**************************************************************************/ 
.................... byte getFirmwareVersion() { 
....................   byte response; 
....................   response = readFromRegister(VersionReg); 
....................   return response; 
.................... } 
....................  
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................  
....................   @brief   Sends a command to a tag. 
....................  
....................   @param   cmd     The command to the MFRC522 to send a command to the tag. 
....................   @param   data    The data that is needed to complete the command. 
....................   @param   dlen    The length of the data. 
....................   @param   result  The result returned by the tag. 
....................   @param   rlen    The number of valid bits in the resulting value. 
....................  
....................   @returns Returns the status of the calculation. 
....................            MI_ERR        if something went wrong, 
....................            MI_NOTAGERR   if there was no tag to send the command to. 
....................            MI_OK         if everything went OK. 
....................  
....................  */ 
.................... /**************************************************************************/ 
....................  
.................... int commandTag(byte cmd, byte *data, int dlen, byte *result, int *rlen) { 
....................   int status = MI_ERR; 
....................   byte irqEn = 0x00; 
....................   byte waitIRq = 0x00; 
....................   byte lastBits, n; 
....................   int i; 
....................  
....................   switch (cmd) { 
....................   case MFRC522_AUTHENT: 
....................     irqEn = 0x12; 
....................     waitIRq = 0x10; 
....................     break; 
....................   case MFRC522_TRANSCEIVE: 
....................     irqEn = 0x77; 
....................     waitIRq = 0x30; 
....................     break; 
....................   default: 
....................     break; 
....................   } 
....................  
....................   writeToRegister(CommIEnReg, irqEn|0x80);    // interrupt request 
....................   clearBitMask(CommIrqReg, 0x80);             // Clear all interrupt requests bits. 
....................   setBitMask(FIFOLevelReg, 0x80);             // FlushBuffer=1, FIFO initialization. 
....................  
....................   writeToRegister(CommandReg, MFRC522_IDLE);  // No action, cancel the current command. 
....................  
....................   // Write to FIFO 
....................   for (i=0; i < dlen; i++) { 
....................     writeToRegister(FIFODataReg, data[i]); 
....................   } 
....................  
....................   // Execute the command. 
....................   writeToRegister(CommandReg, cmd); 
....................   if (cmd == MFRC522_TRANSCEIVE) { 
....................     setBitMask(BitFramingReg, 0x80);  // StartSend=1, transmission of data starts 
....................   } 
....................  
....................   // Waiting for the command to complete so we can receive data. 
....................   i = 25; // Max wait time is 25ms. 
....................   do { 
....................     delay_ms(1); 
....................     // CommIRqReg[7..0] 
....................     // Set1 TxIRq RxIRq IdleIRq HiAlerIRq LoAlertIRq ErrIRq TimerIRq 
....................     n = readFromRegister(CommIrqReg); 
....................     i--; 
....................   } while ((i!=0) && !(n&0x01) && !(n&waitIRq)); 
....................  
....................   clearBitMask(BitFramingReg, 0x80);  // StartSend=0 
....................  
....................   if (i != 0) { // Request did not time out. 
....................     if(!(readFromRegister(ErrorReg) & 0x1D)) {  // BufferOvfl Collerr CRCErr ProtocolErr 
....................       status = MI_OK; 
....................       if (n & irqEn & 0x01) { 
....................         status = MI_NOTAGERR; 
....................       } 
....................  
....................       if (cmd == MFRC522_TRANSCEIVE) { 
....................         n = readFromRegister(FIFOLevelReg); 
....................         lastBits = readFromRegister(ControlReg) & 0x07; 
....................         if (lastBits) { 
....................           *rlen = (n-1)*8 + lastBits; 
....................         } else { 
....................           *rlen = n*8; 
....................         } 
....................  
....................         if (n == 0) { 
....................           n = 1; 
....................         } 
....................  
....................         if (n > MAX_LEN) { 
....................           n = MAX_LEN; 
....................         } 
....................  
....................         // Reading the recieved data from FIFO. 
....................         for (i=0; i<n; i++) { 
....................           result[i] = readFromRegister(FIFODataReg); 
....................         } 
....................       } 
....................     } else { 
....................       status = MI_ERR; 
....................     } 
....................   } 
....................   return status; 
.................... } 
....................  
....................  
.................... /**************************************************************************/ 
.................... /* 
....................  
....................   @brief   Checks to see if there is a tag in the vicinity. 
....................  
....................   @param   mode  The mode we are requsting in. 
....................   @param   type  If we find a tag, this will be the type of that tag. 
....................                  0x4400 = Mifare_UltraLight 
....................                  0x0400 = Mifare_One(S50) 
....................                  0x0200 = Mifare_One(S70) 
....................                  0x0800 = Mifare_Pro(X) 
....................                  0x4403 = Mifare_DESFire 
....................  
....................   @returns Returns the status of the request. 
....................            MI_ERR        if something went wrong, 
....................            MI_NOTAGERR   if there was no tag to send the command to. 
....................            MI_OK         if everything went OK. 
....................  
....................  */ 
.................... /**************************************************************************/ 
.................... int requestTag(byte mode, byte *data) { 
....................   int status, len; 
....................   writeToRegister(BitFramingReg, 0x07);  // TxLastBists = BitFramingReg[2..0] 
....................  
....................   data[0] = mode; 
....................   status = commandTag(MFRC522_TRANSCEIVE, data, 1, data, &len); 
....................  
....................   if ((status != MI_OK) || (len != 0x10)) { 
....................     status = MI_ERR; 
....................   } 
....................  
....................   return status; 
.................... } 
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................  
....................   @brief   Handles collisions that might occur if there are multiple 
....................            tags available. 
....................  
....................   @param   serial  The serial nb of the tag. 
....................  
....................   @returns Returns the status of the collision detection. 
....................            MI_ERR        if something went wrong, 
....................            MI_NOTAGERR   if there was no tag to send the command to. 
....................            MI_OK         if everything went OK. 
....................  
....................  */ 
.................... /**************************************************************************/ 
.................... int antiCollision(byte *serial) { 
....................   int status, i, len; 
....................   byte check = 0x00; 
....................  
....................   writeToRegister(BitFramingReg, 0x00);  // TxLastBits = BitFramingReg[2..0] 
....................  
....................   serial[0] = MF1_ANTICOLL; 
....................   serial[1] = 0x20; 
....................   status = commandTag(MFRC522_TRANSCEIVE, serial, 2, serial, &len); 
....................   len = len / 8; // len is in bits, and we want each byte. 
....................   if (status == MI_OK) { 
....................     // The checksum of the tag is the ^ of all the values. 
....................     for (i = 0; i < len-1; i++) { 
....................       check ^= serial[i]; 
....................     } 
....................     // The checksum should be the same as the one provided from the 
....................     // tag (serial[4]). 
....................     if (check != serial[i]) { 
....................       status = MI_ERR; 
....................     } 
....................   } 
....................  
....................   return status; 
.................... } 
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................  
....................   @brief   Calculates the CRC value for some data that should be sent to 
....................            a tag. 
....................  
....................   @param   data    The data to calculate the value for. 
....................   @param   len     The length of the data. 
....................   @param   result  The result of the CRC calculation. 
....................  
....................  */ 
.................... /**************************************************************************/ 
.................... void calculateCRC(byte *data, int len, byte *result) { 
....................   int i; 
....................   byte n; 
....................  
....................   clearBitMask(DivIrqReg, 0x04);   // CRCIrq = 0 
....................   setBitMask(FIFOLevelReg, 0x80);  // Clear the FIFO pointer 
....................  
....................   //Writing data to the FIFO. 
....................   for (i = 0; i < len; i++) { 
....................     writeToRegister(FIFODataReg, data[i]); 
....................   } 
....................   writeToRegister(CommandReg, MFRC522_CALCCRC); 
....................  
....................   // Wait for the CRC calculation to complete. 
....................   i = 0xFF; 
....................   do { 
....................     n = readFromRegister(DivIrqReg); 
....................     i--; 
....................   } while ((i != 0) && !(n & 0x04));  //CRCIrq = 1 
....................  
....................   // Read the result from the CRC calculation. 
....................   result[0] = readFromRegister(CRCResultRegL); 
....................   result[1] = readFromRegister(CRCResultRegM); 
.................... } 
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Selects a tag for processing. 
....................   @param   serial  The serial number of the tag that is to be selected. 
....................   @returns The SAK response from the tag. 
....................  */ 
.................... /**************************************************************************/ 
.................... byte selectTag(byte *serial) { 
....................   int i, status, len; 
....................   byte sak; 
....................   byte buffer[9]; 
....................  
....................   buffer[0] = MF1_SELECTTAG; 
....................   buffer[1] = 0x70; 
....................   for (i = 0; i < 5; i++) { 
....................     buffer[i+2] = serial[i]; 
....................   } 
....................   calculateCRC(buffer, 7, &buffer[7]); 
....................  
....................   status = commandTag(MFRC522_TRANSCEIVE, buffer, 9, buffer, &len); 
....................  
....................   if ((status == MI_OK) && (len == 0x18)) { 
....................     sak = buffer[0]; 
....................   } 
....................   else { 
....................     sak = 0; 
....................   } 
....................  
....................   return sak; 
.................... } 
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Handles the authentication between the tag and the reader. 
....................   @param   mode    What authentication key to use. 
....................   @param   block   The block that we want to read. 
....................   @param   key     The authentication key. 
....................   @param   serial  The serial of the tag. 
....................   @returns Returns the status of the collision detection. 
....................            MI_ERR        if something went wrong, 
....................            MI_OK         if everything went OK. 
....................  */ 
.................... /**************************************************************************/ 
.................... int authenticate(byte mode, byte block, byte *key, byte *serial) { 
....................   int i, status, len; 
....................   byte buffer[12]; 
....................  
....................   //Verify the command block address + sector + password + tag serial number 
....................   buffer[0] = mode;          // 0th byte is the mode 
....................   buffer[1] = block;         // 1st byte is the block to address. 
....................   for (i = 0; i < 6; i++) {  // 2nd to 7th byte is the authentication key. 
....................     buffer[i+2] = key[i]; 
....................   } 
....................   for (i = 0; i < 4; i++) {  // 8th to 11th byte is the serial of the tag. 
....................     buffer[i+8] = serial[i]; 
....................   } 
....................  
....................   status = commandTag(MFRC522_AUTHENT, buffer, 12, buffer, &len); 
....................  
....................   if ((status != MI_OK) || (!(readFromRegister(Status2Reg) & 0x08))) { 
....................     status = MI_ERR; 
....................   } 
....................  
....................   return status; 
.................... } 
....................  
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Tries to read from the current (authenticated) tag. 
....................   @param   block   The block that we want to read. 
....................   @param   result  The resulting value returned from the tag. 
....................   @returns Returns the status of the collision detection. 
....................            MI_ERR        if something went wrong, 
....................            MI_OK         if everything went OK. 
....................  */ 
.................... /**************************************************************************/ 
.................... int readFromTag(byte block, byte *result) { 
....................   int status, len; 
....................  
....................   result[0] = MF1_READ; 
....................   result[1] = block; 
....................   calculateCRC(result, 2, &result[2]); 
....................   status = commandTag(MFRC522_TRANSCEIVE, result, 4, result, &len); 
....................  
....................   if ((status != MI_OK) || (len != 0x90)) { 
....................     status = MI_ERR; 
....................   } 
....................  
....................   return status; 
.................... } 
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Tries to write to a block on the current tag. 
....................   @param   block  The block that we want to write to. 
....................   @param   data   The data that we shoudl write to the block. 
....................   @returns Returns the status of the collision detection. 
....................            MI_ERR        if something went wrong, 
....................            MI_OK         if everything went OK. 
....................  */ 
.................... /**************************************************************************/ 
.................... int writeToTag(byte block, byte *data) { 
....................   int status, i, len; 
....................   byte buffer[18]; 
....................  
....................   buffer[0] = MF1_WRITE; 
....................   buffer[1] = block; 
....................   calculateCRC(buffer, 2, &buffer[2]); 
....................   status = commandTag(MFRC522_TRANSCEIVE, buffer, 4, buffer, &len); 
....................  
....................   if ((status != MI_OK) || (len != 4) || ((buffer[0] & 0x0F) != 0x0A)) { 
....................     status = MI_ERR; 
....................   } 
....................  
....................   if (status == MI_OK) { 
....................     for (i = 0; i < 16; i++) { 
....................       buffer[i] = data[i]; 
....................     } 
....................     calculateCRC(buffer, 16, &buffer[16]); 
....................     status = commandTag(MFRC522_TRANSCEIVE, buffer, 18, buffer, &len); 
....................  
....................     if ((status != MI_OK) || (len != 4) || ((buffer[0] & 0x0F) != 0x0A)) { 
....................       status = MI_ERR; 
....................     } 
....................   } 
....................  
....................   return status; 
.................... } 
....................  
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Sends a halt command to the current tag. 
....................   @returns Returns the result of the halt. 
....................            MI_ERR        If the command didn't complete properly. 
....................            MI_OK         If the command completed. 
....................  */ 
.................... /**************************************************************************/ 
.................... int haltTag() { 
....................   int status, len; 
....................   byte buffer[4]; 
....................  
....................   buffer[0] = MF1_HALT; 
....................   buffer[1] = 0; 
....................   calculateCRC(buffer, 2, &buffer[2]); 
....................   status = commandTag(MFRC522_TRANSCEIVE, buffer, 4, buffer, &len); 
....................   clearBitMask(Status2Reg, 0x08);  // turn off encryption 
....................   return status; 
.................... } 
....................  
....................  
....................  
....................  
.................... short intrb = FALSE; 
....................  
.................... #int_EXT 
.................... void ext_isr(void) 
.................... { 
....................     intrb = TRUE; 
*
004F:  BSF    32.0
....................      
0050:  BCF    0B.1
0051:  BCF    0A.3
0052:  BCF    0A.4
0053:  GOTO   02B
.................... }  
....................  
....................  
....................  
....................  
.................... byte FoundTag; // Variable used to check if Tag was found 
.................... byte ReadTag; // Variable used to store anti-collision value to read Tag information 
.................... byte TagData[16]; // Variable used to store Full Tag Data 
.................... byte GoodTagSerialNumber[4] = {0x9E, 0x80, 0xB1, 0x59}; // The Tag Serial number we are looking for 
*
05B1:  MOVLW  9E
05B2:  MOVWF  45
05B3:  MOVLW  80
05B4:  MOVWF  46
05B5:  MOVLW  B1
05B6:  MOVWF  47
05B7:  MOVLW  59
05B8:  MOVWF  48
.................... int i=0; 
.................... char buffer[20],buffer2[20],text[20]; 
.................... byte version; 
.................... int GoodTag=0; // Variable used to confirm good Tag Detected  
....................  
....................  
.................... void CheckRFIDHardware(){ 
.................... lcd_putc("\f Checking RFID..."); 
*
03E6:  MOVLW  54
03E7:  BSF    03.6
03E8:  MOVWF  0D
03E9:  MOVLW  00
03EA:  MOVWF  0F
03EB:  BCF    03.6
03EC:  CALL   243
.................... printf("\r\nChecking If Rfid Is Connected"); 
03ED:  MOVLW  5E
03EE:  BSF    03.6
03EF:  MOVWF  0D
03F0:  MOVLW  00
03F1:  MOVWF  0F
03F2:  BCF    03.6
03F3:  CALL   2B7
.................... //check request 
.................... version = readFromRegister(VersionReg); 
03F4:  MOVLW  37
03F5:  BSF    03.5
03F6:  MOVWF  4B
03F7:  BCF    03.5
03F8:  CALL   34E
03F9:  MOVF   78,W
03FA:  MOVWF  5E
.................... delay_ms(100); 
03FB:  MOVLW  64
03FC:  BSF    03.5
03FD:  MOVWF  4D
03FE:  BCF    03.5
03FF:  CALL   0C2
....................  
.................... //response is 00 then hardware is not connected 
.................... if(!version){ 
0400:  MOVF   5E,F
0401:  BTFSS  03.2
0402:  GOTO   41C
....................     lcd_putc("\f RFID Not Found \n Check Again.."); 
0403:  MOVLW  6E
0404:  BSF    03.6
0405:  MOVWF  0D
0406:  MOVLW  00
0407:  MOVWF  0F
0408:  BCF    03.6
0409:  CALL   243
....................     printf("\r\nRFID Hw not Found"); 
040A:  MOVLW  7F
040B:  BSF    03.6
040C:  MOVWF  0D
040D:  MOVLW  00
040E:  MOVWF  0F
040F:  BCF    03.6
0410:  CALL   2B7
....................     delay_ms(5000); 
0411:  MOVLW  14
0412:  BSF    03.5
0413:  MOVWF  48
0414:  MOVLW  FA
0415:  MOVWF  4D
0416:  BCF    03.5
0417:  CALL   0C2
0418:  BSF    03.5
0419:  DECFSZ 48,F
041A:  GOTO   414
041B:  BCF    03.5
.................... } 
.................... if(version){ 
041C:  MOVF   5E,F
041D:  BTFSC  03.2
041E:  GOTO   590
....................     lcd_putc("\f RFID Found"); 
041F:  MOVLW  89
0420:  BSF    03.6
0421:  MOVWF  0D
0422:  MOVLW  00
0423:  MOVWF  0F
0424:  BCF    03.6
0425:  CALL   243
....................     printf(lcd_putc,"\nV: %x",version); 
0426:  MOVLW  90
0427:  BSF    03.6
0428:  MOVWF  0D
0429:  MOVLW  00
042A:  MOVWF  0F
042B:  BCF    03.0
042C:  MOVLW  04
042D:  BSF    03.5
042E:  BCF    03.6
042F:  MOVWF  48
*
04A6:  BCF    03.5
04A7:  MOVF   5E,W
04A8:  BSF    03.5
04A9:  MOVWF  48
04AA:  MOVLW  57
04AB:  MOVWF  49
....................     printf("\r\nRFID Found and HW version is: %2X\r\n",version); 
*
04D0:  MOVLW  94
04D1:  BSF    03.6
04D2:  MOVWF  0D
04D3:  MOVLW  00
04D4:  MOVWF  0F
04D5:  BCF    03.0
04D6:  MOVLW  20
04D7:  BSF    03.5
04D8:  BCF    03.6
04D9:  MOVWF  48
*
0552:  BCF    03.5
0553:  MOVF   5E,W
0554:  BSF    03.5
0555:  MOVWF  48
0556:  MOVLW  37
0557:  MOVWF  49
*
057D:  MOVLW  0D
057E:  BTFSS  0C.4
057F:  GOTO   57E
0580:  MOVWF  19
0581:  MOVLW  0A
0582:  BTFSS  0C.4
0583:  GOTO   582
0584:  MOVWF  19
....................     delay_ms(1000); 
0585:  MOVLW  04
0586:  BSF    03.5
0587:  MOVWF  48
0588:  MOVLW  FA
0589:  MOVWF  4D
058A:  BCF    03.5
058B:  CALL   0C2
058C:  BSF    03.5
058D:  DECFSZ 48,F
058E:  GOTO   588
058F:  BCF    03.5
.................... } 
0590:  BCF    0A.3
0591:  BCF    0A.4
0592:  GOTO   5F0 (RETURN)
....................  
.................... }  
....................  
.................... void readRFID() 
.................... { 
....................      
....................     lcd_putc("\fHold Tag Still"); 
....................      
....................     delay_ms(500); 
....................     // Get anti-collision value to properly read information from the Tag 
....................     ReadTag = antiCollision(TagData); 
....................      
....................     lcd_putc("\f"); 
....................      
....................     lcd_putc("Data: "); 
....................       
....................    for(i=0;i<=2;i++) 
....................    { 
....................     sprintf(buffer2,"%2X",(TagData[i])); //display version in hexadecimal 
....................     delay_ms(20); 
....................     printf(lcd_putc,buffer2); 
....................    
....................    } 
....................     sprintf(buffer2,"%2X",(TagData[i])); //display version in hexadecimal 
....................     delay_ms(20); 
....................     printf(lcd_putc,buffer2);  
....................      
....................      
....................     delay_ms(2000); 
....................   
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... void main() {    
0593:  MOVF   03,W
0594:  ANDLW  1F
0595:  MOVWF  03
0596:  CLRF   2B
0597:  MOVLW  19
0598:  BSF    03.5
0599:  MOVWF  19
059A:  MOVLW  A6
059B:  MOVWF  18
059C:  MOVLW  90
059D:  BCF    03.5
059E:  MOVWF  18
059F:  BCF    32.0
05A0:  CLRF   49
05A1:  CLRF   5F
05A2:  CLRF   61
05A3:  CLRF   60
05A4:  MOVLW  FF
05A5:  MOVWF  62
05A6:  BSF    03.5
05A7:  BSF    1F.0
05A8:  BSF    1F.1
05A9:  BSF    1F.2
05AA:  BCF    1F.3
05AB:  MOVLW  07
05AC:  MOVWF  1C
05AD:  BCF    03.7
....................      
....................     //setup spi line  
....................      
....................    setup_spi(SPI_MASTER|SPI_MODE_0|SPI_CLK_DIV_16);  
*
05B9:  BCF    14.5
05BA:  BCF    62.5
05BB:  MOVF   62,W
05BC:  BSF    03.5
05BD:  MOVWF  07
05BE:  BCF    03.5
05BF:  BSF    62.4
05C0:  MOVF   62,W
05C1:  BSF    03.5
05C2:  MOVWF  07
05C3:  BCF    03.5
05C4:  BCF    62.3
05C5:  MOVF   62,W
05C6:  BSF    03.5
05C7:  MOVWF  07
05C8:  MOVLW  21
05C9:  BCF    03.5
05CA:  MOVWF  14
05CB:  MOVLW  40
05CC:  BSF    03.5
05CD:  MOVWF  14
....................    port_b_pullups(TRUE);  
05CE:  BCF    01.7
....................    delay_ms(20); 
05CF:  MOVLW  14
05D0:  MOVWF  4D
05D1:  BCF    03.5
05D2:  CALL   0C2
....................      
....................    ext_int_edge(H_TO_L); 
05D3:  BSF    03.5
05D4:  BCF    01.6
....................     
....................    clear_interrupt (INT_EXT);     
05D5:  BCF    03.5
05D6:  BCF    0B.1
....................    enable_interrupts(INT_EXT); 
05D7:  BSF    0B.4
....................    enable_interrupts(GLOBAL);  
05D8:  MOVLW  C0
05D9:  IORWF  0B,F
....................     
....................    
....................      
....................    
....................     
....................     
....................      
....................     //init lcd and put some string 
....................     lcd_init(); 
05DA:  GOTO   1A1
....................      
....................     lcd_putc("\f Starting...");     
05DB:  MOVLW  B4
05DC:  BSF    03.6
05DD:  MOVWF  0D
05DE:  MOVLW  00
05DF:  MOVWF  0F
05E0:  BCF    03.6
05E1:  CALL   243
....................      
....................     printf("\r\nstarting..");//output to terminal     
05E2:  MOVLW  BB
05E3:  BSF    03.6
05E4:  MOVWF  0D
05E5:  MOVLW  00
05E6:  MOVWF  0F
05E7:  BCF    03.6
05E8:  CALL   2B7
....................      
....................     delay_ms(100);    
05E9:  MOVLW  64
05EA:  BSF    03.5
05EB:  MOVWF  4D
05EC:  BCF    03.5
05ED:  CALL   0C2
....................     //initialize RFID Reader 
....................     MFRC_begin(); 
05EE:  GOTO   375
....................      
....................     //check if the card reader is connected. 
....................     CheckRFIDHardware(); 
05EF:  GOTO   3E6
....................      
....................     ///// 
....................       
....................      
....................      
....................     while(TRUE){ 
....................          
....................         if(intrb){ 
05F0:  BTFSS  32.0
05F1:  GOTO   604
....................             printf("abc"); 
05F2:  MOVLW  61
05F3:  BTFSS  0C.4
05F4:  GOTO   5F3
05F5:  MOVWF  19
05F6:  MOVLW  62
05F7:  BTFSS  0C.4
05F8:  GOTO   5F7
05F9:  MOVWF  19
05FA:  MOVLW  63
05FB:  BTFSS  0C.4
05FC:  GOTO   5FB
05FD:  MOVWF  19
....................             delay_ms(20); 
05FE:  MOVLW  14
05FF:  BSF    03.5
0600:  MOVWF  4D
0601:  BCF    03.5
0602:  CALL   0C2
....................             intrb=FALSE; 
0603:  BCF    32.0
....................         } 
0604:  GOTO   5F0
....................          
....................         
.................... //         
.................... //      //  Check to see if a Tag was detected 
.................... //     // If yes, then the variable FoundTag will contain "MI_OK" 
.................... //    FoundTag = requestTag(MF1_REQIDL, TagData); 
.................... //     
.................... //    if(FoundTag == MI_OK){       
.................... //        printf("\r\nFound Tag: "); 
.................... //         
.................... //        ReadTag = antiCollision(TagData); 
.................... //         
.................... //        if(ReadTag == MI_OK){ 
.................... //             
.................... //            for(i=0;i<=2;i++) 
.................... //            { 
.................... //             sprintf(buffer2,"%2X",(TagData[i])); //display version in hexadecimal 
.................... //             delay_ms(20); 
.................... //             printf(buffer2); 
.................... //             printf(", "); 
.................... //            } 
.................... //         sprintf(buffer2,"%2X",(TagData[i])); //display version in hexadecimal 
.................... //         delay_ms(20); 
.................... //         printf(buffer2); 
.................... //          
.................... //        } 
.................... //     
.................... //        delay_ms(2000); 
.................... //        }    
.................... //     
....................     } 
....................      
....................     return; 
.................... } 
....................  
0605:  GOTO   605

Configuration Fuses:
   Word  1: 3739   XT NOWDT NOPUT NOBROWNOUT NOLVP NOCPD NOWRT DEBUG NOPROTECT

   Some fuses have been forced to be compatible with the ICD debugger.
