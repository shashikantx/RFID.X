CCS PCM C Compiler, Version 5.078, 43599               03-Jul-18 16:34

               Filename:   C:\Users\Shashikant\Documents\GitHub\RFID.X\build\default\production\main.lst

               ROM used:   1917 words (23%)
                           Largest free fragment is 2048
               RAM used:   100 (27%) at main() level
                           126 (34%) worst case
               Stack used: 5 locations
               Stack size: 8

*
0000:  MOVLW  06
0001:  MOVWF  0A
0002:  GOTO   6CC
0003:  NOP
.................... /*  
....................  * File:   main.c 
....................  * Author: Shashikant 
....................  * 
....................  * Created on 2 July, 2018, 12:43 PM 
....................  */ 
....................  
.................... //Options 
.................... #include <16F877A.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
0004:  DATA 0C,10
0005:  DATA 43,34
0006:  DATA E5,31
0007:  DATA EB,34
0008:  DATA EE,33
0009:  DATA 20,29
000A:  DATA C6,24
000B:  DATA 44,17
000C:  DATA 2E,17
000D:  DATA 00,00
000E:  DATA 0C,10
000F:  DATA 52,23
0010:  DATA 49,22
0011:  DATA 20,27
0012:  DATA 6F,3A
0013:  DATA 20,23
0014:  DATA EF,3A
0015:  DATA 6E,32
0016:  DATA 20,05
0017:  DATA A0,21
0018:  DATA E8,32
0019:  DATA E3,35
001A:  DATA A0,20
001B:  DATA E7,30
001C:  DATA 69,37
001D:  DATA 2E,17
001E:  DATA 00,01
001F:  DATA 0C,10
0020:  DATA 52,23
0021:  DATA 49,22
0022:  DATA 20,23
0023:  DATA EF,3A
0024:  DATA 6E,32
0025:  DATA 00,01
0026:  DATA 0A,2B
0027:  DATA 3A,10
0028:  DATA 25,3C
0029:  DATA 00,00
002A:  DATA 0C,24
002B:  DATA 6F,36
002C:  DATA 64,10
002D:  DATA D4,30
002E:  DATA 67,10
002F:  DATA 53,3A
0030:  DATA 69,36
0031:  DATA 6C,00
0032:  DATA 0C,00
0033:  DATA C4,30
0034:  DATA F4,30
0035:  DATA 3A,10
0036:  DATA 00,01
0037:  DATA 0C,10
0038:  DATA 53,3A
0039:  DATA 61,39
003A:  DATA F4,34
003B:  DATA EE,33
003C:  DATA 2E,17
003D:  DATA 2E,00
003E:  DATA 73,3A
003F:  DATA 61,39
0040:  DATA F4,34
0041:  DATA EE,33
0042:  DATA 2E,17
0043:  DATA 00,00
0044:  DATA 8C,21
0045:  DATA E8,32
0046:  DATA E3,35
0047:  DATA 69,37
0048:  DATA 67,10
0049:  DATA E6,37
004A:  DATA 72,10
004B:  DATA D4,30
004C:  DATA 67,10
004D:  DATA 0D,05
004E:  DATA 00,01
004F:  DATA 0D,05
0050:  DATA A0,21
0051:  DATA E8,32
0052:  DATA E3,35
0053:  DATA 20,23
0054:  DATA 6F,39
0055:  DATA 20,2A
0056:  DATA E1,33
0057:  DATA 00,01
0058:  DATA 0C,10
0059:  DATA D4,30
005A:  DATA 67,10
005B:  DATA C6,37
005C:  DATA 75,37
005D:  DATA 64,00
005E:  DATA 0C,10
005F:  DATA D4,30
0060:  DATA 67,10
0061:  DATA CE,37
0062:  DATA 74,10
0063:  DATA C6,37
0064:  DATA 75,37
0065:  DATA 64,00
*
01E7:  MOVF   0B,W
01E8:  BSF    03.5
01E9:  MOVWF  34
01EA:  BCF    03.5
01EB:  BCF    0B.7
01EC:  BSF    03.5
01ED:  BSF    03.6
01EE:  BSF    0C.7
01EF:  BSF    0C.0
01F0:  NOP
01F1:  NOP
01F2:  BCF    03.6
01F3:  BTFSS  34.7
01F4:  GOTO   1F8
01F5:  BCF    03.5
01F6:  BSF    0B.7
01F7:  BSF    03.5
01F8:  BCF    03.5
01F9:  BSF    03.6
01FA:  MOVF   0C,W
01FB:  ANDLW  7F
01FC:  BTFSC  03.2
01FD:  GOTO   259
01FE:  BSF    03.5
01FF:  BCF    03.6
0200:  MOVWF  34
0201:  BCF    03.5
0202:  BSF    03.6
0203:  MOVF   0D,W
0204:  BSF    03.5
0205:  BCF    03.6
0206:  MOVWF  35
0207:  BCF    03.5
0208:  BSF    03.6
0209:  MOVF   0F,W
020A:  BSF    03.5
020B:  BCF    03.6
020C:  MOVWF  36
020D:  MOVF   34,W
020E:  MOVWF  38
020F:  BCF    03.5
0210:  CALL   1AD
0211:  BSF    03.5
0212:  MOVF   35,W
0213:  BCF    03.5
0214:  BSF    03.6
0215:  MOVWF  0D
0216:  BSF    03.5
0217:  BCF    03.6
0218:  MOVF   36,W
0219:  BCF    03.5
021A:  BSF    03.6
021B:  MOVWF  0F
021C:  BCF    03.6
021D:  MOVF   0B,W
021E:  BSF    03.5
021F:  MOVWF  37
0220:  BCF    03.5
0221:  BCF    0B.7
0222:  BSF    03.5
0223:  BSF    03.6
0224:  BSF    0C.7
0225:  BSF    0C.0
0226:  NOP
0227:  NOP
0228:  BCF    03.6
0229:  BTFSS  37.7
022A:  GOTO   22E
022B:  BCF    03.5
022C:  BSF    0B.7
022D:  BSF    03.5
022E:  BCF    03.5
022F:  BSF    03.6
0230:  RLF    0C,W
0231:  RLF    0E,W
0232:  ANDLW  7F
0233:  BTFSC  03.2
0234:  GOTO   259
0235:  BSF    03.5
0236:  BCF    03.6
0237:  MOVWF  34
0238:  BCF    03.5
0239:  BSF    03.6
023A:  MOVF   0D,W
023B:  BSF    03.5
023C:  BCF    03.6
023D:  MOVWF  35
023E:  BCF    03.5
023F:  BSF    03.6
0240:  MOVF   0F,W
0241:  BSF    03.5
0242:  BCF    03.6
0243:  MOVWF  36
0244:  MOVF   34,W
0245:  MOVWF  38
0246:  BCF    03.5
0247:  CALL   1AD
0248:  BSF    03.5
0249:  MOVF   35,W
024A:  BCF    03.5
024B:  BSF    03.6
024C:  MOVWF  0D
024D:  BSF    03.5
024E:  BCF    03.6
024F:  MOVF   36,W
0250:  BCF    03.5
0251:  BSF    03.6
0252:  MOVWF  0F
0253:  INCF   0D,F
0254:  BTFSC  03.2
0255:  INCF   0F,F
0256:  BCF    03.6
0257:  GOTO   1E7
0258:  BSF    03.6
0259:  BCF    03.6
025A:  RETURN
025B:  MOVF   0B,W
025C:  BSF    03.5
025D:  MOVWF  34
025E:  BCF    03.5
025F:  BCF    0B.7
0260:  BSF    03.5
0261:  BSF    03.6
0262:  BSF    0C.7
0263:  BSF    0C.0
0264:  NOP
0265:  NOP
0266:  BCF    03.6
0267:  BTFSS  34.7
0268:  GOTO   26C
0269:  BCF    03.5
026A:  BSF    0B.7
026B:  BSF    03.5
026C:  BCF    03.5
026D:  BSF    03.6
026E:  MOVF   0C,W
026F:  ANDLW  7F
0270:  BTFSC  03.2
0271:  GOTO   2CF
0272:  BSF    03.5
0273:  BCF    03.6
0274:  MOVWF  34
0275:  BCF    03.5
0276:  BSF    03.6
0277:  MOVF   0D,W
0278:  BSF    03.5
0279:  BCF    03.6
027A:  MOVWF  35
027B:  BCF    03.5
027C:  BSF    03.6
027D:  MOVF   0F,W
027E:  BSF    03.5
027F:  BCF    03.6
0280:  MOVWF  36
0281:  MOVF   34,W
0282:  BCF    03.5
0283:  BTFSS  0C.4
0284:  GOTO   283
0285:  MOVWF  19
0286:  BSF    03.5
0287:  MOVF   35,W
0288:  BCF    03.5
0289:  BSF    03.6
028A:  MOVWF  0D
028B:  BSF    03.5
028C:  BCF    03.6
028D:  MOVF   36,W
028E:  BCF    03.5
028F:  BSF    03.6
0290:  MOVWF  0F
0291:  BCF    03.6
0292:  MOVF   0B,W
0293:  BSF    03.5
0294:  MOVWF  37
0295:  BCF    03.5
0296:  BCF    0B.7
0297:  BSF    03.5
0298:  BSF    03.6
0299:  BSF    0C.7
029A:  BSF    0C.0
029B:  NOP
029C:  NOP
029D:  BCF    03.6
029E:  BTFSS  37.7
029F:  GOTO   2A3
02A0:  BCF    03.5
02A1:  BSF    0B.7
02A2:  BSF    03.5
02A3:  BCF    03.5
02A4:  BSF    03.6
02A5:  RLF    0C,W
02A6:  RLF    0E,W
02A7:  ANDLW  7F
02A8:  BTFSC  03.2
02A9:  GOTO   2CF
02AA:  BSF    03.5
02AB:  BCF    03.6
02AC:  MOVWF  34
02AD:  BCF    03.5
02AE:  BSF    03.6
02AF:  MOVF   0D,W
02B0:  BSF    03.5
02B1:  BCF    03.6
02B2:  MOVWF  35
02B3:  BCF    03.5
02B4:  BSF    03.6
02B5:  MOVF   0F,W
02B6:  BSF    03.5
02B7:  BCF    03.6
02B8:  MOVWF  36
02B9:  MOVF   34,W
02BA:  BCF    03.5
02BB:  BTFSS  0C.4
02BC:  GOTO   2BB
02BD:  MOVWF  19
02BE:  BSF    03.5
02BF:  MOVF   35,W
02C0:  BCF    03.5
02C1:  BSF    03.6
02C2:  MOVWF  0D
02C3:  BSF    03.5
02C4:  BCF    03.6
02C5:  MOVF   36,W
02C6:  BCF    03.5
02C7:  BSF    03.6
02C8:  MOVWF  0F
02C9:  INCF   0D,F
02CA:  BTFSC  03.2
02CB:  INCF   0F,F
02CC:  BCF    03.6
02CD:  GOTO   25B
02CE:  BSF    03.6
02CF:  BCF    03.6
02D0:  RETURN
*
03CE:  BCF    03.5
03CF:  MOVF   0B,W
03D0:  BSF    03.5
03D1:  MOVWF  35
03D2:  BCF    03.5
03D3:  BCF    0B.7
03D4:  BSF    03.5
03D5:  BSF    03.6
03D6:  BSF    0C.7
03D7:  BSF    0C.0
03D8:  NOP
03D9:  NOP
03DA:  BCF    03.6
03DB:  BTFSS  35.7
03DC:  GOTO   3E0
03DD:  BCF    03.5
03DE:  BSF    0B.7
03DF:  BSF    03.5
03E0:  BTFSC  03.0
03E1:  GOTO   419
03E2:  BCF    03.5
03E3:  BSF    03.6
03E4:  MOVF   0C,W
03E5:  ANDLW  7F
03E6:  BSF    03.5
03E7:  BCF    03.6
03E8:  MOVWF  35
03E9:  BCF    03.5
03EA:  BSF    03.6
03EB:  MOVF   0D,W
03EC:  BSF    03.5
03ED:  BCF    03.6
03EE:  MOVWF  36
03EF:  BCF    03.5
03F0:  BSF    03.6
03F1:  MOVF   0F,W
03F2:  BSF    03.5
03F3:  BCF    03.6
03F4:  MOVWF  37
03F5:  MOVF   35,W
03F6:  MOVWF  38
03F7:  BCF    03.5
03F8:  CALL   1AD
03F9:  BSF    03.5
03FA:  MOVF   36,W
03FB:  BCF    03.5
03FC:  BSF    03.6
03FD:  MOVWF  0D
03FE:  BSF    03.5
03FF:  BCF    03.6
0400:  MOVF   37,W
0401:  BCF    03.5
0402:  BSF    03.6
0403:  MOVWF  0F
0404:  BCF    03.6
0405:  MOVF   0B,W
0406:  BSF    03.5
0407:  MOVWF  38
0408:  BCF    03.5
0409:  BCF    0B.7
040A:  BSF    03.5
040B:  BSF    03.6
040C:  BSF    0C.7
040D:  BSF    0C.0
040E:  NOP
040F:  NOP
0410:  BCF    03.6
0411:  BTFSS  38.7
0412:  GOTO   416
0413:  BCF    03.5
0414:  BSF    0B.7
0415:  BSF    03.5
0416:  DECFSZ 34,F
0417:  GOTO   419
0418:  GOTO   444
0419:  BCF    03.5
041A:  BSF    03.6
041B:  RLF    0C,W
041C:  RLF    0E,W
041D:  ANDLW  7F
041E:  BSF    03.5
041F:  BCF    03.6
0420:  MOVWF  35
0421:  BCF    03.5
0422:  BSF    03.6
0423:  MOVF   0D,W
0424:  BSF    03.5
0425:  BCF    03.6
0426:  MOVWF  36
0427:  BCF    03.5
0428:  BSF    03.6
0429:  MOVF   0F,W
042A:  BSF    03.5
042B:  BCF    03.6
042C:  MOVWF  37
042D:  MOVF   35,W
042E:  MOVWF  38
042F:  BCF    03.5
0430:  CALL   1AD
0431:  BSF    03.5
0432:  MOVF   36,W
0433:  BCF    03.5
0434:  BSF    03.6
0435:  MOVWF  0D
0436:  BSF    03.5
0437:  BCF    03.6
0438:  MOVF   37,W
0439:  BCF    03.5
043A:  BSF    03.6
043B:  MOVWF  0F
043C:  INCF   0D,F
043D:  BTFSC  03.2
043E:  INCF   0F,F
043F:  BCF    03.0
0440:  BSF    03.5
0441:  BCF    03.6
0442:  DECFSZ 34,F
0443:  GOTO   3CE
*
044A:  BTFSC  35.7
044B:  GOTO   45E
044C:  MOVLW  0F
044D:  MOVWF  77
044E:  SWAPF  34,W
044F:  ANDWF  77,F
0450:  MOVLW  0A
0451:  SUBWF  77,W
0452:  BTFSC  03.0
0453:  GOTO   457
0454:  MOVLW  30
0455:  ADDWF  77,F
0456:  GOTO   459
0457:  MOVF   35,W
0458:  ADDWF  77,F
0459:  MOVF   77,W
045A:  MOVWF  38
045B:  BCF    03.5
045C:  CALL   1AD
045D:  BSF    03.5
045E:  MOVLW  0F
045F:  ANDWF  34,F
0460:  MOVLW  0A
0461:  SUBWF  34,W
0462:  BTFSC  03.0
0463:  GOTO   466
0464:  MOVLW  30
0465:  GOTO   468
0466:  BCF    35.7
0467:  MOVF   35,W
0468:  ADDWF  34,F
0469:  MOVF   34,W
046A:  MOVWF  38
046B:  BCF    03.5
046C:  CALL   1AD
*
05BB:  MOVF   67,W
05BC:  MOVWF  04
05BD:  BCF    03.7
05BE:  BTFSC  68.0
05BF:  BSF    03.7
05C0:  BSF    03.5
05C1:  MOVF   37,W
05C2:  MOVWF  00
05C3:  INCF   04,F
05C4:  CLRF   00
05C5:  BCF    03.5
05C6:  INCF   67,F
05C7:  BTFSC  03.2
05C8:  INCF   68,F
05C9:  RETURN
05CA:  BSF    03.5
05CB:  BTFSC  36.7
05CC:  GOTO   5DF
05CD:  MOVLW  0F
05CE:  MOVWF  77
05CF:  SWAPF  35,W
05D0:  ANDWF  77,F
05D1:  MOVLW  0A
05D2:  SUBWF  77,W
05D3:  BTFSC  03.0
05D4:  GOTO   5D8
05D5:  MOVLW  30
05D6:  ADDWF  77,F
05D7:  GOTO   5DA
05D8:  MOVF   36,W
05D9:  ADDWF  77,F
05DA:  MOVF   77,W
05DB:  MOVWF  37
05DC:  BCF    03.5
05DD:  CALL   5BB
05DE:  BSF    03.5
05DF:  MOVLW  0F
05E0:  ANDWF  35,F
05E1:  MOVLW  0A
05E2:  SUBWF  35,W
05E3:  BTFSC  03.0
05E4:  GOTO   5E7
05E5:  MOVLW  30
05E6:  GOTO   5E9
05E7:  BCF    36.7
05E8:  MOVF   36,W
05E9:  ADDWF  35,F
05EA:  MOVF   35,W
05EB:  MOVWF  37
05EC:  BCF    03.5
05ED:  CALL   5BB
05EE:  RETURN
05EF:  MOVF   00,F
05F0:  BTFSC  03.2
05F1:  GOTO   60B
05F2:  BSF    03.5
05F3:  CLRF   35
05F4:  MOVF   04,W
05F5:  MOVWF  34
05F6:  BCF    35.0
05F7:  BTFSC  03.7
05F8:  BSF    35.0
05F9:  MOVF   00,W
05FA:  MOVWF  38
05FB:  BCF    03.5
05FC:  CALL   1AD
05FD:  BSF    03.5
05FE:  MOVF   34,W
05FF:  MOVWF  04
0600:  BCF    03.7
0601:  BTFSC  35.0
0602:  BSF    03.7
0603:  INCF   04,F
0604:  BTFSS  03.2
0605:  GOTO   609
0606:  BCF    03.5
0607:  INCF   05,F
0608:  BSF    03.5
0609:  BCF    03.5
060A:  GOTO   5EF
060B:  RETURN
....................  
.................... #list 
....................  
.................... //#include<18F45K22.h> 
.................... #fuses NOPROTECT,NOLVP 
.................... #use delay(crystal=4000000) 
*
0066:  MOVLW  C8
0067:  MOVWF  04
0068:  BCF    03.7
0069:  MOVF   00,W
006A:  BTFSC  03.2
006B:  GOTO   07A
006C:  MOVLW  01
006D:  MOVWF  78
006E:  CLRF   77
006F:  DECFSZ 77,F
0070:  GOTO   06F
0071:  DECFSZ 78,F
0072:  GOTO   06E
0073:  MOVLW  4A
0074:  MOVWF  77
0075:  DECFSZ 77,F
0076:  GOTO   075
0077:  GOTO   078
0078:  DECFSZ 00,F
0079:  GOTO   06C
007A:  RETURN
.................... #use rs232( baud=9600, xmit=PIN_C6, rcv=PIN_C7, bits=8) 
....................  
.................... //LCD module connections 
.................... #define LCD_RS_PIN PIN_D0 
.................... #define LCD_RW_PIN PIN_D1 
.................... #define LCD_ENABLE_PIN PIN_D2 
.................... #define LCD_DATA4 PIN_D4 
.................... #define LCD_DATA5 PIN_D5 
.................... #define LCD_DATA6 PIN_D6 
.................... #define LCD_DATA7 PIN_D7 
.................... //End LCD module connections 
....................  
.................... #define CS PIN_A5 
....................  
....................  
....................  
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
00EB:  BSF    08.4
....................    output_float(LCD_DATA5); 
00EC:  BSF    08.5
....................    output_float(LCD_DATA6); 
00ED:  BSF    08.6
....................    output_float(LCD_DATA7); 
00EE:  BSF    08.7
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
00EF:  BCF    03.5
00F0:  BSF    08.1
00F1:  BSF    03.5
00F2:  BCF    08.1
....................    delay_cycles(1); 
00F3:  NOP
....................    lcd_output_enable(1); 
00F4:  BCF    03.5
00F5:  BSF    08.2
00F6:  BSF    03.5
00F7:  BCF    08.2
....................    delay_cycles(1); 
00F8:  NOP
....................    high = lcd_read_nibble(); 
00F9:  BCF    03.5
00FA:  CALL   0B0
00FB:  MOVF   78,W
00FC:  BSF    03.5
00FD:  MOVWF  40
....................        
....................    lcd_output_enable(0); 
00FE:  BCF    03.5
00FF:  BCF    08.2
0100:  BSF    03.5
0101:  BCF    08.2
....................    delay_cycles(1); 
0102:  NOP
....................    lcd_output_enable(1); 
0103:  BCF    03.5
0104:  BSF    08.2
0105:  BSF    03.5
0106:  BCF    08.2
....................    delay_us(1); 
0107:  NOP
....................    low = lcd_read_nibble(); 
0108:  BCF    03.5
0109:  CALL   0B0
010A:  MOVF   78,W
010B:  BSF    03.5
010C:  MOVWF  3F
....................        
....................    lcd_output_enable(0); 
010D:  BCF    03.5
010E:  BCF    08.2
010F:  BSF    03.5
0110:  BCF    08.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0111:  BCF    08.4
....................    output_drive(LCD_DATA5); 
0112:  BCF    08.5
....................    output_drive(LCD_DATA6); 
0113:  BCF    08.6
....................    output_drive(LCD_DATA7); 
0114:  BCF    08.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0115:  SWAPF  40,W
0116:  MOVWF  77
0117:  MOVLW  F0
0118:  ANDWF  77,F
0119:  MOVF   77,W
011A:  IORWF  3F,W
011B:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
00B0:  BSF    03.5
00B1:  CLRF   41
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
00B2:  BSF    08.4
00B3:  MOVLW  00
00B4:  BCF    03.5
00B5:  BTFSC  08.4
00B6:  MOVLW  01
00B7:  BSF    03.5
00B8:  IORWF  41,F
....................    n |= input(LCD_DATA5) << 1; 
00B9:  BSF    08.5
00BA:  MOVLW  00
00BB:  BCF    03.5
00BC:  BTFSC  08.5
00BD:  MOVLW  01
00BE:  MOVWF  77
00BF:  BCF    03.0
00C0:  RLF    77,F
00C1:  MOVF   77,W
00C2:  BSF    03.5
00C3:  IORWF  41,F
....................    n |= input(LCD_DATA6) << 2; 
00C4:  BSF    08.6
00C5:  MOVLW  00
00C6:  BCF    03.5
00C7:  BTFSC  08.6
00C8:  MOVLW  01
00C9:  MOVWF  77
00CA:  RLF    77,F
00CB:  RLF    77,F
00CC:  MOVLW  FC
00CD:  ANDWF  77,F
00CE:  MOVF   77,W
00CF:  BSF    03.5
00D0:  IORWF  41,F
....................    n |= input(LCD_DATA7) << 3; 
00D1:  BSF    08.7
00D2:  MOVLW  00
00D3:  BCF    03.5
00D4:  BTFSC  08.7
00D5:  MOVLW  01
00D6:  MOVWF  77
00D7:  RLF    77,F
00D8:  RLF    77,F
00D9:  RLF    77,F
00DA:  MOVLW  F8
00DB:  ANDWF  77,F
00DC:  MOVF   77,W
00DD:  BSF    03.5
00DE:  IORWF  41,F
....................     
....................    return(n); 
00DF:  MOVF   41,W
00E0:  MOVWF  78
....................   #else 
00E1:  BCF    03.5
00E2:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
007B:  BSF    03.5
007C:  BTFSC  40.0
007D:  GOTO   082
007E:  BCF    03.5
007F:  BCF    08.4
0080:  GOTO   084
0081:  BSF    03.5
0082:  BCF    03.5
0083:  BSF    08.4
0084:  BSF    03.5
0085:  BCF    08.4
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
0086:  BTFSC  40.1
0087:  GOTO   08C
0088:  BCF    03.5
0089:  BCF    08.5
008A:  GOTO   08E
008B:  BSF    03.5
008C:  BCF    03.5
008D:  BSF    08.5
008E:  BSF    03.5
008F:  BCF    08.5
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
0090:  BTFSC  40.2
0091:  GOTO   096
0092:  BCF    03.5
0093:  BCF    08.6
0094:  GOTO   098
0095:  BSF    03.5
0096:  BCF    03.5
0097:  BSF    08.6
0098:  BSF    03.5
0099:  BCF    08.6
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
009A:  BTFSC  40.3
009B:  GOTO   0A0
009C:  BCF    03.5
009D:  BCF    08.7
009E:  GOTO   0A2
009F:  BSF    03.5
00A0:  BCF    03.5
00A1:  BSF    08.7
00A2:  BSF    03.5
00A3:  BCF    08.7
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
00A4:  NOP
....................    lcd_output_enable(1); 
00A5:  BCF    03.5
00A6:  BSF    08.2
00A7:  BSF    03.5
00A8:  BCF    08.2
....................    delay_us(2); 
00A9:  GOTO   0AA
....................    lcd_output_enable(0); 
00AA:  BCF    03.5
00AB:  BCF    08.2
00AC:  BSF    03.5
00AD:  BCF    08.2
00AE:  BCF    03.5
00AF:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
00E3:  BSF    03.5
00E4:  BCF    08.2
....................    lcd_rs_tris(); 
00E5:  BCF    08.0
....................    lcd_rw_tris(); 
00E6:  BCF    08.1
....................   #endif 
....................  
....................    lcd_output_rs(0); 
00E7:  BCF    03.5
00E8:  BCF    08.0
00E9:  BSF    03.5
00EA:  BCF    08.0
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
011C:  MOVF   78,W
011D:  MOVWF  3F
011E:  BTFSC  3F.7
011F:  GOTO   0EB
....................    lcd_output_rs(address); 
0120:  MOVF   3D,F
0121:  BTFSS  03.2
0122:  GOTO   127
0123:  BCF    03.5
0124:  BCF    08.0
0125:  GOTO   129
0126:  BSF    03.5
0127:  BCF    03.5
0128:  BSF    08.0
0129:  BSF    03.5
012A:  BCF    08.0
....................    delay_cycles(1); 
012B:  NOP
....................    lcd_output_rw(0); 
012C:  BCF    03.5
012D:  BCF    08.1
012E:  BSF    03.5
012F:  BCF    08.1
....................    delay_cycles(1); 
0130:  NOP
....................    lcd_output_enable(0); 
0131:  BCF    03.5
0132:  BCF    08.2
0133:  BSF    03.5
0134:  BCF    08.2
....................    lcd_send_nibble(n >> 4); 
0135:  SWAPF  3E,W
0136:  MOVWF  3F
0137:  MOVLW  0F
0138:  ANDWF  3F,F
0139:  MOVF   3F,W
013A:  MOVWF  40
013B:  BCF    03.5
013C:  CALL   07B
....................    lcd_send_nibble(n & 0xf); 
013D:  BSF    03.5
013E:  MOVF   3E,W
013F:  ANDLW  0F
0140:  MOVWF  3F
0141:  MOVWF  40
0142:  BCF    03.5
0143:  CALL   07B
0144:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
0145:  MOVLW  28
0146:  BSF    03.5
0147:  MOVWF  35
0148:  MOVLW  0C
0149:  MOVWF  36
014A:  MOVLW  01
014B:  MOVWF  37
014C:  MOVLW  06
014D:  MOVWF  38
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
014E:  BCF    03.5
014F:  BCF    08.2
0150:  BSF    03.5
0151:  BCF    08.2
....................    lcd_output_rs(0); 
0152:  BCF    03.5
0153:  BCF    08.0
0154:  BSF    03.5
0155:  BCF    08.0
....................    lcd_output_rw(0); 
0156:  BCF    03.5
0157:  BCF    08.1
0158:  BSF    03.5
0159:  BCF    08.1
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
015A:  BCF    08.4
....................    output_drive(LCD_DATA5); 
015B:  BCF    08.5
....................    output_drive(LCD_DATA6); 
015C:  BCF    08.6
....................    output_drive(LCD_DATA7); 
015D:  BCF    08.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
015E:  BCF    08.2
....................    lcd_rs_tris(); 
015F:  BCF    08.0
....................    lcd_rw_tris(); 
0160:  BCF    08.1
....................  #endif 
....................      
....................    delay_ms(15); 
0161:  MOVLW  0F
0162:  MOVWF  48
0163:  BCF    03.5
0164:  CALL   066
....................    for(i=1;i<=3;++i) 
0165:  MOVLW  01
0166:  BSF    03.5
0167:  MOVWF  34
0168:  MOVF   34,W
0169:  SUBLW  03
016A:  BTFSS  03.0
016B:  GOTO   178
....................    { 
....................        lcd_send_nibble(3); 
016C:  MOVLW  03
016D:  MOVWF  40
016E:  BCF    03.5
016F:  CALL   07B
....................        delay_ms(5); 
0170:  MOVLW  05
0171:  BSF    03.5
0172:  MOVWF  48
0173:  BCF    03.5
0174:  CALL   066
0175:  BSF    03.5
0176:  INCF   34,F
0177:  GOTO   168
....................    } 
....................     
....................    lcd_send_nibble(2); 
0178:  MOVLW  02
0179:  MOVWF  40
017A:  BCF    03.5
017B:  CALL   07B
....................    delay_ms(5); 
017C:  MOVLW  05
017D:  BSF    03.5
017E:  MOVWF  48
017F:  BCF    03.5
0180:  CALL   066
....................    for(i=0;i<=3;++i) 
0181:  BSF    03.5
0182:  CLRF   34
0183:  MOVF   34,W
0184:  SUBLW  03
0185:  BTFSS  03.0
0186:  GOTO   195
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
0187:  MOVLW  B5
0188:  ADDWF  34,W
0189:  MOVWF  04
018A:  BCF    03.7
018B:  MOVF   00,W
018C:  MOVWF  39
018D:  CLRF   3D
018E:  MOVF   39,W
018F:  MOVWF  3E
0190:  BCF    03.5
0191:  CALL   0E3
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0192:  BSF    03.5
0193:  INCF   34,F
0194:  GOTO   183
0195:  BCF    03.5
0196:  BCF    0A.3
0197:  BCF    0A.4
0198:  GOTO   707 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
0199:  BSF    03.5
019A:  DECFSZ 3A,W
019B:  GOTO   19D
019C:  GOTO   1A0
....................       address=LCD_LINE_TWO; 
019D:  MOVLW  40
019E:  MOVWF  3B
019F:  GOTO   1A1
....................    else 
....................       address=0; 
01A0:  CLRF   3B
....................       
....................    address+=x-1; 
01A1:  MOVLW  01
01A2:  SUBWF  39,W
01A3:  ADDWF  3B,F
....................    lcd_send_byte(0,0x80|address); 
01A4:  MOVF   3B,W
01A5:  IORLW  80
01A6:  MOVWF  3C
01A7:  CLRF   3D
01A8:  MOVF   3C,W
01A9:  MOVWF  3E
01AA:  BCF    03.5
01AB:  CALL   0E3
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
01AC:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
01AD:  BSF    03.5
01AE:  MOVF   38,W
01AF:  XORLW  07
01B0:  BCF    03.5
01B1:  BTFSC  03.2
01B2:  GOTO   1BD
01B3:  XORLW  0B
01B4:  BTFSC  03.2
01B5:  GOTO   1C4
01B6:  XORLW  06
01B7:  BTFSC  03.2
01B8:  GOTO   1D0
01B9:  XORLW  02
01BA:  BTFSC  03.2
01BB:  GOTO   1D8
01BC:  GOTO   1DF
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
01BD:  MOVLW  01
01BE:  BSF    03.5
01BF:  MOVWF  39
01C0:  MOVWF  3A
01C1:  BCF    03.5
01C2:  CALL   199
01C3:  GOTO   1E6
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
01C4:  BSF    03.5
01C5:  CLRF   3D
01C6:  MOVLW  01
01C7:  MOVWF  3E
01C8:  BCF    03.5
01C9:  CALL   0E3
....................                      delay_ms(2); 
01CA:  MOVLW  02
01CB:  BSF    03.5
01CC:  MOVWF  48
01CD:  BCF    03.5
01CE:  CALL   066
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
01CF:  GOTO   1E6
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
01D0:  MOVLW  01
01D1:  BSF    03.5
01D2:  MOVWF  39
01D3:  MOVLW  02
01D4:  MOVWF  3A
01D5:  BCF    03.5
01D6:  CALL   199
01D7:  GOTO   1E6
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
01D8:  BSF    03.5
01D9:  CLRF   3D
01DA:  MOVLW  10
01DB:  MOVWF  3E
01DC:  BCF    03.5
01DD:  CALL   0E3
01DE:  GOTO   1E6
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
01DF:  MOVLW  01
01E0:  BSF    03.5
01E1:  MOVWF  3D
01E2:  MOVF   38,W
01E3:  MOVWF  3E
01E4:  BCF    03.5
01E5:  CALL   0E3
....................      #endif 
....................    } 
01E6:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
06E5:  BCF    03.5
06E6:  CLRF   20
06E7:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... //spi modes 
.................... #define SPI_MODE_0  (SPI_L_TO_H | SPI_XMIT_L_TO_H) 
.................... #define SPI_MODE_1  (SPI_L_TO_H) 
.................... #define SPI_MODE_2  (SPI_H_TO_L) 
.................... #define SPI_MODE_3  (SPI_H_TO_L | SPI_XMIT_L_TO_H) 
....................  
.................... #include "rfid.h" 
.................... /*  
....................  * File:   rfid.h 
....................  * Author: Shashikant 
....................  * 
....................  * Created on 2 July, 2018, 1:34 PM 
....................  */ 
....................  
.................... #ifndef RFID_H 
.................... #define	RFID_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................  
....................  
....................  
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* RFID_H */ 
....................  
.................... #define     MAX_LEN               16        // Maximum length of an array. CHECK IF IT IS MAXIMUM LENGTH/SIZE OF FIFO!!!!!!!!!!! 
....................  
.................... //MF522 MFRC522 error codes. 
.................... #define     MI_OK                 0         // Everything A-OK. 
.................... #define     MI_NOTAGERR           1         // No tag error 
.................... #define     MI_ERR                2         // General error 
....................  
.................... //MF522 Command word 
.................... #define     MFRC522_IDLE          0x00      // NO action; Cancel the current command 
.................... #define     MFRC522_MEM           0x01      // Store 25 byte into the internal buffer. 
.................... #define     MFRC522_GENID         0x02      // Generates a 10 byte random ID number. 
.................... #define     MFRC522_CALCCRC       0x03      // CRC Calculate or selftest. 
.................... #define     MFRC522_TRANSMIT      0x04      // Transmit data 
.................... #define     MFRC522_NOCMDCH       0x07      // No command change. 
.................... #define     MFRC522_RECEIVE       0x08      // Receive Data 
.................... #define     MFRC522_TRANSCEIVE    0x0C      // Transmit and receive data, 
.................... #define     MFRC522_AUTHENT       0x0E      // Authentication Key 
.................... #define     MFRC522_SOFTRESET     0x0F      // Reset 
....................  
.................... //Mifare_One tag command word 
.................... #define     MF1_REQIDL            0x26      // find the antenna area does not enter hibernation 
.................... #define     MF1_REQALL            0x52      // find all the tags antenna area 
.................... #define     MF1_ANTICOLL          0x93      // anti-collision 
.................... #define     MF1_SELECTTAG         0x93      // election tag 
.................... #define     MF1_AUTHENT1A         0x60      // authentication key A 
.................... #define     MF1_AUTHENT1B         0x61      // authentication key B 
.................... #define     MF1_READ              0x30      // Read Block 
.................... #define     MF1_WRITE             0xA0      // write block 
.................... #define     MF1_DECREMENT         0xC0      // debit 
.................... #define     MF1_INCREMENT         0xC1      // recharge 
.................... #define     MF1_RESTORE           0xC2      // transfer block data to the buffer 
.................... #define     MF1_TRANSFER          0xB0      // save the data in the buffer 
.................... #define     MF1_HALT              0x50      // Sleep 
....................  
....................  
.................... //------------------ MFRC522 registers--------------- 
.................... //Page 0:Command and Status 
.................... #define     Reserved00            0x00 
.................... #define     CommandReg            0x01 
.................... #define     CommIEnReg            0x02 
.................... #define     DivIEnReg             0x03 
.................... #define     CommIrqReg            0x04 
.................... #define     DivIrqReg             0x05 
.................... #define     ErrorReg              0x06 
.................... #define     Status1Reg            0x07 
.................... #define     Status2Reg            0x08 
.................... #define     FIFODataReg           0x09 
.................... #define     FIFOLevelReg          0x0A 
.................... #define     WaterLevelReg         0x0B 
.................... #define     ControlReg            0x0C 
.................... #define     BitFramingReg         0x0D 
.................... #define     CollReg               0x0E 
.................... #define     Reserved01            0x0F 
.................... //Page 1:Command 
.................... #define     Reserved10            0x10 
.................... #define     ModeReg               0x11 
.................... #define     TxModeReg             0x12 
.................... #define     RxModeReg             0x13 
.................... #define     TxControlReg          0x14 
.................... #define     TxAutoReg             0x15 
.................... #define     TxSelReg              0x16 
.................... #define     RxSelReg              0x17 
.................... #define     RxThresholdReg        0x18 
.................... #define     DemodReg              0x19 
.................... #define     Reserved11            0x1A 
.................... #define     Reserved12            0x1B 
.................... #define     MifareReg             0x1C 
.................... #define     Reserved13            0x1D 
.................... #define     Reserved14            0x1E 
.................... #define     SerialSpeedReg        0x1F 
.................... //Page 2:CFG 
.................... #define     Reserved20            0x20 
.................... #define     CRCResultRegM         0x21 
.................... #define     CRCResultRegL         0x22 
.................... #define     Reserved21            0x23 
.................... #define     ModWidthReg           0x24 
.................... #define     Reserved22            0x25 
.................... #define     RFCfgReg              0x26 
.................... #define     GsNReg                0x27 
.................... #define     CWGsPReg              0x28 
.................... #define     ModGsPReg             0x29 
.................... #define     TModeReg              0x2A 
.................... #define     TPrescalerReg         0x2B 
.................... #define     TReloadRegH           0x2C 
.................... #define     TReloadRegL           0x2D 
.................... #define     TCounterValueRegH     0x2E 
.................... #define     TCounterValueRegL     0x2F 
.................... //Page 3:TestRegister 
.................... #define     Reserved30            0x30 
.................... #define     TestSel1Reg           0x31 
.................... #define     TestSel2Reg           0x32 
.................... #define     TestPinEnReg          0x33 
.................... #define     TestPinValueReg       0x34 
.................... #define     TestBusReg            0x35 
.................... #define     AutoTestReg           0x36 
.................... #define     VersionReg            0x37 
.................... #define     AnalogTestReg         0x38 
.................... #define     TestDAC1Reg           0x39 
.................... #define     TestDAC2Reg           0x3A 
.................... #define     TestADCReg            0x3B 
.................... #define     Reserved31            0x3C 
.................... #define     Reserved32            0x3D 
.................... #define     Reserved33            0x3E 
.................... #define     Reserved34            0x3F 
.................... //-----------------------------------------------  
....................  
.................... //Reads the value at a register. 
.................... byte readFromRegister(byte addr) { 
....................   byte val; 
....................   output_low(CS); 
*
02F2:  BSF    03.5
02F3:  BCF    05.5
02F4:  BCF    03.5
02F5:  BCF    05.5
....................   spi_write(((addr<<1)&0x7E) | 0x80); 
02F6:  BCF    03.0
02F7:  BSF    03.5
02F8:  RLF    4B,W
02F9:  ANDLW  7E
02FA:  IORLW  80
02FB:  MOVWF  4D
02FC:  BCF    03.5
02FD:  MOVF   13,W
02FE:  BSF    03.5
02FF:  MOVF   4D,W
0300:  BCF    03.5
0301:  MOVWF  13
0302:  BSF    03.5
0303:  RRF    14,W
0304:  BTFSS  03.0
0305:  GOTO   303
....................   val =spi_read(0x00); 
0306:  BCF    03.5
0307:  MOVF   13,W
0308:  CLRF   13
0309:  BSF    03.5
030A:  RRF    14,W
030B:  BTFSS  03.0
030C:  GOTO   30A
030D:  BCF    03.5
030E:  MOVF   13,W
030F:  BSF    03.5
0310:  MOVWF  4C
....................   output_high(CS); 
0311:  BCF    05.5
0312:  BCF    03.5
0313:  BSF    05.5
....................   return val; 
0314:  BSF    03.5
0315:  MOVF   4C,W
0316:  MOVWF  78
0317:  BCF    03.5
0318:  RETURN
.................... } 
....................  
.................... //writes Values to specified registers. 
.................... void writeToRegister(byte addr, byte val) { 
....................   output_low(CS); 
*
02D1:  BSF    03.5
02D2:  BCF    05.5
02D3:  BCF    03.5
02D4:  BCF    05.5
....................   //Address format: 0XXXXXX0 
....................   spi_write((addr<<1)&0x7E); 
02D5:  BCF    03.0
02D6:  BSF    03.5
02D7:  RLF    4C,W
02D8:  ANDLW  7E
02D9:  MOVWF  4E
02DA:  BCF    03.5
02DB:  MOVF   13,W
02DC:  BSF    03.5
02DD:  MOVF   4E,W
02DE:  BCF    03.5
02DF:  MOVWF  13
02E0:  BSF    03.5
02E1:  RRF    14,W
02E2:  BTFSS  03.0
02E3:  GOTO   2E1
....................   spi_write(val); 
02E4:  BCF    03.5
02E5:  MOVF   13,W
02E6:  BSF    03.5
02E7:  MOVF   4D,W
02E8:  BCF    03.5
02E9:  MOVWF  13
02EA:  BSF    03.5
02EB:  RRF    14,W
02EC:  BTFSS  03.0
02ED:  GOTO   2EB
....................   output_high(CS); 
02EE:  BCF    05.5
02EF:  BCF    03.5
02F0:  BSF    05.5
02F1:  RETURN
.................... } 
....................  
.................... //Mask to update registers 
.................... void setBitMask(byte addr, byte mask) { 
....................   byte current; 
....................   current = readFromRegister(addr); 
*
0319:  BSF    03.5
031A:  MOVF   48,W
031B:  MOVWF  4B
031C:  BCF    03.5
031D:  CALL   2F2
031E:  MOVF   78,W
031F:  BSF    03.5
0320:  MOVWF  4A
....................   writeToRegister(addr, current | mask); 
0321:  MOVF   4A,W
0322:  IORWF  49,W
0323:  MOVWF  4B
0324:  MOVF   48,W
0325:  MOVWF  4C
0326:  MOVF   4B,W
0327:  MOVWF  4D
0328:  BCF    03.5
0329:  CALL   2D1
032A:  RETURN
.................... } 
....................  
.................... //remove bitmask  maybe not necessary 
.................... void clearBitMask(byte addr, byte mask) { 
....................   byte current; 
....................   current = readFromRegister(addr); 
*
047B:  BSF    03.5
047C:  MOVF   48,W
047D:  MOVWF  4B
047E:  BCF    03.5
047F:  CALL   2F2
0480:  MOVF   78,W
0481:  BSF    03.5
0482:  MOVWF  4A
....................   writeToRegister(addr, current & (~mask)); 
0483:  MOVF   49,W
0484:  XORLW  FF
0485:  ANDWF  4A,W
0486:  MOVWF  4B
0487:  MOVF   48,W
0488:  MOVWF  4C
0489:  MOVF   4B,W
048A:  MOVWF  4D
048B:  BCF    03.5
048C:  CALL   2D1
048D:  RETURN
.................... } 
....................  
.................... //Initialize RFID Reader 
.................... //Does the setup for the MFRC522. 
.................... void reset() { 
....................   writeToRegister(CommandReg, MFRC522_SOFTRESET); 
*
032F:  MOVLW  01
0330:  BSF    03.5
0331:  MOVWF  4C
0332:  MOVLW  0F
0333:  MOVWF  4D
0334:  BCF    03.5
0335:  CALL   2D1
.................... } 
....................  
....................  
....................  
.................... void MFRC_begin() { 
....................   output_high(CS); 
*
032B:  BSF    03.5
032C:  BCF    05.5
032D:  BCF    03.5
032E:  BSF    05.5
....................   reset(); 
....................   //Timer: TPrescaler*TreloadVal/6.78MHz = 24ms 
....................   writeToRegister(TModeReg, 0x8D);    
*
0336:  MOVLW  2A
0337:  BSF    03.5
0338:  MOVWF  4C
0339:  MOVLW  8D
033A:  MOVWF  4D
033B:  BCF    03.5
033C:  CALL   2D1
....................   delay_ms(20); // Tauto=1; f(Timer) = 6.78MHz/TPreScaler 
033D:  MOVLW  14
033E:  BSF    03.5
033F:  MOVWF  48
0340:  BCF    03.5
0341:  CALL   066
....................   writeToRegister(TPrescalerReg, 0x3E);  // TModeReg[3..0] + TPrescalerReg 
0342:  MOVLW  2B
0343:  BSF    03.5
0344:  MOVWF  4C
0345:  MOVLW  3E
0346:  MOVWF  4D
0347:  BCF    03.5
0348:  CALL   2D1
....................   delay_ms(20); 
0349:  MOVLW  14
034A:  BSF    03.5
034B:  MOVWF  48
034C:  BCF    03.5
034D:  CALL   066
....................   writeToRegister(TReloadRegL, 30); 
034E:  MOVLW  2D
034F:  BSF    03.5
0350:  MOVWF  4C
0351:  MOVLW  1E
0352:  MOVWF  4D
0353:  BCF    03.5
0354:  CALL   2D1
....................   delay_ms(20); 
0355:  MOVLW  14
0356:  BSF    03.5
0357:  MOVWF  48
0358:  BCF    03.5
0359:  CALL   066
....................   writeToRegister(TReloadRegH, 0); 
035A:  MOVLW  2C
035B:  BSF    03.5
035C:  MOVWF  4C
035D:  CLRF   4D
035E:  BCF    03.5
035F:  CALL   2D1
....................   delay_ms(20); 
0360:  MOVLW  14
0361:  BSF    03.5
0362:  MOVWF  48
0363:  BCF    03.5
0364:  CALL   066
....................   writeToRegister(TxAutoReg, 0x40);      // 100%ASK 
0365:  MOVLW  15
0366:  BSF    03.5
0367:  MOVWF  4C
0368:  MOVLW  40
0369:  MOVWF  4D
036A:  BCF    03.5
036B:  CALL   2D1
....................   delay_ms(20); 
036C:  MOVLW  14
036D:  BSF    03.5
036E:  MOVWF  48
036F:  BCF    03.5
0370:  CALL   066
....................   writeToRegister(ModeReg, 0x3D);        // CRC initial value 0x6363 
0371:  MOVLW  11
0372:  BSF    03.5
0373:  MOVWF  4C
0374:  MOVLW  3D
0375:  MOVWF  4D
0376:  BCF    03.5
0377:  CALL   2D1
....................   delay_ms(20); 
0378:  MOVLW  14
0379:  BSF    03.5
037A:  MOVWF  48
037B:  BCF    03.5
037C:  CALL   066
....................  //writeToRegister(TxControlReg, 0x82);      
....................   delay_ms(20); 
037D:  MOVLW  14
037E:  BSF    03.5
037F:  MOVWF  48
0380:  BCF    03.5
0381:  CALL   066
....................  setBitMask(TxControlReg, 0x03);        // Turn antenna on. 
0382:  MOVLW  14
0383:  BSF    03.5
0384:  MOVWF  48
0385:  MOVLW  03
0386:  MOVWF  49
0387:  BCF    03.5
0388:  CALL   319
0389:  BCF    0A.3
038A:  BCF    0A.4
038B:  GOTO   721 (RETURN)
.................... } 
....................  
.................... //Checking MFRC522 Firmwareversion 
.................... byte getFirmwareVersion() { 
....................   byte response; 
....................   response = readFromRegister(VersionReg); 
....................   return response; 
.................... } 
....................  
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................  
....................   @brief   Sends a command to a tag. 
....................  
....................   @param   cmd     The command to the MFRC522 to send a command to the tag. 
....................   @param   data    The data that is needed to complete the command. 
....................   @param   dlen    The length of the data. 
....................   @param   result  The result returned by the tag. 
....................   @param   rlen    The number of valid bits in the resulting value. 
....................  
....................   @returns Returns the status of the calculation. 
....................            MI_ERR        if something went wrong, 
....................            MI_NOTAGERR   if there was no tag to send the command to. 
....................            MI_OK         if everything went OK. 
....................  
....................  */ 
.................... /**************************************************************************/ 
....................  
.................... int commandTag(byte cmd, byte *data, int dlen, byte *result, int *rlen) { 
*
048E:  MOVLW  02
048F:  BSF    03.5
0490:  MOVWF  42
0491:  CLRF   43
0492:  CLRF   44
....................   int status = MI_ERR; 
....................   byte irqEn = 0x00; 
....................   byte waitIRq = 0x00; 
....................   byte lastBits, n; 
....................   int i; 
....................  
....................   switch (cmd) { 
0493:  MOVF   3A,W
0494:  XORLW  0E
0495:  BCF    03.5
0496:  BTFSC  03.2
0497:  GOTO   49C
0498:  XORLW  02
0499:  BTFSC  03.2
049A:  GOTO   4A2
049B:  GOTO   4A9
....................   case MFRC522_AUTHENT: 
....................     irqEn = 0x12; 
049C:  MOVLW  12
049D:  BSF    03.5
049E:  MOVWF  43
....................     waitIRq = 0x10; 
049F:  MOVLW  10
04A0:  MOVWF  44
....................     break; 
04A1:  GOTO   4AA
....................   case MFRC522_TRANSCEIVE: 
....................     irqEn = 0x77; 
04A2:  MOVLW  77
04A3:  BSF    03.5
04A4:  MOVWF  43
....................     waitIRq = 0x30; 
04A5:  MOVLW  30
04A6:  MOVWF  44
....................     break; 
04A7:  GOTO   4AA
04A8:  BCF    03.5
....................   default: 
....................     break; 
04A9:  BSF    03.5
....................   } 
....................  
....................   writeToRegister(CommIEnReg, irqEn|0x80);    // interrupt request 
04AA:  MOVF   43,W
04AB:  IORLW  80
04AC:  MOVWF  48
04AD:  MOVLW  02
04AE:  MOVWF  4C
04AF:  MOVF   48,W
04B0:  MOVWF  4D
04B1:  BCF    03.5
04B2:  CALL   2D1
....................   clearBitMask(CommIrqReg, 0x80);             // Clear all interrupt requests bits. 
04B3:  MOVLW  04
04B4:  BSF    03.5
04B5:  MOVWF  48
04B6:  MOVLW  80
04B7:  MOVWF  49
04B8:  BCF    03.5
04B9:  CALL   47B
....................   setBitMask(FIFOLevelReg, 0x80);             // FlushBuffer=1, FIFO initialization. 
04BA:  MOVLW  0A
04BB:  BSF    03.5
04BC:  MOVWF  48
04BD:  MOVLW  80
04BE:  MOVWF  49
04BF:  BCF    03.5
04C0:  CALL   319
....................  
....................   writeToRegister(CommandReg, MFRC522_IDLE);  // No action, cancel the current command. 
04C1:  MOVLW  01
04C2:  BSF    03.5
04C3:  MOVWF  4C
04C4:  CLRF   4D
04C5:  BCF    03.5
04C6:  CALL   2D1
....................  
....................   // Write to FIFO 
....................   for (i=0; i < dlen; i++) { 
04C7:  BSF    03.5
04C8:  CLRF   47
04C9:  MOVF   3D,W
04CA:  SUBWF  47,W
04CB:  BTFSC  03.0
04CC:  GOTO   4DE
....................     writeToRegister(FIFODataReg, data[i]); 
04CD:  MOVF   47,W
04CE:  ADDWF  3B,W
04CF:  MOVWF  04
04D0:  BCF    03.7
04D1:  BTFSC  3C.0
04D2:  BSF    03.7
04D3:  MOVF   00,W
04D4:  MOVWF  48
04D5:  MOVLW  09
04D6:  MOVWF  4C
04D7:  MOVF   48,W
04D8:  MOVWF  4D
04D9:  BCF    03.5
04DA:  CALL   2D1
04DB:  BSF    03.5
04DC:  INCF   47,F
04DD:  GOTO   4C9
....................   } 
....................  
....................   // Execute the command. 
....................   writeToRegister(CommandReg, cmd); 
04DE:  MOVLW  01
04DF:  MOVWF  4C
04E0:  MOVF   3A,W
04E1:  MOVWF  4D
04E2:  BCF    03.5
04E3:  CALL   2D1
....................   if (cmd == MFRC522_TRANSCEIVE) { 
04E4:  BSF    03.5
04E5:  MOVF   3A,W
04E6:  SUBLW  0C
04E7:  BTFSS  03.2
04E8:  GOTO   4F0
....................     setBitMask(BitFramingReg, 0x80);  // StartSend=1, transmission of data starts 
04E9:  MOVLW  0D
04EA:  MOVWF  48
04EB:  MOVLW  80
04EC:  MOVWF  49
04ED:  BCF    03.5
04EE:  CALL   319
04EF:  BSF    03.5
....................   } 
....................  
....................   // Waiting for the command to complete so we can receive data. 
....................   i = 25; // Max wait time is 25ms. 
04F0:  MOVLW  19
04F1:  MOVWF  47
....................   do { 
....................     delay_ms(1); 
04F2:  MOVLW  01
04F3:  MOVWF  48
04F4:  BCF    03.5
04F5:  CALL   066
....................     // CommIRqReg[7..0] 
....................     // Set1 TxIRq RxIRq IdleIRq HiAlerIRq LoAlertIRq ErrIRq TimerIRq 
....................     n = readFromRegister(CommIrqReg); 
04F6:  MOVLW  04
04F7:  BSF    03.5
04F8:  MOVWF  4B
04F9:  BCF    03.5
04FA:  CALL   2F2
04FB:  MOVF   78,W
04FC:  BSF    03.5
04FD:  MOVWF  46
....................     i--; 
04FE:  DECF   47,F
....................   } while ((i!=0) && !(n&0x01) && !(n&waitIRq)); 
04FF:  MOVF   47,F
0500:  BTFSC  03.2
0501:  GOTO   508
0502:  BTFSC  46.0
0503:  GOTO   508
0504:  MOVF   46,W
0505:  ANDWF  44,W
0506:  BTFSC  03.2
0507:  GOTO   4F2
....................  
....................   clearBitMask(BitFramingReg, 0x80);  // StartSend=0 
0508:  MOVLW  0D
0509:  MOVWF  48
050A:  MOVLW  80
050B:  MOVWF  49
050C:  BCF    03.5
050D:  CALL   47B
....................  
....................   if (i != 0) { // Request did not time out. 
050E:  BSF    03.5
050F:  MOVF   47,F
0510:  BTFSC  03.2
0511:  GOTO   585
....................     if(!(readFromRegister(ErrorReg) & 0x1D)) {  // BufferOvfl Collerr CRCErr ProtocolErr 
0512:  MOVLW  06
0513:  MOVWF  4B
0514:  BCF    03.5
0515:  CALL   2F2
0516:  MOVF   78,W
0517:  ANDLW  1D
0518:  BTFSS  03.2
0519:  GOTO   582
....................       status = MI_OK; 
051A:  BSF    03.5
051B:  CLRF   42
....................       if (n & irqEn & 0x01) { 
051C:  MOVF   46,W
051D:  ANDWF  43,W
051E:  ANDLW  01
051F:  BTFSC  03.2
0520:  GOTO   523
....................         status = MI_NOTAGERR; 
0521:  MOVLW  01
0522:  MOVWF  42
....................       } 
....................  
....................       if (cmd == MFRC522_TRANSCEIVE) { 
0523:  MOVF   3A,W
0524:  SUBLW  0C
0525:  BTFSS  03.2
0526:  GOTO   580
....................         n = readFromRegister(FIFOLevelReg); 
0527:  MOVLW  0A
0528:  MOVWF  4B
0529:  BCF    03.5
052A:  CALL   2F2
052B:  MOVF   78,W
052C:  BSF    03.5
052D:  MOVWF  46
....................         lastBits = readFromRegister(ControlReg) & 0x07; 
052E:  MOVLW  0C
052F:  MOVWF  4B
0530:  BCF    03.5
0531:  CALL   2F2
0532:  MOVF   78,W
0533:  ANDLW  07
0534:  BSF    03.5
0535:  MOVWF  45
....................         if (lastBits) { 
0536:  MOVF   45,F
0537:  BTFSC  03.2
0538:  GOTO   54A
....................           *rlen = (n-1)*8 + lastBits; 
0539:  MOVF   40,W
053A:  MOVWF  04
053B:  BCF    03.7
053C:  BTFSC  41.0
053D:  BSF    03.7
053E:  MOVLW  01
053F:  SUBWF  46,W
0540:  MOVWF  77
0541:  RLF    77,F
0542:  RLF    77,F
0543:  RLF    77,F
0544:  MOVLW  F8
0545:  ANDWF  77,F
0546:  MOVF   77,W
0547:  ADDWF  45,W
0548:  MOVWF  00
....................         } else { 
0549:  GOTO   557
....................           *rlen = n*8; 
054A:  MOVF   40,W
054B:  MOVWF  04
054C:  BCF    03.7
054D:  BTFSC  41.0
054E:  BSF    03.7
054F:  RLF    46,W
0550:  MOVWF  77
0551:  RLF    77,F
0552:  RLF    77,F
0553:  MOVLW  F8
0554:  ANDWF  77,F
0555:  MOVF   77,W
0556:  MOVWF  00
....................         } 
....................  
....................         if (n == 0) { 
0557:  MOVF   46,F
0558:  BTFSS  03.2
0559:  GOTO   55C
....................           n = 1; 
055A:  MOVLW  01
055B:  MOVWF  46
....................         } 
....................  
....................         if (n > MAX_LEN) { 
055C:  MOVF   46,W
055D:  SUBLW  10
055E:  BTFSC  03.0
055F:  GOTO   562
....................           n = MAX_LEN; 
0560:  MOVLW  10
0561:  MOVWF  46
....................         } 
....................  
....................         // Reading the recieved data from FIFO. 
....................         for (i=0; i<n; i++) { 
0562:  CLRF   47
0563:  MOVF   46,W
0564:  SUBWF  47,W
0565:  BTFSC  03.0
0566:  GOTO   580
....................           result[i] = readFromRegister(FIFODataReg); 
0567:  MOVF   47,W
0568:  ADDWF  3E,W
0569:  MOVWF  78
056A:  MOVF   3F,W
056B:  MOVWF  7A
056C:  BTFSC  03.0
056D:  INCF   7A,F
056E:  MOVF   78,W
056F:  MOVWF  48
0570:  MOVF   7A,W
0571:  MOVWF  49
0572:  MOVLW  09
0573:  MOVWF  4B
0574:  BCF    03.5
0575:  CALL   2F2
0576:  BSF    03.5
0577:  MOVF   48,W
0578:  MOVWF  04
0579:  BCF    03.7
057A:  BTFSC  49.0
057B:  BSF    03.7
057C:  MOVF   78,W
057D:  MOVWF  00
057E:  INCF   47,F
057F:  GOTO   563
....................         } 
....................       } 
....................     } else { 
0580:  GOTO   585
0581:  BCF    03.5
....................       status = MI_ERR; 
0582:  MOVLW  02
0583:  BSF    03.5
0584:  MOVWF  42
....................     } 
....................   } 
....................   return status; 
0585:  MOVF   42,W
0586:  MOVWF  78
0587:  BCF    03.5
0588:  RETURN
.................... } 
....................  
....................  
.................... /**************************************************************************/ 
.................... /* 
....................  
....................   @brief   Checks to see if there is a tag in the vicinity. 
....................  
....................   @param   mode  The mode we are requsting in. 
....................   @param   type  If we find a tag, this will be the type of that tag. 
....................                  0x4400 = Mifare_UltraLight 
....................                  0x0400 = Mifare_One(S50) 
....................                  0x0200 = Mifare_One(S70) 
....................                  0x0800 = Mifare_Pro(X) 
....................                  0x4403 = Mifare_DESFire 
....................  
....................   @returns Returns the status of the request. 
....................            MI_ERR        if something went wrong, 
....................            MI_NOTAGERR   if there was no tag to send the command to. 
....................            MI_OK         if everything went OK. 
....................  
....................  */ 
.................... /**************************************************************************/ 
.................... int requestTag(byte mode, byte *data) { 
....................   int status, len; 
....................   writeToRegister(BitFramingReg, 0x07);  // TxLastBists = BitFramingReg[2..0] 
0589:  MOVLW  0D
058A:  BSF    03.5
058B:  MOVWF  4C
058C:  MOVLW  07
058D:  MOVWF  4D
058E:  BCF    03.5
058F:  CALL   2D1
....................  
....................   data[0] = mode; 
0590:  BSF    03.5
0591:  MOVF   35,W
0592:  MOVWF  04
0593:  BCF    03.7
0594:  BTFSC  36.0
0595:  BSF    03.7
0596:  MOVF   34,W
0597:  MOVWF  00
....................   status = commandTag(MFRC522_TRANSCEIVE, data, 1, data, &len); 
0598:  MOVLW  0C
0599:  MOVWF  3A
059A:  MOVF   36,W
059B:  MOVWF  3C
059C:  MOVF   35,W
059D:  MOVWF  3B
059E:  MOVLW  01
059F:  MOVWF  3D
05A0:  MOVF   36,W
05A1:  MOVWF  3F
05A2:  MOVF   35,W
05A3:  MOVWF  3E
05A4:  CLRF   41
05A5:  MOVLW  B8
05A6:  MOVWF  40
05A7:  BCF    03.5
05A8:  CALL   48E
05A9:  MOVF   78,W
05AA:  BSF    03.5
05AB:  MOVWF  37
....................  
....................   if ((status != MI_OK) || (len != 0x10)) { 
05AC:  MOVF   37,F
05AD:  BTFSS  03.2
05AE:  GOTO   5B3
05AF:  MOVF   38,W
05B0:  SUBLW  10
05B1:  BTFSC  03.2
05B2:  GOTO   5B5
....................     status = MI_ERR; 
05B3:  MOVLW  02
05B4:  MOVWF  37
....................   } 
....................  
....................   return status; 
05B5:  MOVF   37,W
05B6:  MOVWF  78
05B7:  BCF    03.5
05B8:  BCF    0A.3
05B9:  BCF    0A.4
05BA:  GOTO   72A (RETURN)
.................... } 
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................  
....................   @brief   Handles collisions that might occur if there are multiple 
....................            tags available. 
....................  
....................   @param   serial  The serial nb of the tag. 
....................  
....................   @returns Returns the status of the collision detection. 
....................            MI_ERR        if something went wrong, 
....................            MI_NOTAGERR   if there was no tag to send the command to. 
....................            MI_OK         if everything went OK. 
....................  
....................  */ 
.................... /**************************************************************************/ 
.................... int antiCollision(byte *serial) { 
*
0620:  CLRF   39
....................   int status, i, len; 
....................   byte check = 0x00; 
....................  
....................   writeToRegister(BitFramingReg, 0x00);  // TxLastBits = BitFramingReg[2..0] 
0621:  MOVLW  0D
0622:  MOVWF  4C
0623:  CLRF   4D
0624:  BCF    03.5
0625:  CALL   2D1
....................  
....................   serial[0] = MF1_ANTICOLL; 
0626:  BSF    03.5
0627:  MOVF   34,W
0628:  MOVWF  04
0629:  BCF    03.7
062A:  BTFSC  35.0
062B:  BSF    03.7
062C:  MOVLW  93
062D:  MOVWF  00
....................   serial[1] = 0x20; 
062E:  MOVLW  01
062F:  ADDWF  34,W
0630:  MOVWF  04
0631:  BCF    03.7
0632:  BTFSC  35.0
0633:  BSF    03.7
0634:  MOVLW  20
0635:  MOVWF  00
....................   status = commandTag(MFRC522_TRANSCEIVE, serial, 2, serial, &len); 
0636:  MOVLW  0C
0637:  MOVWF  3A
0638:  MOVF   35,W
0639:  MOVWF  3C
063A:  MOVF   34,W
063B:  MOVWF  3B
063C:  MOVLW  02
063D:  MOVWF  3D
063E:  MOVF   35,W
063F:  MOVWF  3F
0640:  MOVF   34,W
0641:  MOVWF  3E
0642:  CLRF   41
0643:  MOVLW  B8
0644:  MOVWF  40
0645:  BCF    03.5
0646:  CALL   48E
0647:  MOVF   78,W
0648:  BSF    03.5
0649:  MOVWF  36
....................   len = len / 8; // len is in bits, and we want each byte. 
064A:  RRF    38,F
064B:  RRF    38,F
064C:  RRF    38,F
064D:  MOVLW  1F
064E:  ANDWF  38,F
....................   if (status == MI_OK) { 
064F:  MOVF   36,F
0650:  BTFSS  03.2
0651:  GOTO   66E
....................     // The checksum of the tag is the ^ of all the values. 
....................     for (i = 0; i < len-1; i++) { 
0652:  CLRF   37
0653:  MOVLW  01
0654:  SUBWF  38,W
0655:  SUBWF  37,W
0656:  BTFSC  03.0
0657:  GOTO   662
....................       check ^= serial[i]; 
0658:  MOVF   37,W
0659:  ADDWF  34,W
065A:  MOVWF  04
065B:  BCF    03.7
065C:  BTFSC  35.0
065D:  BSF    03.7
065E:  MOVF   00,W
065F:  XORWF  39,F
0660:  INCF   37,F
0661:  GOTO   653
....................     } 
....................     // The checksum should be the same as the one provided from the 
....................     // tag (serial[4]). 
....................     if (check != serial[i]) { 
0662:  MOVF   37,W
0663:  ADDWF  34,W
0664:  MOVWF  04
0665:  BCF    03.7
0666:  BTFSC  35.0
0667:  BSF    03.7
0668:  MOVF   00,W
0669:  SUBWF  39,W
066A:  BTFSC  03.2
066B:  GOTO   66E
....................       status = MI_ERR; 
066C:  MOVLW  02
066D:  MOVWF  36
....................     } 
....................   } 
....................  
....................   return status; 
066E:  MOVF   36,W
066F:  MOVWF  78
.................... } 
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................  
....................   @brief   Calculates the CRC value for some data that should be sent to 
....................            a tag. 
....................  
....................   @param   data    The data to calculate the value for. 
....................   @param   len     The length of the data. 
....................   @param   result  The result of the CRC calculation. 
....................  
....................  */ 
.................... /**************************************************************************/ 
.................... void calculateCRC(byte *data, int len, byte *result) { 
....................   int i; 
....................   byte n; 
....................  
....................   clearBitMask(DivIrqReg, 0x04);   // CRCIrq = 0 
....................   setBitMask(FIFOLevelReg, 0x80);  // Clear the FIFO pointer 
....................  
....................   //Writing data to the FIFO. 
....................   for (i = 0; i < len; i++) { 
....................     writeToRegister(FIFODataReg, data[i]); 
....................   } 
....................   writeToRegister(CommandReg, MFRC522_CALCCRC); 
....................  
....................   // Wait for the CRC calculation to complete. 
....................   i = 0xFF; 
....................   do { 
....................     n = readFromRegister(DivIrqReg); 
....................     i--; 
....................   } while ((i != 0) && !(n & 0x04));  //CRCIrq = 1 
....................  
....................   // Read the result from the CRC calculation. 
....................   result[0] = readFromRegister(CRCResultRegL); 
....................   result[1] = readFromRegister(CRCResultRegM); 
.................... } 
....................  
....................  
....................  
.................... byte FoundTag; // Variable used to check if Tag was found 
.................... byte ReadTag; // Variable used to store anti-collision value to read Tag information 
.................... byte TagData[16]; // Variable used to store Full Tag Data 
.................... byte GoodTagSerialNumber[4] = {0x9E, 0x80, 0xB1, 0x59}; // The Tag Serial number we are looking for 
*
06E8:  MOVLW  9E
06E9:  MOVWF  38
06EA:  MOVLW  80
06EB:  MOVWF  39
06EC:  MOVLW  B1
06ED:  MOVWF  3A
06EE:  MOVLW  59
06EF:  MOVWF  3B
.................... int i=0; 
.................... char buffer[20],buffer2[20],text[20]; 
.................... byte version; 
.................... int GoodTag=0; // Variable used to confirm good Tag Detected  
....................  
....................  
.................... void CheckRFIDHardware(){ 
.................... lcd_putc("\f Checking RFID..."); 
*
038C:  MOVLW  04
038D:  BSF    03.6
038E:  MOVWF  0D
038F:  MOVLW  00
0390:  MOVWF  0F
0391:  BCF    03.6
0392:  CALL   1E7
.................... //check request 
.................... version = readFromRegister(VersionReg); 
0393:  MOVLW  37
0394:  BSF    03.5
0395:  MOVWF  4B
0396:  BCF    03.5
0397:  CALL   2F2
0398:  MOVF   78,W
0399:  MOVWF  65
.................... delay_ms(1000); 
039A:  MOVLW  04
039B:  BSF    03.5
039C:  MOVWF  34
039D:  MOVLW  FA
039E:  MOVWF  48
039F:  BCF    03.5
03A0:  CALL   066
03A1:  BSF    03.5
03A2:  DECFSZ 34,F
03A3:  GOTO   39D
....................  
.................... //response is 00 then hardware is not connected 
.................... if(!version){ 
03A4:  BCF    03.5
03A5:  MOVF   65,F
03A6:  BTFSS  03.2
03A7:  GOTO   3BA
....................     lcd_putc("\f RFID Not Found \n Check Again.."); 
03A8:  MOVLW  0E
03A9:  BSF    03.6
03AA:  MOVWF  0D
03AB:  MOVLW  00
03AC:  MOVWF  0F
03AD:  BCF    03.6
03AE:  CALL   1E7
....................     delay_ms(5000); 
03AF:  MOVLW  14
03B0:  BSF    03.5
03B1:  MOVWF  34
03B2:  MOVLW  FA
03B3:  MOVWF  48
03B4:  BCF    03.5
03B5:  CALL   066
03B6:  BSF    03.5
03B7:  DECFSZ 34,F
03B8:  GOTO   3B2
03B9:  BCF    03.5
.................... } 
.................... if(version){ 
03BA:  MOVF   65,F
03BB:  BTFSC  03.2
03BC:  GOTO   478
....................     lcd_putc("\f RFID Found"); 
03BD:  MOVLW  1F
03BE:  BSF    03.6
03BF:  MOVWF  0D
03C0:  MOVLW  00
03C1:  MOVWF  0F
03C2:  BCF    03.6
03C3:  CALL   1E7
....................     printf(lcd_putc,"\nV: %x",version); 
03C4:  MOVLW  26
03C5:  BSF    03.6
03C6:  MOVWF  0D
03C7:  MOVLW  00
03C8:  MOVWF  0F
03C9:  BCF    03.0
03CA:  MOVLW  04
03CB:  BSF    03.5
03CC:  BCF    03.6
03CD:  MOVWF  34
*
0444:  BCF    03.5
0445:  MOVF   65,W
0446:  BSF    03.5
0447:  MOVWF  34
0448:  MOVLW  57
0449:  MOVWF  35
....................     delay_ms(1000); 
*
046D:  MOVLW  04
046E:  BSF    03.5
046F:  MOVWF  34
0470:  MOVLW  FA
0471:  MOVWF  48
0472:  BCF    03.5
0473:  CALL   066
0474:  BSF    03.5
0475:  DECFSZ 34,F
0476:  GOTO   470
0477:  BCF    03.5
.................... } 
0478:  BCF    0A.3
0479:  BCF    0A.4
047A:  GOTO   722 (RETURN)
....................  
.................... }  
....................  
.................... void readRFID() 
.................... { 
....................      
....................     lcd_putc("\fHold Tag Still"); 
*
060C:  MOVLW  2A
060D:  BSF    03.6
060E:  MOVWF  0D
060F:  MOVLW  00
0610:  MOVWF  0F
0611:  BCF    03.6
0612:  CALL   1E7
....................      
....................     delay_ms(500); 
0613:  MOVLW  02
0614:  BSF    03.5
0615:  MOVWF  34
0616:  MOVLW  FA
0617:  MOVWF  48
0618:  BCF    03.5
0619:  CALL   066
061A:  BSF    03.5
061B:  DECFSZ 34,F
061C:  GOTO   616
....................     // Get anti-collision value to properly read information from the Tag 
....................     ReadTag = antiCollision(TagData); 
061D:  CLRF   35
061E:  MOVLW  28
061F:  MOVWF  34
*
0670:  MOVF   78,W
0671:  BCF    03.5
0672:  MOVWF  27
....................      
....................     lcd_putc("\f"); 
0673:  MOVLW  32
0674:  BSF    03.6
0675:  MOVWF  0D
0676:  MOVLW  00
0677:  MOVWF  0F
0678:  BCF    03.6
0679:  CALL   1E7
....................      
....................     lcd_putc("Data: "); 
067A:  MOVLW  33
067B:  BSF    03.6
067C:  MOVWF  0D
067D:  MOVLW  00
067E:  MOVWF  0F
067F:  BCF    03.6
0680:  CALL   1E7
....................       
....................    for(i=0;i<=2;i++) 
0681:  CLRF   3C
0682:  MOVF   3C,W
0683:  SUBLW  02
0684:  BTFSS  03.0
0685:  GOTO   6A3
....................    { 
....................     sprintf(buffer2,"%2X",(TagData[i])); //display version in hexadecimal 
0686:  MOVLW  28
0687:  ADDWF  3C,W
0688:  MOVWF  04
0689:  BCF    03.7
068A:  MOVF   00,W
068B:  BSF    03.5
068C:  MOVWF  34
068D:  BCF    03.5
068E:  CLRF   68
068F:  MOVLW  51
0690:  MOVWF  67
0691:  BSF    03.5
0692:  MOVF   34,W
0693:  MOVWF  35
0694:  MOVLW  37
0695:  MOVWF  36
0696:  BCF    03.5
0697:  CALL   5CA
....................     delay_ms(20); 
0698:  MOVLW  14
0699:  BSF    03.5
069A:  MOVWF  48
069B:  BCF    03.5
069C:  CALL   066
....................     printf(lcd_putc,buffer2); 
069D:  MOVLW  51
069E:  MOVWF  04
069F:  BCF    03.7
06A0:  CALL   5EF
06A1:  INCF   3C,F
06A2:  GOTO   682
....................    
....................    } 
....................     sprintf(buffer2,"%2X",(TagData[i])); //display version in hexadecimal 
06A3:  MOVLW  28
06A4:  ADDWF  3C,W
06A5:  MOVWF  04
06A6:  BCF    03.7
06A7:  MOVF   00,W
06A8:  BSF    03.5
06A9:  MOVWF  34
06AA:  BCF    03.5
06AB:  CLRF   68
06AC:  MOVLW  51
06AD:  MOVWF  67
06AE:  BSF    03.5
06AF:  MOVF   34,W
06B0:  MOVWF  35
06B1:  MOVLW  37
06B2:  MOVWF  36
06B3:  BCF    03.5
06B4:  CALL   5CA
....................     delay_ms(20); 
06B5:  MOVLW  14
06B6:  BSF    03.5
06B7:  MOVWF  48
06B8:  BCF    03.5
06B9:  CALL   066
....................     printf(lcd_putc,buffer2);  
06BA:  MOVLW  51
06BB:  MOVWF  04
06BC:  BCF    03.7
06BD:  CALL   5EF
....................      
....................      
....................     delay_ms(2000); 
06BE:  MOVLW  08
06BF:  BSF    03.5
06C0:  MOVWF  34
06C1:  MOVLW  FA
06C2:  MOVWF  48
06C3:  BCF    03.5
06C4:  CALL   066
06C5:  BSF    03.5
06C6:  DECFSZ 34,F
06C7:  GOTO   6C1
06C8:  BCF    03.5
06C9:  BCF    0A.3
06CA:  BCF    0A.4
06CB:  GOTO   759 (RETURN)
....................   
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... void main() {    
06CC:  MOVF   03,W
06CD:  ANDLW  1F
06CE:  MOVWF  03
06CF:  MOVLW  19
06D0:  BSF    03.5
06D1:  MOVWF  19
06D2:  MOVLW  A6
06D3:  MOVWF  18
06D4:  MOVLW  90
06D5:  BCF    03.5
06D6:  MOVWF  18
06D7:  CLRF   3C
06D8:  CLRF   66
06D9:  CLRF   68
06DA:  CLRF   67
06DB:  MOVLW  FF
06DC:  MOVWF  69
06DD:  BSF    03.5
06DE:  BSF    1F.0
06DF:  BSF    1F.1
06E0:  BSF    1F.2
06E1:  BCF    1F.3
06E2:  MOVLW  07
06E3:  MOVWF  1C
06E4:  BCF    03.7
....................      
....................     //setup spi line  
....................     setup_spi(SPI_MASTER|SPI_MODE_0|SPI_CLK_DIV_16);  
*
06F0:  BCF    14.5
06F1:  BCF    69.5
06F2:  MOVF   69,W
06F3:  BSF    03.5
06F4:  MOVWF  07
06F5:  BCF    03.5
06F6:  BSF    69.4
06F7:  MOVF   69,W
06F8:  BSF    03.5
06F9:  MOVWF  07
06FA:  BCF    03.5
06FB:  BCF    69.3
06FC:  MOVF   69,W
06FD:  BSF    03.5
06FE:  MOVWF  07
06FF:  MOVLW  21
0700:  BCF    03.5
0701:  MOVWF  14
0702:  MOVLW  40
0703:  BSF    03.5
0704:  MOVWF  14
....................      
....................     //init lcd and put some string 
....................     lcd_init();     
0705:  BCF    03.5
0706:  GOTO   145
....................     lcd_putc("\f Starting...");     
0707:  MOVLW  37
0708:  BSF    03.6
0709:  MOVWF  0D
070A:  MOVLW  00
070B:  MOVWF  0F
070C:  BCF    03.6
070D:  CALL   1E7
....................     printf("starting.."); 
070E:  MOVLW  3E
070F:  BSF    03.6
0710:  MOVWF  0D
0711:  MOVLW  00
0712:  MOVWF  0F
0713:  BCF    03.6
0714:  CALL   25B
....................     delay_ms(500); 
0715:  MOVLW  02
0716:  BSF    03.5
0717:  MOVWF  34
0718:  MOVLW  FA
0719:  MOVWF  48
071A:  BCF    03.5
071B:  CALL   066
071C:  BSF    03.5
071D:  DECFSZ 34,F
071E:  GOTO   718
....................      
....................     //initialize RFID Reader 
....................     MFRC_begin(); 
071F:  BCF    03.5
0720:  GOTO   32B
....................      
....................     //check if the card reader is connected. 
....................     CheckRFIDHardware(); 
0721:  GOTO   38C
....................      
....................      
....................     while(TRUE){ 
....................          
....................       //  Check to see if a Tag was detected 
....................      // If yes, then the variable FoundTag will contain "MI_OK" 
....................     FoundTag = requestTag(MF1_REQIDL, TagData); 
0722:  MOVLW  26
0723:  BSF    03.5
0724:  MOVWF  34
0725:  CLRF   36
0726:  MOVLW  28
0727:  MOVWF  35
0728:  BCF    03.5
0729:  GOTO   589
072A:  MOVF   78,W
072B:  MOVWF  26
....................      
....................     lcd_putc("\fChecking for Tag \r\n"); 
072C:  MOVLW  44
072D:  BSF    03.6
072E:  MOVWF  0D
072F:  MOVLW  00
0730:  MOVWF  0F
0731:  BCF    03.6
0732:  CALL   1E7
....................     printf("\r\n Check For Tag"); 
0733:  MOVLW  4F
0734:  BSF    03.6
0735:  MOVWF  0D
0736:  MOVLW  00
0737:  MOVWF  0F
0738:  BCF    03.6
0739:  CALL   25B
....................     delay_ms(500); 
073A:  MOVLW  02
073B:  BSF    03.5
073C:  MOVWF  34
073D:  MOVLW  FA
073E:  MOVWF  48
073F:  BCF    03.5
0740:  CALL   066
0741:  BSF    03.5
0742:  DECFSZ 34,F
0743:  GOTO   73D
....................     
....................      
....................     //tag is found 
....................     if(FoundTag == MI_OK){ 
0744:  BCF    03.5
0745:  MOVF   26,F
0746:  BTFSS  03.2
0747:  GOTO   75E
....................          
....................         //if tag is found PIN_B0 is set to high, 
....................         output_high(PIN_B0); 
0748:  BSF    03.5
0749:  BCF    06.0
074A:  BCF    03.5
074B:  BSF    06.0
....................          
....................         //put that rfid is found on display 
....................         lcd_putc("\f Tag Found"); 
074C:  MOVLW  58
074D:  BSF    03.6
074E:  MOVWF  0D
074F:  MOVLW  00
0750:  MOVWF  0F
0751:  BCF    03.6
0752:  CALL   1E7
....................          
....................         delay_ms(200); 
0753:  MOVLW  C8
0754:  BSF    03.5
0755:  MOVWF  48
0756:  BCF    03.5
0757:  CALL   066
....................  
....................          
....................         readRFID(); 
0758:  GOTO   60C
....................          
....................         //set PIN_BO to low 
....................         output_low(PIN_B0); 
0759:  BSF    03.5
075A:  BCF    06.0
075B:  BCF    03.5
075C:  BCF    06.0
....................         
....................     }else{//tag not found 
075D:  GOTO   770
....................         lcd_putc("\f Tag Not Found"); 
075E:  MOVLW  5E
075F:  BSF    03.6
0760:  MOVWF  0D
0761:  MOVLW  00
0762:  MOVWF  0F
0763:  BCF    03.6
0764:  CALL   1E7
....................         delay_ms(1000); 
0765:  MOVLW  04
0766:  BSF    03.5
0767:  MOVWF  34
0768:  MOVLW  FA
0769:  MOVWF  48
076A:  BCF    03.5
076B:  CALL   066
076C:  BSF    03.5
076D:  DECFSZ 34,F
076E:  GOTO   768
076F:  BCF    03.5
....................     } 
....................      
....................     delay_ms(1000); 
0770:  MOVLW  04
0771:  BSF    03.5
0772:  MOVWF  34
0773:  MOVLW  FA
0774:  MOVWF  48
0775:  BCF    03.5
0776:  CALL   066
0777:  BSF    03.5
0778:  DECFSZ 34,F
0779:  GOTO   773
077A:  BCF    03.5
077B:  GOTO   722
....................          
....................     } 
....................      
....................      
....................     return; 
.................... } 
....................  
077C:  SLEEP

Configuration Fuses:
   Word  1: 3F71   XT NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
