CCS PCM C Compiler, Version 5.078, 43599               08-Apr-19 09:16

               Filename:   C:\Users\Shashikant\Documents\GitHub\RFID.X\build\default\production\main.lst

               ROM used:   4054 words (49%)
                           Largest free fragment is 2048
               RAM used:   143 (14%) at main() level
                           230 (22%) worst case
               Stack used: 5 locations
               Stack size: 16

*
0000:  MOVLP  08
0001:  GOTO   5E1
0002:  NOP
.................... /*  
....................  * File:   main.c 
....................  * Author: Shashikant 
....................  * 
....................  * Created on 2 July, 2018, 12:43 PM 
....................  */ 
....................  
.................... //Options 
.................... #include <16F18855.h> 
.................... //////////// Standard Header file for the PIC16F18855 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F18855 
0003:  DATA 0D,05
0004:  DATA 43,34
0005:  DATA E5,31
0006:  DATA EB,34
0007:  DATA EE,33
0008:  DATA A0,24
0009:  DATA 66,10
000A:  DATA 52,33
000B:  DATA 69,32
000C:  DATA A0,24
000D:  DATA 73,10
000E:  DATA C3,37
000F:  DATA 6E,37
0010:  DATA E5,31
0011:  DATA F4,32
0012:  DATA 64,00
0013:  DATA 0C,10
0014:  DATA 52,23
0015:  DATA 49,22
0016:  DATA 20,27
0017:  DATA 6F,3A
0018:  DATA 20,23
0019:  DATA EF,3A
001A:  DATA 6E,32
001B:  DATA 20,05
001C:  DATA A0,21
001D:  DATA E8,32
001E:  DATA E3,35
001F:  DATA A0,20
0020:  DATA E7,30
0021:  DATA 69,37
0022:  DATA 2E,17
0023:  DATA 00,00
0024:  DATA 0D,05
0025:  DATA 52,23
0026:  DATA 49,22
0027:  DATA 20,24
0028:  DATA 77,10
0029:  DATA EE,37
002A:  DATA 74,10
002B:  DATA C6,37
002C:  DATA 75,37
002D:  DATA 64,00
002E:  DATA 0C,10
002F:  DATA 52,23
0030:  DATA 49,22
0031:  DATA 20,23
0032:  DATA EF,3A
0033:  DATA 6E,32
0034:  DATA 00,01
0035:  DATA 0A,2B
0036:  DATA 3A,10
0037:  DATA 25,3C
0038:  DATA 00,00
0039:  DATA 0D,05
003A:  DATA 52,23
003B:  DATA 49,22
003C:  DATA 20,23
003D:  DATA EF,3A
003E:  DATA 6E,32
003F:  DATA A0,30
0040:  DATA 6E,32
0041:  DATA 20,24
0042:  DATA 57,10
0043:  DATA F6,32
0044:  DATA F2,39
0045:  DATA E9,37
0046:  DATA 6E,10
0047:  DATA E9,39
0048:  DATA 3A,10
0049:  DATA 30,3C
004A:  DATA 25,19
004B:  DATA D8,06
004C:  DATA 0A,00
004D:  DATA C1,3A
004E:  DATA 74,34
004F:  DATA 65,37
0050:  DATA F4,34
0051:  DATA E3,30
0052:  DATA F4,32
0053:  DATA 64,10
0054:  DATA 62,36
0055:  DATA EF,31
0056:  DATA 6B,10
0057:  DATA 30,3C
0058:  DATA 25,19
0059:  DATA 58,10
005A:  DATA F7,34
005B:  DATA 74,34
005C:  DATA A0,20
005D:  DATA 0D,05
005E:  DATA 00,01
005F:  DATA D2,32
0060:  DATA 61,32
0061:  DATA 20,33
0062:  DATA E1,34
0063:  DATA EC,32
0064:  DATA E4,06
0065:  DATA 0A,00
0066:  DATA C1,3A
0067:  DATA 74,34
0068:  DATA 65,37
0069:  DATA F4,34
006A:  DATA E3,30
006B:  DATA F4,32
006C:  DATA 64,10
006D:  DATA 62,36
006E:  DATA EF,31
006F:  DATA 6B,10
0070:  DATA 30,3C
0071:  DATA 25,19
0072:  DATA 58,10
0073:  DATA F7,34
0074:  DATA 74,34
0075:  DATA A0,35
0076:  DATA E5,3C
0077:  DATA 20,21
0078:  DATA 00,01
0079:  DATA D2,32
007A:  DATA 61,32
007B:  DATA 20,33
007C:  DATA E1,34
007D:  DATA EC,32
007E:  DATA 64,10
007F:  DATA 0D,05
0080:  DATA 00,01
0081:  DATA C1,31
0082:  DATA E3,32
0083:  DATA F3,39
0084:  DATA 20,32
0085:  DATA 65,37
0086:  DATA E9,32
0087:  DATA 64,10
0088:  DATA 61,3A
0089:  DATA 20,31
008A:  DATA EC,37
008B:  DATA E3,35
008C:  DATA 20,18
008D:  DATA F8,12
008E:  DATA 32,2C
008F:  DATA 00,00
0090:  DATA C1,3A
0091:  DATA 74,34
0092:  DATA 65,37
0093:  DATA F4,34
0094:  DATA E3,30
0095:  DATA F4,32
0096:  DATA 64,10
0097:  DATA 62,36
0098:  DATA EF,31
0099:  DATA 6B,10
009A:  DATA 30,3C
009B:  DATA 25,19
009C:  DATA 58,10
009D:  DATA F7,34
009E:  DATA 74,34
009F:  DATA A0,25
00A0:  DATA E5,3C
00A1:  DATA A0,20
00A2:  DATA 0D,05
00A3:  DATA 00,01
00A4:  DATA D2,32
00A5:  DATA 61,32
00A6:  DATA 20,33
00A7:  DATA E1,34
00A8:  DATA EC,32
00A9:  DATA E4,06
00AA:  DATA 0A,00
00AB:  DATA C1,3A
00AC:  DATA 74,34
00AD:  DATA 65,37
00AE:  DATA F4,34
00AF:  DATA E3,30
00B0:  DATA F4,32
00B1:  DATA 64,10
00B2:  DATA 62,36
00B3:  DATA EF,31
00B4:  DATA 6B,10
00B5:  DATA 30,3C
00B6:  DATA 25,19
00B7:  DATA 58,10
00B8:  DATA F7,34
00B9:  DATA 74,34
00BA:  DATA A0,35
00BB:  DATA E5,3C
00BC:  DATA 20,21
00BD:  DATA 00,01
00BE:  DATA D2,32
00BF:  DATA 61,32
00C0:  DATA 20,33
00C1:  DATA E1,34
00C2:  DATA EC,32
00C3:  DATA 64,10
00C4:  DATA 0D,05
00C5:  DATA 00,01
00C6:  DATA C1,31
00C7:  DATA E3,32
00C8:  DATA F3,39
00C9:  DATA 20,32
00CA:  DATA 65,37
00CB:  DATA E9,32
00CC:  DATA 64,10
00CD:  DATA 61,3A
00CE:  DATA 20,31
00CF:  DATA EC,37
00D0:  DATA E3,35
00D1:  DATA 20,18
00D2:  DATA F8,12
00D3:  DATA 32,2C
00D4:  DATA 00,00
00D5:  DATA C1,3A
00D6:  DATA 74,34
00D7:  DATA 65,37
00D8:  DATA F4,34
00D9:  DATA E3,30
00DA:  DATA F4,32
00DB:  DATA 64,10
00DC:  DATA F7,34
00DD:  DATA 74,34
00DE:  DATA A0,35
00DF:  DATA E5,3C
00E0:  DATA A0,20
00E1:  DATA A0,06
00E2:  DATA 0A,00
00E3:  DATA 57,39
00E4:  DATA 69,3A
00E5:  DATA 65,10
00E6:  DATA D3,3A
00E7:  DATA E3,31
00E8:  DATA E5,39
00E9:  DATA 73,33
00EA:  DATA 75,36
00EB:  DATA 0D,05
00EC:  DATA 00,01
00ED:  DATA 57,39
00EE:  DATA 69,3A
00EF:  DATA 65,10
00F0:  DATA E6,30
00F1:  DATA 69,36
00F2:  DATA 65,32
00F3:  DATA 0D,05
00F4:  DATA 00,01
00F5:  DATA C1,3A
00F6:  DATA 74,34
00F7:  DATA 65,37
00F8:  DATA F4,34
00F9:  DATA E3,30
00FA:  DATA F4,32
00FB:  DATA 64,10
00FC:  DATA F7,34
00FD:  DATA 74,34
00FE:  DATA A0,35
00FF:  DATA E5,3C
0100:  DATA 20,21
0101:  DATA A0,06
0102:  DATA 0A,00
0103:  DATA 57,39
0104:  DATA 69,3A
0105:  DATA 65,10
0106:  DATA D3,3A
0107:  DATA E3,31
0108:  DATA E5,39
0109:  DATA 73,33
010A:  DATA 75,36
010B:  DATA 0D,05
010C:  DATA 00,01
010D:  DATA 57,39
010E:  DATA 69,3A
010F:  DATA 65,10
0110:  DATA C6,30
0111:  DATA 69,36
0112:  DATA 65,32
0113:  DATA 00,01
0114:  DATA C3,37
0115:  DATA 75,36
0116:  DATA 64,37
0117:  DATA 27,3A
0118:  DATA A0,30
0119:  DATA E3,31
011A:  DATA E5,39
011B:  DATA 73,10
011C:  DATA 62,36
011D:  DATA EF,31
011E:  DATA 6B,10
011F:  DATA 30,3C
0120:  DATA 25,2C
0121:  DATA A0,3B
0122:  DATA F2,34
0123:  DATA F4,32
0124:  DATA 20,33
0125:  DATA E1,34
0126:  DATA EC,32
0127:  DATA 64,00
0128:  DATA C1,3A
0129:  DATA 74,34
012A:  DATA 65,37
012B:  DATA F4,34
012C:  DATA E3,30
012D:  DATA F4,32
012E:  DATA 64,10
012F:  DATA F7,34
0130:  DATA 74,34
0131:  DATA 20,26
0132:  DATA EF,31
0133:  DATA EB,35
0134:  DATA E5,3C
0135:  DATA A0,06
0136:  DATA 0A,00
0137:  DATA 57,39
0138:  DATA 69,3A
0139:  DATA 65,10
013A:  DATA D3,3A
013B:  DATA E3,31
013C:  DATA E5,39
013D:  DATA 73,33
013E:  DATA 75,36
013F:  DATA 0D,05
0140:  DATA 00,01
0141:  DATA 57,39
0142:  DATA 69,3A
0143:  DATA 65,10
0144:  DATA E6,30
0145:  DATA 69,36
0146:  DATA 65,32
0147:  DATA 0D,05
0148:  DATA 00,01
0149:  DATA 8A,2B
014A:  DATA F2,34
014B:  DATA F4,32
014C:  DATA 20,33
014D:  DATA E1,34
014E:  DATA EC,32
014F:  DATA 64,16
0150:  DATA A0,3B
0151:  DATA F2,37
0152:  DATA EE,33
0153:  DATA A0,35
0154:  DATA E5,3C
0155:  DATA A0,39
0156:  DATA 75,38
0157:  DATA 70,36
0158:  DATA E9,32
0159:  DATA 64,10
015A:  DATA 0D,05
015B:  DATA 00,00
015C:  DATA C1,3A
015D:  DATA 74,34
015E:  DATA 65,37
015F:  DATA F4,34
0160:  DATA E3,30
0161:  DATA F4,32
0162:  DATA 64,10
0163:  DATA 62,36
0164:  DATA EF,31
0165:  DATA 6B,10
0166:  DATA 30,3C
0167:  DATA 25,19
0168:  DATA 58,10
0169:  DATA F7,34
016A:  DATA 74,34
016B:  DATA 20,26
016C:  DATA EF,31
016D:  DATA EB,25
016E:  DATA E5,3C
016F:  DATA A0,06
0170:  DATA 0A,00
0171:  DATA D2,32
0172:  DATA 61,32
0173:  DATA 20,33
0174:  DATA E1,34
0175:  DATA EC,32
0176:  DATA E4,06
0177:  DATA 0A,00
0178:  DATA 0A,29
0179:  DATA E5,30
017A:  DATA 64,10
017B:  DATA E6,30
017C:  DATA 69,36
017D:  DATA 65,32
017E:  DATA 2C,10
017F:  DATA 77,39
0180:  DATA 6F,37
0181:  DATA 67,10
0182:  DATA EB,32
0183:  DATA 79,10
0184:  DATA F3,3A
0185:  DATA 70,38
0186:  DATA EC,34
0187:  DATA 65,32
0188:  DATA A0,06
0189:  DATA 0A,00
018A:  DATA 0C,10
018B:  DATA 53,3A
018C:  DATA 61,39
018D:  DATA F4,34
018E:  DATA EE,33
018F:  DATA 2E,17
0190:  DATA 2E,00
0191:  DATA 0D,05
0192:  DATA 73,3A
0193:  DATA 61,39
0194:  DATA F4,34
0195:  DATA EE,33
0196:  DATA 2E,17
0197:  DATA 00,01
0198:  DATA 0D,05
0199:  DATA D3,32
019A:  DATA 61,39
019B:  DATA 63,34
019C:  DATA 69,37
019D:  DATA 67,10
019E:  DATA E6,37
019F:  DATA 72,10
01A0:  DATA E3,30
01A1:  DATA 72,32
01A2:  DATA 00,01
01A3:  DATA 0C,10
01A4:  DATA D3,32
01A5:  DATA 61,39
01A6:  DATA 63,34
01A7:  DATA 69,37
01A8:  DATA 67,10
01A9:  DATA E6,37
01AA:  DATA 72,10
01AB:  DATA 0A,39
01AC:  DATA E6,34
01AD:  DATA 64,17
01AE:  DATA 2E,17
01AF:  DATA 00,01
01B0:  DATA 0D,05
01B1:  DATA C6,37
01B2:  DATA 75,37
01B3:  DATA 64,10
01B4:  DATA D4,30
01B5:  DATA 67,1D
01B6:  DATA 20,00
01B7:  DATA 0D,05
01B8:  DATA C6,37
01B9:  DATA 75,37
01BA:  DATA 64,10
01BB:  DATA D4,30
01BC:  DATA 67,1D
01BD:  DATA 20,00
01BE:  DATA 0D,05
01BF:  DATA D3,20
01C0:  DATA 4B,1D
01C1:  DATA 20,18
01C2:  DATA F8,12
01C3:  DATA 32,3C
01C4:  DATA 00,01
01C5:  DATA 0D,05
01C6:  DATA 20,23
01C7:  DATA E1,34
01C8:  DATA EC,32
01C9:  DATA 64,10
01CA:  DATA F4,37
01CB:  DATA 20,39
01CC:  DATA E5,30
01CD:  DATA 64,10
01CE:  DATA E3,30
01CF:  DATA 72,32
01D0:  DATA 00,01
01D1:  DATA 0D,05
01D2:  DATA A0,24
01D3:  DATA EE,31
01D4:  DATA EF,36
01D5:  DATA 70,36
01D6:  DATA 65,3A
01D7:  DATA 65,10
01D8:  DATA D5,24
01D9:  DATA 44,00
01DA:  DATA 0D,05
01DB:  DATA A0,24
01DC:  DATA 73,10
01DD:  DATA 61,10
01DE:  DATA CD,34
01DF:  DATA E6,30
01E0:  DATA F2,32
01E1:  DATA A0,21
01E2:  DATA 61,39
01E3:  DATA 64,05
01E4:  DATA 00,00
*
0351:  MOVF   0B,W
0352:  BCF    0B.7
0353:  MOVLB  10
0354:  BCF    1E.6
0355:  BSF    1E.0
0356:  NOP
0357:  NOP
0358:  BTFSC  09.7
0359:  BSF    0B.7
035A:  MOVF   1C,W
035B:  ANDLW  7F
035C:  BTFSC  03.2
035D:  GOTO   39D
035E:  MOVLB  01
035F:  MOVWF  5B
0360:  MOVLB  10
0361:  MOVF   1A,W
0362:  MOVLB  01
0363:  MOVWF  5C
0364:  MOVLB  10
0365:  MOVF   1B,W
0366:  MOVLB  01
0367:  MOVWF  5D
0368:  MOVF   5B,W
0369:  MOVWF  5E
036A:  MOVLB  00
036B:  CALL   317
036C:  MOVLB  01
036D:  MOVF   5C,W
036E:  MOVLB  10
036F:  MOVWF  1A
0370:  MOVLB  01
0371:  MOVF   5D,W
0372:  MOVLB  10
0373:  MOVWF  1B
0374:  MOVF   0B,W
0375:  BCF    0B.7
0376:  BCF    1E.6
0377:  BSF    1E.0
0378:  NOP
0379:  NOP
037A:  BTFSC  09.7
037B:  BSF    0B.7
037C:  RLF    1C,W
037D:  RLF    1D,W
037E:  ANDLW  7F
037F:  BTFSC  03.2
0380:  GOTO   39D
0381:  MOVLB  01
0382:  MOVWF  5B
0383:  MOVLB  10
0384:  MOVF   1A,W
0385:  MOVLB  01
0386:  MOVWF  5C
0387:  MOVLB  10
0388:  MOVF   1B,W
0389:  MOVLB  01
038A:  MOVWF  5D
038B:  MOVF   5B,W
038C:  MOVWF  5E
038D:  MOVLB  00
038E:  CALL   317
038F:  MOVLB  01
0390:  MOVF   5C,W
0391:  MOVLB  10
0392:  MOVWF  1A
0393:  MOVLB  01
0394:  MOVF   5D,W
0395:  MOVLB  10
0396:  MOVWF  1B
0397:  INCF   1A,F
0398:  BTFSC  03.2
0399:  INCF   1B,F
039A:  MOVLB  00
039B:  GOTO   351
039C:  MOVLB  10
039D:  MOVLB  00
039E:  RETURN
*
03CB:  MOVF   0B,W
03CC:  BCF    0B.7
03CD:  MOVLB  10
03CE:  BCF    1E.6
03CF:  BSF    1E.0
03D0:  NOP
03D1:  NOP
03D2:  BTFSC  09.7
03D3:  BSF    0B.7
03D4:  MOVF   1C,W
03D5:  ANDLW  7F
03D6:  BTFSC  03.2
03D7:  GOTO   417
03D8:  MOVLB  02
03D9:  MOVWF  28
03DA:  MOVLB  10
03DB:  MOVF   1A,W
03DC:  MOVLB  02
03DD:  MOVWF  29
03DE:  MOVLB  10
03DF:  MOVF   1B,W
03E0:  MOVLB  02
03E1:  MOVWF  2A
03E2:  MOVF   28,W
03E3:  MOVWF  2B
03E4:  MOVLB  00
03E5:  CALL   39F
03E6:  MOVLB  02
03E7:  MOVF   29,W
03E8:  MOVLB  10
03E9:  MOVWF  1A
03EA:  MOVLB  02
03EB:  MOVF   2A,W
03EC:  MOVLB  10
03ED:  MOVWF  1B
03EE:  MOVF   0B,W
03EF:  BCF    0B.7
03F0:  BCF    1E.6
03F1:  BSF    1E.0
03F2:  NOP
03F3:  NOP
03F4:  BTFSC  09.7
03F5:  BSF    0B.7
03F6:  RLF    1C,W
03F7:  RLF    1D,W
03F8:  ANDLW  7F
03F9:  BTFSC  03.2
03FA:  GOTO   417
03FB:  MOVLB  02
03FC:  MOVWF  28
03FD:  MOVLB  10
03FE:  MOVF   1A,W
03FF:  MOVLB  02
0400:  MOVWF  29
0401:  MOVLB  10
0402:  MOVF   1B,W
0403:  MOVLB  02
0404:  MOVWF  2A
0405:  MOVF   28,W
0406:  MOVWF  2B
0407:  MOVLB  00
0408:  CALL   39F
0409:  MOVLB  02
040A:  MOVF   29,W
040B:  MOVLB  10
040C:  MOVWF  1A
040D:  MOVLB  02
040E:  MOVF   2A,W
040F:  MOVLB  10
0410:  MOVWF  1B
0411:  INCF   1A,F
0412:  BTFSC  03.2
0413:  INCF   1B,F
0414:  MOVLB  00
0415:  GOTO   3CB
0416:  MOVLB  10
0417:  MOVLB  00
0418:  RETURN
*
04C5:  MOVF   0B,W
04C6:  BCF    0B.7
04C7:  MOVLB  10
04C8:  BCF    1E.6
04C9:  BSF    1E.0
04CA:  NOP
04CB:  NOP
04CC:  BTFSC  09.7
04CD:  BSF    0B.7
04CE:  BTFSC  03.0
04CF:  GOTO   4F8
04D0:  MOVF   1C,W
04D1:  ANDLW  7F
04D2:  MOVLB  02
04D3:  MOVWF  28
04D4:  MOVLB  10
04D5:  MOVF   1A,W
04D6:  MOVLB  02
04D7:  MOVWF  29
04D8:  MOVLB  10
04D9:  MOVF   1B,W
04DA:  MOVLB  02
04DB:  MOVWF  2A
04DC:  MOVF   28,W
04DD:  MOVWF  2B
04DE:  MOVLB  00
04DF:  CALL   39F
04E0:  MOVLB  02
04E1:  MOVF   29,W
04E2:  MOVLB  10
04E3:  MOVWF  1A
04E4:  MOVLB  02
04E5:  MOVF   2A,W
04E6:  MOVLB  10
04E7:  MOVWF  1B
04E8:  MOVF   0B,W
04E9:  BCF    0B.7
04EA:  BCF    1E.6
04EB:  BSF    1E.0
04EC:  NOP
04ED:  NOP
04EE:  BTFSC  09.7
04EF:  BSF    0B.7
04F0:  MOVLB  02
04F1:  DECFSZ 27,F
04F2:  GOTO   4F4
04F3:  GOTO   4F6
04F4:  MOVLB  10
04F5:  GOTO   4F8
04F6:  GOTO   51B
04F7:  MOVLB  10
04F8:  RLF    1C,W
04F9:  RLF    1D,W
04FA:  ANDLW  7F
04FB:  MOVLB  02
04FC:  MOVWF  28
04FD:  MOVLB  10
04FE:  MOVF   1A,W
04FF:  MOVLB  02
0500:  MOVWF  29
0501:  MOVLB  10
0502:  MOVF   1B,W
0503:  MOVLB  02
0504:  MOVWF  2A
0505:  MOVF   28,W
0506:  MOVWF  2B
0507:  MOVLB  00
0508:  CALL   39F
0509:  MOVLB  02
050A:  MOVF   29,W
050B:  MOVLB  10
050C:  MOVWF  1A
050D:  MOVLB  02
050E:  MOVF   2A,W
050F:  MOVLB  10
0510:  MOVWF  1B
0511:  INCF   1A,F
0512:  BTFSC  03.2
0513:  INCF   1B,F
0514:  BCF    03.0
0515:  MOVLB  02
0516:  DECFSZ 27,F
0517:  GOTO   519
0518:  GOTO   51B
0519:  MOVLB  00
051A:  GOTO   4C5
051B:  MOVLB  00
051C:  RETURN
051D:  MOVLB  02
051E:  BTFSC  28.7
051F:  GOTO   532
0520:  MOVLW  0F
0521:  MOVWF  77
0522:  SWAPF  27,W
0523:  ANDWF  77,F
0524:  MOVLW  0A
0525:  SUBWF  77,W
0526:  BTFSC  03.0
0527:  GOTO   52B
0528:  MOVLW  30
0529:  ADDWF  77,F
052A:  GOTO   52D
052B:  MOVF   28,W
052C:  ADDWF  77,F
052D:  MOVF   77,W
052E:  MOVWF  2B
052F:  MOVLB  00
0530:  CALL   39F
0531:  MOVLB  02
0532:  MOVLW  0F
0533:  ANDWF  27,F
0534:  MOVLW  0A
0535:  SUBWF  27,W
0536:  BTFSC  03.0
0537:  GOTO   53A
0538:  MOVLW  30
0539:  GOTO   53C
053A:  BCF    28.7
053B:  MOVF   28,W
053C:  ADDWF  27,F
053D:  MOVF   27,W
053E:  MOVWF  2B
053F:  MOVLB  00
0540:  CALL   39F
0541:  RETURN
*
0589:  MOVF   0B,W
058A:  BCF    0B.7
058B:  MOVLB  10
058C:  BCF    1E.6
058D:  BSF    1E.0
058E:  NOP
058F:  NOP
0590:  BTFSC  09.7
0591:  BSF    0B.7
0592:  BTFSC  03.0
0593:  GOTO   5BC
0594:  MOVF   1C,W
0595:  ANDLW  7F
0596:  MOVLB  01
0597:  MOVWF  5B
0598:  MOVLB  10
0599:  MOVF   1A,W
059A:  MOVLB  01
059B:  MOVWF  5C
059C:  MOVLB  10
059D:  MOVF   1B,W
059E:  MOVLB  01
059F:  MOVWF  5D
05A0:  MOVF   5B,W
05A1:  MOVWF  5E
05A2:  MOVLB  00
05A3:  CALL   317
05A4:  MOVLB  01
05A5:  MOVF   5C,W
05A6:  MOVLB  10
05A7:  MOVWF  1A
05A8:  MOVLB  01
05A9:  MOVF   5D,W
05AA:  MOVLB  10
05AB:  MOVWF  1B
05AC:  MOVF   0B,W
05AD:  BCF    0B.7
05AE:  BCF    1E.6
05AF:  BSF    1E.0
05B0:  NOP
05B1:  NOP
05B2:  BTFSC  09.7
05B3:  BSF    0B.7
05B4:  MOVLB  01
05B5:  DECFSZ 5A,F
05B6:  GOTO   5B8
05B7:  GOTO   5BA
05B8:  MOVLB  10
05B9:  GOTO   5BC
05BA:  GOTO   5DC
05BB:  MOVLB  10
05BC:  RLF    1C,W
05BD:  RLF    1D,W
05BE:  ANDLW  7F
05BF:  MOVLB  01
05C0:  MOVWF  5B
05C1:  MOVLB  10
05C2:  MOVF   1A,W
05C3:  MOVLB  01
05C4:  MOVWF  5C
05C5:  MOVLB  10
05C6:  MOVF   1B,W
05C7:  MOVLB  01
05C8:  MOVWF  5D
05C9:  MOVF   5B,W
05CA:  MOVWF  5E
05CB:  MOVLB  00
05CC:  CALL   317
05CD:  MOVLB  01
05CE:  MOVF   5C,W
05CF:  MOVLB  10
05D0:  MOVWF  1A
05D1:  MOVLB  01
05D2:  MOVF   5D,W
05D3:  MOVLB  10
05D4:  MOVWF  1B
05D5:  INCF   1A,F
05D6:  BTFSC  03.2
05D7:  INCF   1B,F
05D8:  BCF    03.0
05D9:  MOVLB  01
05DA:  DECFSZ 5A,F
05DB:  GOTO   589
*
05E0:  BTFSC  5B.7
05E1:  GOTO   5F4
05E2:  MOVLW  0F
05E3:  MOVWF  77
05E4:  SWAPF  5A,W
05E5:  ANDWF  77,F
05E6:  MOVLW  0A
05E7:  SUBWF  77,W
05E8:  BTFSC  03.0
05E9:  GOTO   5ED
05EA:  MOVLW  30
05EB:  ADDWF  77,F
05EC:  GOTO   5EF
05ED:  MOVF   5B,W
05EE:  ADDWF  77,F
05EF:  MOVF   77,W
05F0:  MOVWF  5E
05F1:  MOVLB  00
05F2:  CALL   317
05F3:  MOVLB  01
05F4:  MOVLW  0F
05F5:  ANDWF  5A,F
05F6:  MOVLW  0A
05F7:  SUBWF  5A,W
05F8:  BTFSC  03.0
05F9:  GOTO   5FC
05FA:  MOVLW  30
05FB:  GOTO   5FE
05FC:  BCF    5B.7
05FD:  MOVF   5B,W
05FE:  ADDWF  5A,F
05FF:  MOVF   5A,W
0600:  MOVWF  5E
0601:  MOVLB  00
0602:  CALL   317
*
07D3:  MOVLB  01
07D4:  MOVF   37,W
07D5:  MOVWF  05
07D6:  MOVF   36,W
07D7:  MOVWF  04
07D8:  MOVF   5C,W
07D9:  MOVWI  W,[FSR0++]
07DA:  CLRF   00
07DB:  INCF   36,F
07DC:  BTFSC  03.2
07DD:  INCF   37,F
07DE:  MOVLB  00
07DF:  RETURN
07E0:  MOVF   00,F
07E1:  BTFSC  03.2
07E2:  GOTO   7F5
07E3:  MOVF   05,W
07E4:  MOVLB  01
07E5:  MOVWF  5B
07E6:  MOVF   04,W
07E7:  MOVWF  5A
07E8:  MOVF   00,W
07E9:  MOVLB  02
07EA:  MOVWF  2B
07EB:  MOVLB  00
07EC:  CALL   39F
07ED:  MOVLB  01
07EE:  MOVF   5B,W
07EF:  MOVWF  05
07F0:  MOVF   5A,W
07F1:  MOVWF  04
07F2:  ADDFSR 01,FSR0
07F3:  MOVLB  00
07F4:  GOTO   7E0
07F5:  RETURN
*
0800:  MOVLB  01
0801:  BTFSC  5B.7
0802:  GOTO   017
0803:  MOVLW  0F
0804:  MOVWF  77
0805:  SWAPF  5A,W
0806:  ANDWF  77,F
0807:  MOVLW  0A
0808:  SUBWF  77,W
0809:  BTFSC  03.0
080A:  GOTO   00E
080B:  MOVLW  30
080C:  ADDWF  77,F
080D:  GOTO   010
080E:  MOVF   5B,W
080F:  ADDWF  77,F
0810:  MOVF   77,W
0811:  MOVWF  5C
0812:  MOVLP  00
0813:  MOVLB  00
0814:  CALL   7D3
0815:  MOVLP  08
0816:  MOVLB  01
0817:  MOVLW  0F
0818:  ANDWF  5A,F
0819:  MOVLW  0A
081A:  SUBWF  5A,W
081B:  BTFSC  03.0
081C:  GOTO   01F
081D:  MOVLW  30
081E:  GOTO   021
081F:  BCF    5B.7
0820:  MOVF   5B,W
0821:  ADDWF  5A,F
0822:  MOVF   5A,W
0823:  MOVWF  5C
0824:  MOVLP  00
0825:  MOVLB  00
0826:  CALL   7D3
0827:  MOVLP  08
0828:  RETURN
....................  
.................... #list 
....................  
.................... //#include<18F45K22.h> 
.................... #fuses NOPROTECT,NOLVP,NOWDT 
.................... #use delay(oscillator=4000000) 
*
01E5:  MOVLW  20
01E6:  MOVWF  05
01E7:  MOVLW  CF
01E8:  MOVWF  04
01E9:  MOVF   00,W
01EA:  BTFSC  03.2
01EB:  GOTO   1FA
01EC:  MOVLW  01
01ED:  MOVWF  78
01EE:  CLRF   77
01EF:  DECFSZ 77,F
01F0:  GOTO   1EF
01F1:  DECFSZ 78,F
01F2:  GOTO   1EE
01F3:  MOVLW  4A
01F4:  MOVWF  77
01F5:  DECFSZ 77,F
01F6:  GOTO   1F5
01F7:  GOTO   1F8
01F8:  DECFSZ 00,F
01F9:  GOTO   1EC
01FA:  RETURN
....................  
.................... //pin configuration remapped 
.................... #pin_select SDO1=PIN_C5 
.................... #pin_select TX1=PIN_C6 
....................  
.................... #use rs232( baud=19200, xmit=PIN_C6, rcv=PIN_C7, bits=8,ERRORS) 
*
039F:  BCF    13.6
03A0:  BCF    18.6
03A1:  MOVLW  08
03A2:  MOVWF  78
03A3:  GOTO   3A4
03A4:  NOP
03A5:  BSF    78.7
03A6:  GOTO   3BD
03A7:  BCF    78.7
03A8:  MOVLB  02
03A9:  RRF    2B,F
03AA:  BTFSS  03.0
03AB:  GOTO   3AF
03AC:  MOVLB  00
03AD:  BSF    18.6
03AE:  MOVLB  02
03AF:  BTFSC  03.0
03B0:  GOTO   3B4
03B1:  MOVLB  00
03B2:  BCF    18.6
03B3:  MOVLB  02
03B4:  BSF    78.6
03B5:  GOTO   3BE
03B6:  BCF    78.6
03B7:  DECFSZ 78,F
03B8:  GOTO   3A9
03B9:  GOTO   3BA
03BA:  NOP
03BB:  MOVLB  00
03BC:  BSF    18.6
03BD:  MOVLB  02
03BE:  MOVLW  0A
03BF:  MOVWF  04
03C0:  DECFSZ 04,F
03C1:  GOTO   3C0
03C2:  GOTO   3C3
03C3:  BTFSS  78.7
03C4:  GOTO   3C7
03C5:  MOVLB  00
03C6:  GOTO   3A7
03C7:  BTFSC  78.6
03C8:  GOTO   3B6
03C9:  MOVLB  00
03CA:  RETURN
....................  
.................... //LCD module connections 
.................... #define LCD_RS_PIN PIN_B2 
.................... #define LCD_RW_PIN PIN_B1 
.................... #define LCD_ENABLE_PIN PIN_B3 
.................... #define LCD_DATA4 PIN_B4 
.................... #define LCD_DATA5 PIN_B5 
.................... #define LCD_DATA6 PIN_B6 
.................... #define LCD_DATA7 PIN_B7 
.................... //End LCD module connections 
....................  
.................... #define CS PIN_A5 
....................  
....................  
....................  
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
0262:  BSF    12.4
....................    output_float(LCD_DATA5); 
0263:  BSF    12.5
....................    output_float(LCD_DATA6); 
0264:  BSF    12.6
....................    output_float(LCD_DATA7); 
0265:  BSF    12.7
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
0266:  BSF    17.1
0267:  BCF    12.1
....................    delay_cycles(1); 
0268:  NOP
....................    lcd_output_enable(1); 
0269:  BSF    17.3
026A:  BCF    12.3
....................    delay_cycles(1); 
026B:  NOP
....................    high = lcd_read_nibble(); 
026C:  CALL   22A
026D:  MOVF   78,W
026E:  MOVLB  01
026F:  MOVWF  66
....................        
....................    lcd_output_enable(0); 
0270:  MOVLB  00
0271:  BCF    17.3
0272:  BCF    12.3
....................    delay_cycles(1); 
0273:  NOP
....................    lcd_output_enable(1); 
0274:  BSF    17.3
0275:  BCF    12.3
....................    delay_us(1); 
0276:  NOP
....................    low = lcd_read_nibble(); 
0277:  CALL   22A
0278:  MOVF   78,W
0279:  MOVLB  01
027A:  MOVWF  65
....................        
....................    lcd_output_enable(0); 
027B:  MOVLB  00
027C:  BCF    17.3
027D:  BCF    12.3
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
027E:  BCF    12.4
....................    output_drive(LCD_DATA5); 
027F:  BCF    12.5
....................    output_drive(LCD_DATA6); 
0280:  BCF    12.6
....................    output_drive(LCD_DATA7); 
0281:  BCF    12.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0282:  MOVLB  01
0283:  SWAPF  66,W
0284:  MOVWF  77
0285:  MOVLW  F0
0286:  ANDWF  77,F
0287:  MOVF   77,W
0288:  IORWF  65,W
0289:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
022A:  MOVLB  01
022B:  CLRF   67
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
022C:  MOVLB  00
022D:  BSF    12.4
022E:  MOVLW  00
022F:  BTFSC  0D.4
0230:  MOVLW  01
0231:  MOVLB  01
0232:  IORWF  67,F
....................    n |= input(LCD_DATA5) << 1; 
0233:  MOVLB  00
0234:  BSF    12.5
0235:  MOVLW  00
0236:  BTFSC  0D.5
0237:  MOVLW  01
0238:  MOVWF  77
0239:  BCF    03.0
023A:  RLF    77,F
023B:  MOVF   77,W
023C:  MOVLB  01
023D:  IORWF  67,F
....................    n |= input(LCD_DATA6) << 2; 
023E:  MOVLB  00
023F:  BSF    12.6
0240:  MOVLW  00
0241:  BTFSC  0D.6
0242:  MOVLW  01
0243:  MOVWF  77
0244:  RLF    77,F
0245:  RLF    77,F
0246:  MOVLW  FC
0247:  ANDWF  77,F
0248:  MOVF   77,W
0249:  MOVLB  01
024A:  IORWF  67,F
....................    n |= input(LCD_DATA7) << 3; 
024B:  MOVLB  00
024C:  BSF    12.7
024D:  MOVLW  00
024E:  BTFSC  0D.7
024F:  MOVLW  01
0250:  MOVWF  77
0251:  RLF    77,F
0252:  RLF    77,F
0253:  RLF    77,F
0254:  MOVLW  F8
0255:  ANDWF  77,F
0256:  MOVF   77,W
0257:  MOVLB  01
0258:  IORWF  67,F
....................     
....................    return(n); 
0259:  MOVF   67,W
025A:  MOVWF  78
....................   #else 
025B:  MOVLB  00
025C:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
01FB:  MOVLB  01
01FC:  BTFSC  66.0
01FD:  GOTO   202
01FE:  MOVLB  00
01FF:  BCF    17.4
0200:  GOTO   204
0201:  MOVLB  01
0202:  MOVLB  00
0203:  BSF    17.4
0204:  BCF    12.4
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
0205:  MOVLB  01
0206:  BTFSC  66.1
0207:  GOTO   20C
0208:  MOVLB  00
0209:  BCF    17.5
020A:  GOTO   20E
020B:  MOVLB  01
020C:  MOVLB  00
020D:  BSF    17.5
020E:  BCF    12.5
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
020F:  MOVLB  01
0210:  BTFSC  66.2
0211:  GOTO   216
0212:  MOVLB  00
0213:  BCF    17.6
0214:  GOTO   218
0215:  MOVLB  01
0216:  MOVLB  00
0217:  BSF    17.6
0218:  BCF    12.6
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
0219:  MOVLB  01
021A:  BTFSC  66.3
021B:  GOTO   220
021C:  MOVLB  00
021D:  BCF    17.7
021E:  GOTO   222
021F:  MOVLB  01
0220:  MOVLB  00
0221:  BSF    17.7
0222:  BCF    12.7
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
0223:  NOP
....................    lcd_output_enable(1); 
0224:  BSF    17.3
0225:  BCF    12.3
....................    delay_us(2); 
0226:  GOTO   227
....................    lcd_output_enable(0); 
0227:  BCF    17.3
0228:  BCF    12.3
0229:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
025D:  BCF    12.3
....................    lcd_rs_tris(); 
025E:  BCF    12.2
....................    lcd_rw_tris(); 
025F:  BCF    12.1
....................   #endif 
....................  
....................    lcd_output_rs(0); 
0260:  BCF    17.2
0261:  BCF    12.2
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
028A:  MOVF   78,W
028B:  MOVWF  65
028C:  BTFSS  65.7
028D:  GOTO   290
028E:  MOVLB  00
028F:  GOTO   262
....................    lcd_output_rs(address); 
0290:  MOVF   63,F
0291:  BTFSS  03.2
0292:  GOTO   297
0293:  MOVLB  00
0294:  BCF    17.2
0295:  GOTO   299
0296:  MOVLB  01
0297:  MOVLB  00
0298:  BSF    17.2
0299:  BCF    12.2
....................    delay_cycles(1); 
029A:  NOP
....................    lcd_output_rw(0); 
029B:  BCF    17.1
029C:  BCF    12.1
....................    delay_cycles(1); 
029D:  NOP
....................    lcd_output_enable(0); 
029E:  BCF    17.3
029F:  BCF    12.3
....................    lcd_send_nibble(n >> 4); 
02A0:  MOVLB  01
02A1:  SWAPF  64,W
02A2:  MOVWF  65
02A3:  MOVLW  0F
02A4:  ANDWF  65,F
02A5:  MOVF   65,W
02A6:  MOVWF  66
02A7:  MOVLB  00
02A8:  CALL   1FB
....................    lcd_send_nibble(n & 0xf); 
02A9:  MOVLB  01
02AA:  MOVF   64,W
02AB:  ANDLW  0F
02AC:  MOVWF  65
02AD:  MOVWF  66
02AE:  MOVLB  00
02AF:  CALL   1FB
02B0:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
02B1:  MOVLW  28
02B2:  MOVLB  01
02B3:  MOVWF  5A
02B4:  MOVLW  0C
02B5:  MOVWF  5B
02B6:  MOVLW  01
02B7:  MOVWF  5C
02B8:  MOVLW  06
02B9:  MOVWF  5D
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
02BA:  MOVLB  00
02BB:  BCF    17.3
02BC:  BCF    12.3
....................    lcd_output_rs(0); 
02BD:  BCF    17.2
02BE:  BCF    12.2
....................    lcd_output_rw(0); 
02BF:  BCF    17.1
02C0:  BCF    12.1
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
02C1:  BCF    12.4
....................    output_drive(LCD_DATA5); 
02C2:  BCF    12.5
....................    output_drive(LCD_DATA6); 
02C3:  BCF    12.6
....................    output_drive(LCD_DATA7); 
02C4:  BCF    12.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
02C5:  BCF    12.3
....................    lcd_rs_tris(); 
02C6:  BCF    12.2
....................    lcd_rw_tris(); 
02C7:  BCF    12.1
....................  #endif 
....................      
....................    delay_ms(15); 
02C8:  MOVLW  0F
02C9:  MOVLB  02
02CA:  MOVWF  4F
02CB:  MOVLB  00
02CC:  CALL   1E5
....................    for(i=1;i<=3;++i) 
02CD:  MOVLW  01
02CE:  MOVLB  01
02CF:  MOVWF  59
02D0:  MOVF   59,W
02D1:  SUBLW  03
02D2:  BTFSS  03.0
02D3:  GOTO   2E0
....................    { 
....................        lcd_send_nibble(3); 
02D4:  MOVLW  03
02D5:  MOVWF  66
02D6:  MOVLB  00
02D7:  CALL   1FB
....................        delay_ms(5); 
02D8:  MOVLW  05
02D9:  MOVLB  02
02DA:  MOVWF  4F
02DB:  MOVLB  00
02DC:  CALL   1E5
02DD:  MOVLB  01
02DE:  INCF   59,F
02DF:  GOTO   2D0
....................    } 
....................     
....................    lcd_send_nibble(2); 
02E0:  MOVLW  02
02E1:  MOVWF  66
02E2:  MOVLB  00
02E3:  CALL   1FB
....................    delay_ms(5); 
02E4:  MOVLW  05
02E5:  MOVLB  02
02E6:  MOVWF  4F
02E7:  MOVLB  00
02E8:  CALL   1E5
....................    for(i=0;i<=3;++i) 
02E9:  MOVLB  01
02EA:  CLRF   59
02EB:  MOVF   59,W
02EC:  SUBLW  03
02ED:  BTFSS  03.0
02EE:  GOTO   300
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
02EF:  MOVLW  8A
02F0:  ADDWF  59,W
02F1:  MOVWF  04
02F2:  MOVLW  20
02F3:  MOVWF  05
02F4:  BTFSC  03.0
02F5:  INCF   05,F
02F6:  MOVF   00,W
02F7:  MOVWF  5E
02F8:  CLRF   63
02F9:  MOVF   5E,W
02FA:  MOVWF  64
02FB:  MOVLB  00
02FC:  CALL   25D
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
02FD:  MOVLB  01
02FE:  INCF   59,F
02FF:  GOTO   2EB
0300:  MOVLP  08
0301:  MOVLB  00
0302:  GOTO   65C (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
0303:  MOVLB  01
0304:  DECFSZ 60,W
0305:  GOTO   307
0306:  GOTO   30A
....................       address=LCD_LINE_TWO; 
0307:  MOVLW  40
0308:  MOVWF  61
0309:  GOTO   30B
....................    else 
....................       address=0; 
030A:  CLRF   61
....................       
....................    address+=x-1; 
030B:  MOVLW  01
030C:  SUBWF  5F,W
030D:  ADDWF  61,F
....................    lcd_send_byte(0,0x80|address); 
030E:  MOVF   61,W
030F:  IORLW  80
0310:  MOVWF  62
0311:  CLRF   63
0312:  MOVF   62,W
0313:  MOVWF  64
0314:  MOVLB  00
0315:  CALL   25D
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0316:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
0317:  MOVLB  01
0318:  MOVF   5E,W
0319:  XORLW  07
031A:  MOVLB  00
031B:  BTFSC  03.2
031C:  GOTO   327
031D:  XORLW  0B
031E:  BTFSC  03.2
031F:  GOTO   32E
0320:  XORLW  06
0321:  BTFSC  03.2
0322:  GOTO   33A
0323:  XORLW  02
0324:  BTFSC  03.2
0325:  GOTO   342
0326:  GOTO   349
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
0327:  MOVLW  01
0328:  MOVLB  01
0329:  MOVWF  5F
032A:  MOVWF  60
032B:  MOVLB  00
032C:  CALL   303
032D:  GOTO   350
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
032E:  MOVLB  01
032F:  CLRF   63
0330:  MOVLW  01
0331:  MOVWF  64
0332:  MOVLB  00
0333:  CALL   25D
....................                      delay_ms(2); 
0334:  MOVLW  02
0335:  MOVLB  02
0336:  MOVWF  4F
0337:  MOVLB  00
0338:  CALL   1E5
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
0339:  GOTO   350
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
033A:  MOVLW  01
033B:  MOVLB  01
033C:  MOVWF  5F
033D:  MOVLW  02
033E:  MOVWF  60
033F:  MOVLB  00
0340:  CALL   303
0341:  GOTO   350
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
0342:  MOVLB  01
0343:  CLRF   63
0344:  MOVLW  10
0345:  MOVWF  64
0346:  MOVLB  00
0347:  CALL   25D
0348:  GOTO   350
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
0349:  MOVLW  01
034A:  MOVLB  01
034B:  MOVWF  63
034C:  MOVF   5E,W
034D:  MOVWF  64
034E:  MOVLB  00
034F:  CALL   25D
....................      #endif 
....................    } 
0350:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... //spi modes 
.................... #define SPI_MODE_0  (SPI_L_TO_H | SPI_XMIT_L_TO_H) 
.................... #define SPI_MODE_1  (SPI_L_TO_H) 
.................... #define SPI_MODE_2  (SPI_H_TO_L) 
.................... #define SPI_MODE_3  (SPI_H_TO_L | SPI_XMIT_L_TO_H) 
....................  
.................... #include "rfid.h" 
.................... /*  
....................  * File:   rfid.h 
....................  * Author: Shashikant 
....................  * 
....................  * Created on 2 July, 2018, 1:34 PM 
....................  */ 
....................  
.................... #ifndef RFID_H 
.................... #define	RFID_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................  
....................  
....................  
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* RFID_H */ 
....................  
.................... #define     MAX_LEN               16        // Maximum length of an array. CHECK IF IT IS MAXIMUM LENGTH/SIZE OF FIFO!!!!!!!!!!! 
....................  
.................... //MF522 MFRC522 error codes. 
.................... #define     MI_OK                 0         // Everything A-OK. 
.................... #define     MI_NOTAGERR           1         // No tag error 
.................... #define     MI_ERR                2         // General error 
....................  
.................... //MF522 Command word 
.................... #define     MFRC522_IDLE          0x00      // NO action; Cancel the current command 
.................... #define     MFRC522_MEM           0x01      // Store 25 byte into the internal buffer. 
.................... #define     MFRC522_GENID         0x02      // Generates a 10 byte random ID number. 
.................... #define     MFRC522_CALCCRC       0x03      // CRC Calculate or selftest. 
.................... #define     MFRC522_TRANSMIT      0x04      // Transmit data 
.................... #define     MFRC522_NOCMDCH       0x07      // No command change. 
.................... #define     MFRC522_RECEIVE       0x08      // Receive Data 
.................... #define     MFRC522_TRANSCEIVE    0x0C      // Transmit and receive data, 
.................... #define     MFRC522_AUTHENT       0x0E      // Authentication Key 
.................... #define     MFRC522_SOFTRESET     0x0F      // Reset 
....................  
.................... //Mifare_One tag command word 
.................... #define     MF1_REQIDL            0x26      // find the antenna area does not enter hibernation 
.................... #define     MF1_REQALL            0x52      // find all the tags antenna area 
.................... #define     MF1_ANTICOLL          0x93      // anti-collision 
.................... #define     MF1_SELECTTAG         0x93      // election tag 
.................... #define     MF1_AUTHENT1A         0x60      // authentication key A 
.................... #define     MF1_AUTHENT1B         0x61      // authentication key B 
.................... #define     MF1_READ              0x30      // Read Block 
.................... #define     MF1_WRITE             0xA0      // write block 
.................... #define     MF1_DECREMENT         0xC0      // debit 
.................... #define     MF1_INCREMENT         0xC1      // recharge 
.................... #define     MF1_RESTORE           0xC2      // transfer block data to the buffer 
.................... #define     MF1_TRANSFER          0xB0      // save the data in the buffer 
.................... #define     MF1_HALT              0x50      // Sleep 
....................  
....................  
.................... //------------------ MFRC522 registers--------------- 
.................... //Page 0:Command and Status 
.................... #define     Reserved00            0x00 
.................... #define     CommandReg            0x01 
.................... #define     CommIEnReg            0x02 
.................... #define     DivIEnReg             0x03 
.................... #define     CommIrqReg            0x04 
.................... #define     DivIrqReg             0x05 
.................... #define     ErrorReg              0x06 
.................... #define     Status1Reg            0x07 
.................... #define     Status2Reg            0x08 
.................... #define     FIFODataReg           0x09 
.................... #define     FIFOLevelReg          0x0A 
.................... #define     WaterLevelReg         0x0B 
.................... #define     ControlReg            0x0C 
.................... #define     BitFramingReg         0x0D 
.................... #define     CollReg               0x0E 
.................... #define     Reserved01            0x0F 
.................... //Page 1:Command 
.................... #define     Reserved10            0x10 
.................... #define     ModeReg               0x11 
.................... #define     TxModeReg             0x12 
.................... #define     RxModeReg             0x13 
.................... #define     TxControlReg          0x14 
.................... #define     TxAutoReg             0x15 
.................... #define     TxSelReg              0x16 
.................... #define     RxSelReg              0x17 
.................... #define     RxThresholdReg        0x18 
.................... #define     DemodReg              0x19 
.................... #define     Reserved11            0x1A 
.................... #define     Reserved12            0x1B 
.................... #define     MifareReg             0x1C 
.................... #define     Reserved13            0x1D 
.................... #define     Reserved14            0x1E 
.................... #define     SerialSpeedReg        0x1F 
.................... //Page 2:CFG 
.................... #define     Reserved20            0x20 
.................... #define     CRCResultRegM         0x21 
.................... #define     CRCResultRegL         0x22 
.................... #define     Reserved21            0x23 
.................... #define     ModWidthReg           0x24 
.................... #define     Reserved22            0x25 
.................... #define     RFCfgReg              0x26 
.................... #define     GsNReg                0x27 
.................... #define     CWGsPReg              0x28 
.................... #define     ModGsPReg             0x29 
.................... #define     TModeReg              0x2A 
.................... #define     TPrescalerReg         0x2B 
.................... #define     TReloadRegH           0x2C 
.................... #define     TReloadRegL           0x2D 
.................... #define     TCounterValueRegH     0x2E 
.................... #define     TCounterValueRegL     0x2F 
.................... //Page 3:TestRegister 
.................... #define     Reserved30            0x30 
.................... #define     TestSel1Reg           0x31 
.................... #define     TestSel2Reg           0x32 
.................... #define     TestPinEnReg          0x33 
.................... #define     TestPinValueReg       0x34 
.................... #define     TestBusReg            0x35 
.................... #define     AutoTestReg           0x36 
.................... #define     VersionReg            0x37 
.................... #define     AnalogTestReg         0x38 
.................... #define     TestDAC1Reg           0x39 
.................... #define     TestDAC2Reg           0x3A 
.................... #define     TestADCReg            0x3B 
.................... #define     Reserved31            0x3C 
.................... #define     Reserved32            0x3D 
.................... #define     Reserved33            0x3E 
.................... #define     Reserved34            0x3F 
.................... //-----------------------------------------------  
....................  
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Writes value to a register. 
....................   @param   addr  The address a register. 
....................   @param   val   The value to write to a register. 
....................  */ 
.................... /**************************************************************************/ 
.................... void writeToRegister(byte addr, byte val) { 
....................   output_low(CS); 
*
0419:  BCF    11.5
041A:  BCF    16.5
....................   //Address format: 0XXXXXX0 
....................   spi_write((addr<<1)&0x7E); 
041B:  BCF    03.0
041C:  MOVLB  02
041D:  RLF    53,W
041E:  ANDLW  7E
041F:  MOVWF  55
0420:  MOVLB  03
0421:  MOVF   0C,W
0422:  MOVLB  02
0423:  MOVF   55,W
0424:  MOVLB  03
0425:  MOVWF  0C
0426:  RRF    0F,W
0427:  BTFSS  03.0
0428:  GOTO   426
....................   spi_write(val); 
0429:  MOVF   0C,W
042A:  MOVLB  02
042B:  MOVF   54,W
042C:  MOVLB  03
042D:  MOVWF  0C
042E:  RRF    0F,W
042F:  BTFSS  03.0
0430:  GOTO   42E
....................   output_high(CS); 
0431:  MOVLB  00
0432:  BCF    11.5
0433:  BSF    16.5
0434:  RETURN
.................... } 
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Reads the value at a register. 
....................   @param   addr  The address a register. 
....................   @returns The byte at the register. 
....................  */ 
.................... /**************************************************************************/ 
.................... byte readFromRegister(byte addr) { 
....................   byte val; 
....................   output_low(CS); 
0435:  BCF    11.5
0436:  BCF    16.5
....................   spi_write(((addr<<1)&0x7E) | 0x80); 
0437:  BCF    03.0
0438:  MOVLB  02
0439:  RLF    52,W
043A:  ANDLW  7E
043B:  IORLW  80
043C:  MOVWF  54
043D:  MOVLB  03
043E:  MOVF   0C,W
043F:  MOVLB  02
0440:  MOVF   54,W
0441:  MOVLB  03
0442:  MOVWF  0C
0443:  RRF    0F,W
0444:  BTFSS  03.0
0445:  GOTO   443
....................   val =spi_read(0x00); 
0446:  MOVF   0C,W
0447:  CLRF   0C
0448:  RRF    0F,W
0449:  BTFSS  03.0
044A:  GOTO   448
044B:  MOVF   0C,W
044C:  MOVLB  02
044D:  MOVWF  53
....................   output_high(CS); 
044E:  MOVLB  00
044F:  BCF    11.5
0450:  BSF    16.5
....................   return val; 
0451:  MOVLB  02
0452:  MOVF   53,W
0453:  MOVWF  78
0454:  MOVLB  00
0455:  RETURN
.................... } 
....................  
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Adds a bitmask to a register. 
....................   @param   addr   The address a register. 
....................   @param   mask  The mask to update the register with. 
....................  */ 
.................... /**************************************************************************/ 
.................... void setBitMask(byte addr, byte mask) { 
....................   byte current; 
....................   current = readFromRegister(addr); 
0456:  MOVLB  02
0457:  MOVF   4F,W
0458:  MOVWF  52
0459:  MOVLB  00
045A:  CALL   435
045B:  MOVF   78,W
045C:  MOVLB  02
045D:  MOVWF  51
....................   writeToRegister(addr, current | mask); 
045E:  MOVF   51,W
045F:  IORWF  50,W
0460:  MOVWF  52
0461:  MOVF   4F,W
0462:  MOVWF  53
0463:  MOVF   52,W
0464:  MOVWF  54
0465:  MOVLB  00
0466:  CALL   419
0467:  RETURN
.................... } 
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Removes a bitmask from the register. 
....................   @param   reg   The address a register. 
....................   @param   mask  The mask to update the register with. 
....................  */ 
.................... /**************************************************************************/ 
.................... void clearBitMask(byte addr, byte mask) { 
....................   byte current; 
....................   current = readFromRegister(addr); 
*
0633:  MOVLB  02
0634:  MOVF   4F,W
0635:  MOVWF  52
0636:  MOVLB  00
0637:  CALL   435
0638:  MOVF   78,W
0639:  MOVLB  02
063A:  MOVWF  51
....................   writeToRegister(addr, current & (~mask)); 
063B:  MOVF   50,W
063C:  XORLW  FF
063D:  ANDWF  51,W
063E:  MOVWF  52
063F:  MOVF   4F,W
0640:  MOVWF  53
0641:  MOVF   52,W
0642:  MOVWF  54
0643:  MOVLB  00
0644:  CALL   419
0645:  RETURN
.................... } 
....................  
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Sends a SOFTRESET command to the MFRC522 chip. 
....................  */ 
.................... /**************************************************************************/ 
.................... void reset() { 
....................   writeToRegister(CommandReg, MFRC522_SOFTRESET); 
*
046A:  MOVLW  01
046B:  MOVLB  02
046C:  MOVWF  53
046D:  MOVLW  0F
046E:  MOVWF  54
046F:  MOVLB  00
0470:  CALL   419
.................... } 
....................  
....................  
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Does the setup for the MFRC522. 
....................  */ 
.................... /**************************************************************************/ 
.................... void MFRC_begin() { 
....................   output_high(CS); 
*
0468:  BCF    11.5
0469:  BSF    16.5
....................   reset(); 
....................   //Timer: TPrescaler*TreloadVal/6.78MHz = 24ms 
....................   writeToRegister(TModeReg, 0x8D);    
*
0471:  MOVLW  2A
0472:  MOVLB  02
0473:  MOVWF  53
0474:  MOVLW  8D
0475:  MOVWF  54
0476:  MOVLB  00
0477:  CALL   419
....................   delay_ms(20); // Tauto=1; f(Timer) = 6.78MHz/TPreScaler 
0478:  MOVLW  14
0479:  MOVLB  02
047A:  MOVWF  4F
047B:  MOVLB  00
047C:  CALL   1E5
....................   writeToRegister(TPrescalerReg, 0x3E);  // TModeReg[3..0] + TPrescalerReg 
047D:  MOVLW  2B
047E:  MOVLB  02
047F:  MOVWF  53
0480:  MOVLW  3E
0481:  MOVWF  54
0482:  MOVLB  00
0483:  CALL   419
....................   delay_ms(20); 
0484:  MOVLW  14
0485:  MOVLB  02
0486:  MOVWF  4F
0487:  MOVLB  00
0488:  CALL   1E5
....................   writeToRegister(TReloadRegL, 30); 
0489:  MOVLW  2D
048A:  MOVLB  02
048B:  MOVWF  53
048C:  MOVLW  1E
048D:  MOVWF  54
048E:  MOVLB  00
048F:  CALL   419
....................   delay_ms(20); 
0490:  MOVLW  14
0491:  MOVLB  02
0492:  MOVWF  4F
0493:  MOVLB  00
0494:  CALL   1E5
....................   writeToRegister(TReloadRegH, 0); 
0495:  MOVLW  2C
0496:  MOVLB  02
0497:  MOVWF  53
0498:  CLRF   54
0499:  MOVLB  00
049A:  CALL   419
....................   delay_ms(20); 
049B:  MOVLW  14
049C:  MOVLB  02
049D:  MOVWF  4F
049E:  MOVLB  00
049F:  CALL   1E5
....................   writeToRegister(TxAutoReg, 0x40);      // 100%ASK 
04A0:  MOVLW  15
04A1:  MOVLB  02
04A2:  MOVWF  53
04A3:  MOVLW  40
04A4:  MOVWF  54
04A5:  MOVLB  00
04A6:  CALL   419
....................   delay_ms(20); 
04A7:  MOVLW  14
04A8:  MOVLB  02
04A9:  MOVWF  4F
04AA:  MOVLB  00
04AB:  CALL   1E5
....................   writeToRegister(ModeReg, 0x3D);        // CRC initial value 0x6363 
04AC:  MOVLW  11
04AD:  MOVLB  02
04AE:  MOVWF  53
04AF:  MOVLW  3D
04B0:  MOVWF  54
04B1:  MOVLB  00
04B2:  CALL   419
....................   delay_ms(20); 
04B3:  MOVLW  14
04B4:  MOVLB  02
04B5:  MOVWF  4F
04B6:  MOVLB  00
04B7:  CALL   1E5
....................  //writeToRegister(TxControlReg, 0x82);      
....................   delay_ms(20); 
04B8:  MOVLW  14
04B9:  MOVLB  02
04BA:  MOVWF  4F
04BB:  MOVLB  00
04BC:  CALL   1E5
....................  setBitMask(TxControlReg, 0x03);        // Turn antenna on. 
04BD:  MOVLW  14
04BE:  MOVLB  02
04BF:  MOVWF  4F
04C0:  MOVLW  03
04C1:  MOVWF  50
04C2:  MOVLB  00
04C3:  CALL   456
04C4:  RETURN
.................... } 
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Checks the firmware version of the chip. 
....................   @returns The firmware version of the MFRC522 chip. 
....................  */ 
.................... /**************************************************************************/ 
.................... byte getFirmwareVersion() { 
....................   byte response; 
....................   response = readFromRegister(VersionReg); 
....................   return response; 
.................... } 
....................  
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................  
....................   @brief   Sends a command to a tag. 
....................  
....................   @param   cmd     The command to the MFRC522 to send a command to the tag. 
....................   @param   data    The data that is needed to complete the command. 
....................   @param   dlen    The length of the data. 
....................   @param   result  The result returned by the tag. 
....................   @param   rlen    The number of valid bits in the resulting value. 
....................  
....................   @returns Returns the status of the calculation. 
....................            MI_ERR        if something went wrong, 
....................            MI_NOTAGERR   if there was no tag to send the command to. 
....................            MI_OK         if everything went OK. 
....................  
....................  */ 
.................... /**************************************************************************/ 
....................  
.................... int commandTag(byte cmd, byte *data, int dlen, byte *result, int *rlen) { 
*
0646:  MOVLW  02
0647:  MOVLB  02
0648:  MOVWF  48
0649:  CLRF   49
064A:  CLRF   4A
....................   int status = MI_ERR; 
....................   byte irqEn = 0x00; 
....................   byte waitIRq = 0x00; 
....................   byte lastBits, n; 
....................   int i; 
....................  
....................   switch (cmd) { 
064B:  MOVF   40,W
064C:  XORLW  0E
064D:  MOVLB  00
064E:  BTFSC  03.2
064F:  GOTO   654
0650:  XORLW  02
0651:  BTFSC  03.2
0652:  GOTO   65A
0653:  GOTO   661
....................   case MFRC522_AUTHENT: 
....................     irqEn = 0x12; 
0654:  MOVLW  12
0655:  MOVLB  02
0656:  MOVWF  49
....................     waitIRq = 0x10; 
0657:  MOVLW  10
0658:  MOVWF  4A
....................     break; 
0659:  GOTO   662
....................   case MFRC522_TRANSCEIVE: 
....................     irqEn = 0x77; 
065A:  MOVLW  77
065B:  MOVLB  02
065C:  MOVWF  49
....................     waitIRq = 0x30; 
065D:  MOVLW  30
065E:  MOVWF  4A
....................     break; 
065F:  GOTO   662
0660:  MOVLB  00
....................   default: 
....................     break; 
0661:  MOVLB  02
....................   } 
....................  
....................   writeToRegister(CommIEnReg, irqEn|0x80);    // interrupt request 
0662:  MOVF   49,W
0663:  IORLW  80
0664:  MOVWF  4F
0665:  MOVLW  02
0666:  MOVWF  53
0667:  MOVF   4F,W
0668:  MOVWF  54
0669:  MOVLB  00
066A:  CALL   419
....................   clearBitMask(CommIrqReg, 0x80);             // Clear all interrupt requests bits. 
066B:  MOVLW  04
066C:  MOVLB  02
066D:  MOVWF  4F
066E:  MOVLW  80
066F:  MOVWF  50
0670:  MOVLB  00
0671:  CALL   633
....................   setBitMask(FIFOLevelReg, 0x80);             // FlushBuffer=1, FIFO initialization. 
0672:  MOVLW  0A
0673:  MOVLB  02
0674:  MOVWF  4F
0675:  MOVLW  80
0676:  MOVWF  50
0677:  MOVLB  00
0678:  CALL   456
....................  
....................   writeToRegister(CommandReg, MFRC522_IDLE);  // No action, cancel the current command. 
0679:  MOVLW  01
067A:  MOVLB  02
067B:  MOVWF  53
067C:  CLRF   54
067D:  MOVLB  00
067E:  CALL   419
....................  
....................   // Write to FIFO 
....................   for (i=0; i < dlen; i++) { 
067F:  MOVLB  02
0680:  CLRF   4D
0681:  MOVF   43,W
0682:  SUBWF  4D,W
0683:  BTFSC  03.0
0684:  GOTO   696
....................     writeToRegister(FIFODataReg, data[i]); 
0685:  MOVF   4D,W
0686:  ADDWF  41,W
0687:  MOVWF  04
0688:  MOVLW  00
0689:  ADDWFC 42,W
068A:  MOVWF  05
068B:  MOVF   00,W
068C:  MOVWF  4F
068D:  MOVLW  09
068E:  MOVWF  53
068F:  MOVF   4F,W
0690:  MOVWF  54
0691:  MOVLB  00
0692:  CALL   419
0693:  MOVLB  02
0694:  INCF   4D,F
0695:  GOTO   681
....................   } 
....................  
....................   // Execute the command. 
....................   writeToRegister(CommandReg, cmd); 
0696:  MOVLW  01
0697:  MOVWF  53
0698:  MOVF   40,W
0699:  MOVWF  54
069A:  MOVLB  00
069B:  CALL   419
....................   if (cmd == MFRC522_TRANSCEIVE) { 
069C:  MOVLB  02
069D:  MOVF   40,W
069E:  SUBLW  0C
069F:  BTFSS  03.2
06A0:  GOTO   6A8
....................     setBitMask(BitFramingReg, 0x80);  // StartSend=1, transmission of data starts 
06A1:  MOVLW  0D
06A2:  MOVWF  4F
06A3:  MOVLW  80
06A4:  MOVWF  50
06A5:  MOVLB  00
06A6:  CALL   456
06A7:  MOVLB  02
....................   } 
....................  
....................   // Waiting for the command to complete so we can receive data. 
....................   i = 25; // Max wait time is 25ms. 
06A8:  MOVLW  19
06A9:  MOVWF  4D
....................   do { 
....................     delay_ms(1); 
06AA:  MOVLW  01
06AB:  MOVWF  4F
06AC:  MOVLB  00
06AD:  CALL   1E5
....................     // CommIRqReg[7..0] 
....................     // Set1 TxIRq RxIRq IdleIRq HiAlerIRq LoAlertIRq ErrIRq TimerIRq 
....................     n = readFromRegister(CommIrqReg); 
06AE:  MOVLW  04
06AF:  MOVLB  02
06B0:  MOVWF  52
06B1:  MOVLB  00
06B2:  CALL   435
06B3:  MOVF   78,W
06B4:  MOVLB  02
06B5:  MOVWF  4C
....................     i--; 
06B6:  DECF   4D,F
....................   } while ((i!=0) && !(n&0x01) && !(n&waitIRq)); 
06B7:  MOVF   4D,F
06B8:  BTFSC  03.2
06B9:  GOTO   6C0
06BA:  BTFSC  4C.0
06BB:  GOTO   6C0
06BC:  MOVF   4C,W
06BD:  ANDWF  4A,W
06BE:  BTFSC  03.2
06BF:  GOTO   6AA
....................  
....................   clearBitMask(BitFramingReg, 0x80);  // StartSend=0 
06C0:  MOVLW  0D
06C1:  MOVWF  4F
06C2:  MOVLW  80
06C3:  MOVWF  50
06C4:  MOVLB  00
06C5:  CALL   633
....................  
....................   if (i != 0) { // Request did not time out. 
06C6:  MOVLB  02
06C7:  MOVF   4D,F
06C8:  BTFSC  03.2
06C9:  GOTO   739
....................     if(!(readFromRegister(ErrorReg) & 0x1D)) {  // BufferOvfl Collerr CRCErr ProtocolErr 
06CA:  MOVLW  06
06CB:  MOVWF  52
06CC:  MOVLB  00
06CD:  CALL   435
06CE:  MOVF   78,W
06CF:  ANDLW  1D
06D0:  BTFSS  03.2
06D1:  GOTO   736
....................       status = MI_OK; 
06D2:  MOVLB  02
06D3:  CLRF   48
....................       if (n & irqEn & 0x01) { 
06D4:  MOVF   4C,W
06D5:  ANDWF  49,W
06D6:  ANDLW  01
06D7:  BTFSC  03.2
06D8:  GOTO   6DB
....................         status = MI_NOTAGERR; 
06D9:  MOVLW  01
06DA:  MOVWF  48
....................       } 
....................  
....................       if (cmd == MFRC522_TRANSCEIVE) { 
06DB:  MOVF   40,W
06DC:  SUBLW  0C
06DD:  BTFSS  03.2
06DE:  GOTO   734
....................         n = readFromRegister(FIFOLevelReg); 
06DF:  MOVLW  0A
06E0:  MOVWF  52
06E1:  MOVLB  00
06E2:  CALL   435
06E3:  MOVF   78,W
06E4:  MOVLB  02
06E5:  MOVWF  4C
....................         lastBits = readFromRegister(ControlReg) & 0x07; 
06E6:  MOVLW  0C
06E7:  MOVWF  52
06E8:  MOVLB  00
06E9:  CALL   435
06EA:  MOVF   78,W
06EB:  ANDLW  07
06EC:  MOVLB  02
06ED:  MOVWF  4B
....................         if (lastBits) { 
06EE:  MOVF   4B,F
06EF:  BTFSC  03.2
06F0:  GOTO   701
....................           *rlen = (n-1)*8 + lastBits; 
06F1:  MOVF   46,W
06F2:  MOVWF  04
06F3:  MOVF   47,W
06F4:  MOVWF  05
06F5:  MOVLW  01
06F6:  SUBWF  4C,W
06F7:  MOVWF  77
06F8:  RLF    77,F
06F9:  RLF    77,F
06FA:  RLF    77,F
06FB:  MOVLW  F8
06FC:  ANDWF  77,F
06FD:  MOVF   77,W
06FE:  ADDWF  4B,W
06FF:  MOVWF  00
....................         } else { 
0700:  GOTO   70D
....................           *rlen = n*8; 
0701:  MOVF   46,W
0702:  MOVWF  04
0703:  MOVF   47,W
0704:  MOVWF  05
0705:  RLF    4C,W
0706:  MOVWF  77
0707:  RLF    77,F
0708:  RLF    77,F
0709:  MOVLW  F8
070A:  ANDWF  77,F
070B:  MOVF   77,W
070C:  MOVWF  00
....................         } 
....................  
....................         if (n == 0) { 
070D:  MOVF   4C,F
070E:  BTFSS  03.2
070F:  GOTO   712
....................           n = 1; 
0710:  MOVLW  01
0711:  MOVWF  4C
....................         } 
....................  
....................         if (n > MAX_LEN) { 
0712:  MOVF   4C,W
0713:  SUBLW  10
0714:  BTFSC  03.0
0715:  GOTO   718
....................           n = MAX_LEN; 
0716:  MOVLW  10
0717:  MOVWF  4C
....................         } 
....................  
....................         // Reading the recieved data from FIFO. 
....................         for (i=0; i<n; i++) { 
0718:  CLRF   4D
0719:  MOVF   4C,W
071A:  SUBWF  4D,W
071B:  BTFSC  03.0
071C:  GOTO   734
....................           result[i] = readFromRegister(FIFODataReg); 
071D:  MOVF   4D,W
071E:  ADDWF  44,W
071F:  MOVWF  78
0720:  MOVLW  00
0721:  ADDWFC 45,W
0722:  MOVWF  7A
0723:  MOVF   78,W
0724:  MOVWF  4F
0725:  MOVF   7A,W
0726:  MOVWF  50
0727:  MOVLW  09
0728:  MOVWF  52
0729:  MOVLB  00
072A:  CALL   435
072B:  MOVLB  02
072C:  MOVF   50,W
072D:  MOVWF  05
072E:  MOVF   4F,W
072F:  MOVWF  04
0730:  MOVF   78,W
0731:  MOVWF  00
0732:  INCF   4D,F
0733:  GOTO   719
....................         } 
....................       } 
....................     } else { 
0734:  GOTO   739
0735:  MOVLB  00
....................       status = MI_ERR; 
0736:  MOVLW  02
0737:  MOVLB  02
0738:  MOVWF  48
....................     } 
....................   } 
....................   return status; 
0739:  MOVF   48,W
073A:  MOVWF  78
073B:  MOVLB  00
073C:  RETURN
.................... } 
....................  
....................  
.................... /**************************************************************************/ 
.................... /* 
....................  
....................   @brief   Checks to see if there is a tag in the vicinity. 
....................  
....................   @param   mode  The mode we are requsting in. 
....................   @param   type  If we find a tag, this will be the type of that tag. 
....................                  0x4400 = Mifare_UltraLight 
....................                  0x0400 = Mifare_One(S50) 
....................                  0x0200 = Mifare_One(S70) 
....................                  0x0800 = Mifare_Pro(X) 
....................                  0x4403 = Mifare_DESFire 
....................  
....................   @returns Returns the status of the request. 
....................            MI_ERR        if something went wrong, 
....................            MI_NOTAGERR   if there was no tag to send the command to. 
....................            MI_OK         if everything went OK. 
....................  
....................  */ 
.................... /**************************************************************************/ 
.................... int requestTag(byte mode, byte *data) { 
....................   int status, len; 
....................   writeToRegister(BitFramingReg, 0x07);  // TxLastBists = BitFramingReg[2..0] 
073D:  MOVLW  0D
073E:  MOVLB  02
073F:  MOVWF  53
0740:  MOVLW  07
0741:  MOVWF  54
0742:  MOVLB  00
0743:  CALL   419
....................  
....................   data[0] = mode; 
0744:  MOVLB  01
0745:  MOVF   5A,W
0746:  MOVWF  04
0747:  MOVF   5B,W
0748:  MOVWF  05
0749:  MOVF   59,W
074A:  MOVWI  W,[FSR0+00]
....................   status = commandTag(MFRC522_TRANSCEIVE, data, 1, data, &len); 
074B:  MOVLW  0C
074C:  MOVLB  02
074D:  MOVWF  40
074E:  MOVLB  01
074F:  MOVF   5B,W
0750:  MOVLB  02
0751:  MOVWF  42
0752:  MOVLB  01
0753:  MOVF   5A,W
0754:  MOVLB  02
0755:  MOVWF  41
0756:  MOVLW  01
0757:  MOVWF  43
0758:  MOVLB  01
0759:  MOVF   5B,W
075A:  MOVLB  02
075B:  MOVWF  45
075C:  MOVLB  01
075D:  MOVF   5A,W
075E:  MOVLB  02
075F:  MOVWF  44
0760:  MOVLW  20
0761:  MOVWF  47
0762:  MOVLW  8D
0763:  MOVWF  46
0764:  MOVLB  00
0765:  CALL   646
0766:  MOVF   78,W
0767:  MOVLB  01
0768:  MOVWF  5C
....................  
....................   if ((status != MI_OK) || (len != 0x10)) { 
0769:  MOVF   5C,F
076A:  BTFSS  03.2
076B:  GOTO   770
076C:  MOVF   5D,W
076D:  SUBLW  10
076E:  BTFSC  03.2
076F:  GOTO   772
....................     status = MI_ERR; 
0770:  MOVLW  02
0771:  MOVWF  5C
....................   } 
....................  
....................   return status; 
0772:  MOVF   5C,W
0773:  MOVWF  78
0774:  MOVLP  08
0775:  MOVLB  00
0776:  GOTO   6A6 (RETURN)
.................... } 
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................  
....................   @brief   Handles collisions that might occur if there are multiple 
....................            tags available. 
....................  
....................   @param   serial  The serial nb of the tag. 
....................  
....................   @returns Returns the status of the collision detection. 
....................            MI_ERR        if something went wrong, 
....................            MI_NOTAGERR   if there was no tag to send the command to. 
....................            MI_OK         if everything went OK. 
....................  
....................  */ 
.................... /**************************************************************************/ 
.................... int antiCollision(byte *serial) { 
0777:  MOVLB  01
0778:  CLRF   5E
....................   int status, i, len; 
....................   byte check = 0x00; 
....................  
....................   writeToRegister(BitFramingReg, 0x00);  // TxLastBits = BitFramingReg[2..0] 
0779:  MOVLW  0D
077A:  MOVLB  02
077B:  MOVWF  53
077C:  CLRF   54
077D:  MOVLB  00
077E:  CALL   419
....................  
....................   serial[0] = MF1_ANTICOLL; 
077F:  MOVLB  01
0780:  MOVF   59,W
0781:  MOVWF  04
0782:  MOVF   5A,W
0783:  MOVWF  05
0784:  MOVLW  93
0785:  MOVWI  W,[FSR0+00]
....................   serial[1] = 0x20; 
0786:  MOVF   59,W
0787:  MOVWF  04
0788:  MOVF   5A,W
0789:  MOVWF  05
078A:  MOVLW  20
078B:  MOVWI  W,[FSR0+01]
....................   status = commandTag(MFRC522_TRANSCEIVE, serial, 2, serial, &len); 
078C:  MOVLW  0C
078D:  MOVLB  02
078E:  MOVWF  40
078F:  MOVLB  01
0790:  MOVF   5A,W
0791:  MOVLB  02
0792:  MOVWF  42
0793:  MOVLB  01
0794:  MOVF   59,W
0795:  MOVLB  02
0796:  MOVWF  41
0797:  MOVLW  02
0798:  MOVWF  43
0799:  MOVLB  01
079A:  MOVF   5A,W
079B:  MOVLB  02
079C:  MOVWF  45
079D:  MOVLB  01
079E:  MOVF   59,W
079F:  MOVLB  02
07A0:  MOVWF  44
07A1:  MOVLW  20
07A2:  MOVWF  47
07A3:  MOVLW  8D
07A4:  MOVWF  46
07A5:  MOVLB  00
07A6:  CALL   646
07A7:  MOVF   78,W
07A8:  MOVLB  01
07A9:  MOVWF  5B
....................   len = len / 8; // len is in bits, and we want each byte. 
07AA:  RRF    5D,F
07AB:  RRF    5D,F
07AC:  RRF    5D,F
07AD:  MOVLW  1F
07AE:  ANDWF  5D,F
....................   if (status == MI_OK) { 
07AF:  MOVF   5B,F
07B0:  BTFSS  03.2
07B1:  GOTO   7CE
....................     // The checksum of the tag is the ^ of all the values. 
....................     for (i = 0; i < len-1; i++) { 
07B2:  CLRF   5C
07B3:  MOVLW  01
07B4:  SUBWF  5D,W
07B5:  SUBWF  5C,W
07B6:  BTFSC  03.0
07B7:  GOTO   7C2
....................       check ^= serial[i]; 
07B8:  MOVF   5C,W
07B9:  ADDWF  59,W
07BA:  MOVWF  04
07BB:  MOVLW  00
07BC:  ADDWFC 5A,W
07BD:  MOVWF  05
07BE:  MOVF   00,W
07BF:  XORWF  5E,F
07C0:  INCF   5C,F
07C1:  GOTO   7B3
....................     } 
....................     // The checksum should be the same as the one provided from the 
....................     // tag (serial[4]). 
....................     if (check != serial[i]) { 
07C2:  MOVF   5C,W
07C3:  ADDWF  59,W
07C4:  MOVWF  04
07C5:  MOVLW  00
07C6:  ADDWFC 5A,W
07C7:  MOVWF  05
07C8:  MOVF   00,W
07C9:  SUBWF  5E,W
07CA:  BTFSC  03.2
07CB:  GOTO   7CE
....................       status = MI_ERR; 
07CC:  MOVLW  02
07CD:  MOVWF  5B
....................     } 
....................   } 
....................  
....................   return status; 
07CE:  MOVF   5B,W
07CF:  MOVWF  78
07D0:  MOVLP  08
07D1:  MOVLB  00
07D2:  GOTO   6C6 (RETURN)
.................... } 
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................  
....................   @brief   Calculates the CRC value for some data that should be sent to 
....................            a tag. 
....................  
....................   @param   data    The data to calculate the value for. 
....................   @param   len     The length of the data. 
....................   @param   result  The result of the CRC calculation. 
....................  
....................  */ 
.................... /**************************************************************************/ 
.................... void calculateCRC(byte *data, int len, byte *result) { 
....................   int i; 
....................   byte n; 
....................  
....................   clearBitMask(DivIrqReg, 0x04);   // CRCIrq = 0 
*
0829:  MOVLW  05
082A:  MOVLB  02
082B:  MOVWF  4F
082C:  MOVLW  04
082D:  MOVWF  50
082E:  MOVLP  00
082F:  MOVLB  00
0830:  CALL   633
0831:  MOVLP  08
....................   setBitMask(FIFOLevelReg, 0x80);  // Clear the FIFO pointer 
0832:  MOVLW  0A
0833:  MOVLB  02
0834:  MOVWF  4F
0835:  MOVLW  80
0836:  MOVWF  50
0837:  MOVLP  00
0838:  MOVLB  00
0839:  CALL   456
083A:  MOVLP  08
....................  
....................   //Writing data to the FIFO. 
....................   for (i = 0; i < len; i++) { 
083B:  MOVLB  02
083C:  CLRF   45
083D:  MOVF   42,W
083E:  SUBWF  45,W
083F:  BTFSC  03.0
0840:  GOTO   054
....................     writeToRegister(FIFODataReg, data[i]); 
0841:  MOVF   45,W
0842:  ADDWF  40,W
0843:  MOVWF  04
0844:  MOVLW  00
0845:  ADDWFC 41,W
0846:  MOVWF  05
0847:  MOVF   00,W
0848:  MOVWF  48
0849:  MOVLW  09
084A:  MOVWF  53
084B:  MOVF   48,W
084C:  MOVWF  54
084D:  MOVLP  00
084E:  MOVLB  00
084F:  CALL   419
0850:  MOVLP  08
0851:  MOVLB  02
0852:  INCF   45,F
0853:  GOTO   03D
....................   } 
....................   writeToRegister(CommandReg, MFRC522_CALCCRC); 
0854:  MOVLW  01
0855:  MOVWF  53
0856:  MOVLW  03
0857:  MOVWF  54
0858:  MOVLP  00
0859:  MOVLB  00
085A:  CALL   419
085B:  MOVLP  08
....................  
....................   // Wait for the CRC calculation to complete. 
....................   i = 0xFF; 
085C:  MOVLW  FF
085D:  MOVLB  02
085E:  MOVWF  45
....................   do { 
....................     n = readFromRegister(DivIrqReg); 
085F:  MOVLW  05
0860:  MOVWF  52
0861:  MOVLP  00
0862:  MOVLB  00
0863:  CALL   435
0864:  MOVLP  08
0865:  MOVF   78,W
0866:  MOVLB  02
0867:  MOVWF  46
....................     i--; 
0868:  DECF   45,F
....................   } while ((i != 0) && !(n & 0x04));  //CRCIrq = 1 
0869:  MOVF   45,F
086A:  BTFSC  03.2
086B:  GOTO   06E
086C:  BTFSS  46.2
086D:  GOTO   05F
....................  
....................   // Read the result from the CRC calculation. 
....................   result[0] = readFromRegister(CRCResultRegL); 
086E:  MOVF   43,W
086F:  MOVWF  48
0870:  MOVF   44,W
0871:  MOVWF  49
0872:  MOVLW  22
0873:  MOVWF  52
0874:  MOVLP  00
0875:  MOVLB  00
0876:  CALL   435
0877:  MOVLP  08
0878:  MOVLB  02
0879:  MOVF   49,W
087A:  MOVWF  05
087B:  MOVF   48,W
087C:  MOVWF  04
087D:  MOVF   78,W
087E:  MOVWF  00
....................   result[1] = readFromRegister(CRCResultRegM); 
087F:  MOVLW  01
0880:  ADDWF  43,W
0881:  MOVWF  48
0882:  MOVLW  00
0883:  ADDWFC 44,W
0884:  MOVWF  49
0885:  MOVLW  21
0886:  MOVWF  52
0887:  MOVLP  00
0888:  MOVLB  00
0889:  CALL   435
088A:  MOVLP  08
088B:  MOVLB  02
088C:  MOVF   49,W
088D:  MOVWF  05
088E:  MOVF   48,W
088F:  MOVWF  04
0890:  MOVF   78,W
0891:  MOVWF  00
0892:  MOVLB  00
0893:  RETURN
.................... } 
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Selects a tag for processing. 
....................   @param   serial  The serial number of the tag that is to be selected. 
....................   @returns The SAK response from the tag. 
....................  */ 
.................... /**************************************************************************/ 
.................... byte selectTag(byte *serial) { 
....................   int i, status, len; 
....................   byte sak; 
....................   byte buffer[9]; 
....................  
....................   buffer[0] = MF1_SELECTTAG; 
0894:  MOVLW  93
0895:  MOVLB  01
0896:  MOVWF  5F
....................   buffer[1] = 0x70; 
0897:  MOVLW  70
0898:  MOVWF  60
....................   for (i = 0; i < 5; i++) { 
0899:  CLRF   5B
089A:  MOVF   5B,W
089B:  SUBLW  04
089C:  BTFSS  03.0
089D:  GOTO   0BA
....................     buffer[i+2] = serial[i]; 
089E:  MOVLW  02
089F:  ADDWF  5B,W
08A0:  ADDLW  8F
08A1:  MOVWF  78
08A2:  MOVLW  20
08A3:  MOVWF  7A
08A4:  BTFSC  03.0
08A5:  INCF   7A,F
08A6:  MOVF   78,W
08A7:  MOVWF  6A
08A8:  MOVF   7A,W
08A9:  MOVWF  6B
08AA:  MOVF   5B,W
08AB:  ADDWF  59,W
08AC:  MOVWF  04
08AD:  MOVLW  00
08AE:  ADDWFC 5A,W
08AF:  MOVWF  05
08B0:  MOVF   00,W
08B1:  MOVWF  6C
08B2:  MOVF   6B,W
08B3:  MOVWF  05
08B4:  MOVF   6A,W
08B5:  MOVWF  04
08B6:  MOVF   6C,W
08B7:  MOVWF  00
08B8:  INCF   5B,F
08B9:  GOTO   09A
....................   } 
....................   calculateCRC(buffer, 7, &buffer[7]); 
08BA:  MOVLW  20
08BB:  MOVLB  02
08BC:  MOVWF  41
08BD:  MOVLW  8F
08BE:  MOVWF  40
08BF:  MOVLW  07
08C0:  MOVWF  42
08C1:  MOVLW  20
08C2:  MOVWF  44
08C3:  MOVLW  96
08C4:  MOVWF  43
08C5:  MOVLB  00
08C6:  CALL   029
....................  
....................   status = commandTag(MFRC522_TRANSCEIVE, buffer, 9, buffer, &len); 
08C7:  MOVLW  0C
08C8:  MOVLB  02
08C9:  MOVWF  40
08CA:  MOVLW  20
08CB:  MOVWF  42
08CC:  MOVLW  8F
08CD:  MOVWF  41
08CE:  MOVLW  09
08CF:  MOVWF  43
08D0:  MOVLW  20
08D1:  MOVWF  45
08D2:  MOVLW  8F
08D3:  MOVWF  44
08D4:  MOVLW  20
08D5:  MOVWF  47
08D6:  MOVLW  8D
08D7:  MOVWF  46
08D8:  MOVLP  00
08D9:  MOVLB  00
08DA:  CALL   646
08DB:  MOVLP  08
08DC:  MOVF   78,W
08DD:  MOVLB  01
08DE:  MOVWF  5C
....................  
....................   if ((status == MI_OK) && (len == 0x18)) { 
08DF:  MOVF   5C,F
08E0:  BTFSS  03.2
08E1:  GOTO   0E9
08E2:  MOVF   5D,W
08E3:  SUBLW  18
08E4:  BTFSS  03.2
08E5:  GOTO   0E9
....................     sak = buffer[0]; 
08E6:  MOVF   5F,W
08E7:  MOVWF  5E
....................   } 
08E8:  GOTO   0EA
....................   else { 
....................     sak = 0; 
08E9:  CLRF   5E
....................   } 
....................  
....................   return sak; 
08EA:  MOVF   5E,W
08EB:  MOVWF  78
08EC:  MOVLP  08
08ED:  MOVLB  00
08EE:  GOTO   72F (RETURN)
.................... } 
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Handles the authentication between the tag and the reader. 
....................   @param   mode    What authentication key to use. 
....................   @param   block   The block that we want to read. 
....................   @param   key     The authentication key. 
....................   @param   serial  The serial of the tag. 
....................   @returns Returns the status of the collision detection. 
....................            MI_ERR        if something went wrong, 
....................            MI_OK         if everything went OK. 
....................  */ 
.................... /**************************************************************************/ 
.................... int authenticate(byte mode, byte block, byte *key, byte *serial) { 
....................   int i, status, len; 
....................   byte buffer[12]; 
....................  
....................   //Verify the command block address + sector + password + tag serial number 
....................   buffer[0] = mode;          // 0th byte is the mode 
08EF:  MOVLB  02
08F0:  MOVF   27,W
08F1:  MOVWF  30
....................   buffer[1] = block;         // 1st byte is the block to address. 
08F2:  MOVF   28,W
08F3:  MOVWF  31
....................   for (i = 0; i < 6; i++) {  // 2nd to 7th byte is the authentication key. 
08F4:  CLRF   2D
08F5:  MOVF   2D,W
08F6:  SUBLW  05
08F7:  BTFSS  03.0
08F8:  GOTO   115
....................     buffer[i+2] = key[i]; 
08F9:  MOVLW  02
08FA:  ADDWF  2D,W
08FB:  ADDLW  B0
08FC:  MOVWF  78
08FD:  MOVLW  20
08FE:  MOVWF  7A
08FF:  BTFSC  03.0
0900:  INCF   7A,F
0901:  MOVF   78,W
0902:  MOVWF  3D
0903:  MOVF   7A,W
0904:  MOVWF  3E
0905:  MOVF   2D,W
0906:  ADDWF  29,W
0907:  MOVWF  04
0908:  MOVLW  00
0909:  ADDWFC 2A,W
090A:  MOVWF  05
090B:  MOVF   00,W
090C:  MOVWF  3F
090D:  MOVF   3E,W
090E:  MOVWF  05
090F:  MOVF   3D,W
0910:  MOVWF  04
0911:  MOVF   3F,W
0912:  MOVWF  00
0913:  INCF   2D,F
0914:  GOTO   0F5
....................   } 
....................   for (i = 0; i < 4; i++) {  // 8th to 11th byte is the serial of the tag. 
0915:  CLRF   2D
0916:  MOVF   2D,W
0917:  SUBLW  03
0918:  BTFSS  03.0
0919:  GOTO   136
....................     buffer[i+8] = serial[i]; 
091A:  MOVLW  08
091B:  ADDWF  2D,W
091C:  ADDLW  B0
091D:  MOVWF  78
091E:  MOVLW  20
091F:  MOVWF  7A
0920:  BTFSC  03.0
0921:  INCF   7A,F
0922:  MOVF   78,W
0923:  MOVWF  3D
0924:  MOVF   7A,W
0925:  MOVWF  3E
0926:  MOVF   2D,W
0927:  ADDWF  2B,W
0928:  MOVWF  04
0929:  MOVLW  00
092A:  ADDWFC 2C,W
092B:  MOVWF  05
092C:  MOVF   00,W
092D:  MOVWF  3F
092E:  MOVF   3E,W
092F:  MOVWF  05
0930:  MOVF   3D,W
0931:  MOVWF  04
0932:  MOVF   3F,W
0933:  MOVWF  00
0934:  INCF   2D,F
0935:  GOTO   116
....................   } 
....................  
....................   status = commandTag(MFRC522_AUTHENT, buffer, 12, buffer, &len); 
0936:  MOVLW  0E
0937:  MOVWF  40
0938:  MOVLW  20
0939:  MOVWF  42
093A:  MOVLW  B0
093B:  MOVWF  41
093C:  MOVLW  0C
093D:  MOVWF  43
093E:  MOVLW  20
093F:  MOVWF  45
0940:  MOVLW  B0
0941:  MOVWF  44
0942:  MOVLW  20
0943:  MOVWF  47
0944:  MOVLW  AF
0945:  MOVWF  46
0946:  MOVLP  00
0947:  MOVLB  00
0948:  CALL   646
0949:  MOVLP  08
094A:  MOVF   78,W
094B:  MOVLB  02
094C:  MOVWF  2E
....................  
....................   if ((status != MI_OK) || (!(readFromRegister(Status2Reg) & 0x08))) { 
094D:  MOVF   2E,F
094E:  BTFSS  03.2
094F:  GOTO   159
0950:  MOVLW  08
0951:  MOVWF  52
0952:  MOVLP  00
0953:  MOVLB  00
0954:  CALL   435
0955:  MOVLP  08
0956:  BTFSC  78.3
0957:  GOTO   15C
0958:  MOVLB  02
....................     status = MI_ERR; 
0959:  MOVLW  02
095A:  MOVWF  2E
095B:  MOVLB  00
....................   } 
....................  
....................   return status; 
095C:  MOVLB  02
095D:  MOVF   2E,W
095E:  MOVWF  78
095F:  MOVLB  00
0960:  RETURN
.................... } 
....................  
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Tries to read from the current (authenticated) tag. 
....................   @param   block   The block that we want to read. 
....................   @param   result  The resulting value returned from the tag. 
....................   @returns Returns the status of the collision detection. 
....................            MI_ERR        if something went wrong, 
....................            MI_OK         if everything went OK. 
....................  */ 
.................... /**************************************************************************/ 
.................... int readFromTag(byte block, byte *result) { 
....................   int status, len; 
....................  
....................   result[0] = MF1_READ; 
0961:  MOVLB  01
0962:  MOVF   62,W
0963:  MOVWF  04
0964:  MOVF   63,W
0965:  MOVWF  05
0966:  MOVLW  30
0967:  MOVWI  W,[FSR0+00]
....................   result[1] = block; 
0968:  MOVF   62,W
0969:  MOVWF  04
096A:  MOVF   63,W
096B:  MOVWF  05
096C:  MOVF   61,W
096D:  MOVWI  W,[FSR0+01]
....................   calculateCRC(result, 2, &result[2]); 
096E:  MOVLW  02
096F:  ADDWF  62,W
0970:  MOVWF  78
0971:  MOVLW  00
0972:  ADDWFC 63,W
0973:  MOVWF  7A
0974:  MOVF   78,W
0975:  MOVWF  66
0976:  MOVF   7A,W
0977:  MOVWF  67
0978:  MOVF   63,W
0979:  MOVLB  02
097A:  MOVWF  41
097B:  MOVLB  01
097C:  MOVF   62,W
097D:  MOVLB  02
097E:  MOVWF  40
097F:  MOVLW  02
0980:  MOVWF  42
0981:  MOVLB  01
0982:  MOVF   67,W
0983:  MOVLB  02
0984:  MOVWF  44
0985:  MOVLB  01
0986:  MOVF   66,W
0987:  MOVLB  02
0988:  MOVWF  43
0989:  MOVLB  00
098A:  CALL   029
....................   status = commandTag(MFRC522_TRANSCEIVE, result, 4, result, &len); 
098B:  MOVLW  0C
098C:  MOVLB  02
098D:  MOVWF  40
098E:  MOVLB  01
098F:  MOVF   63,W
0990:  MOVLB  02
0991:  MOVWF  42
0992:  MOVLB  01
0993:  MOVF   62,W
0994:  MOVLB  02
0995:  MOVWF  41
0996:  MOVLW  04
0997:  MOVWF  43
0998:  MOVLB  01
0999:  MOVF   63,W
099A:  MOVLB  02
099B:  MOVWF  45
099C:  MOVLB  01
099D:  MOVF   62,W
099E:  MOVLB  02
099F:  MOVWF  44
09A0:  MOVLW  20
09A1:  MOVWF  47
09A2:  MOVLW  95
09A3:  MOVWF  46
09A4:  MOVLP  00
09A5:  MOVLB  00
09A6:  CALL   646
09A7:  MOVLP  08
09A8:  MOVF   78,W
09A9:  MOVLB  01
09AA:  MOVWF  64
....................  
....................   if ((status != MI_OK) || (len != 0x90)) { 
09AB:  MOVF   64,F
09AC:  BTFSS  03.2
09AD:  GOTO   1B2
09AE:  MOVF   65,W
09AF:  SUBLW  90
09B0:  BTFSC  03.2
09B1:  GOTO   1B4
....................     status = MI_ERR; 
09B2:  MOVLW  02
09B3:  MOVWF  64
....................   } 
....................  
....................   return status; 
09B4:  MOVF   64,W
09B5:  MOVWF  78
09B6:  MOVLB  00
09B7:  RETURN
.................... } 
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Tries to write to a block on the current tag. 
....................   @param   block  The block that we want to write to. 
....................   @param   data   The data that we should write to the block. 
....................   @returns Returns the status of the collision detection. 
....................            MI_ERR        if something went wrong, 
....................            MI_OK         if everything went OK. 
....................  */ 
.................... /**************************************************************************/ 
.................... int writeToTag(byte block, byte *data) { 
....................   int status, i, len; 
....................   byte buffer[18]; 
....................  
....................   buffer[0] = MF1_WRITE; 
*
0B92:  MOVLW  A0
0B93:  MOVLB  02
0B94:  MOVWF  2D
....................   buffer[1] = block; 
0B95:  MOVF   27,W
0B96:  MOVWF  2E
....................   calculateCRC(buffer, 2, &buffer[2]); 
0B97:  MOVLW  20
0B98:  MOVWF  41
0B99:  MOVLW  AD
0B9A:  MOVWF  40
0B9B:  MOVLW  02
0B9C:  MOVWF  42
0B9D:  MOVLW  20
0B9E:  MOVWF  44
0B9F:  MOVLW  AF
0BA0:  MOVWF  43
0BA1:  MOVLB  00
0BA2:  CALL   029
....................   status = commandTag(MFRC522_TRANSCEIVE, buffer, 4, buffer, &len); 
0BA3:  MOVLW  0C
0BA4:  MOVLB  02
0BA5:  MOVWF  40
0BA6:  MOVLW  20
0BA7:  MOVWF  42
0BA8:  MOVLW  AD
0BA9:  MOVWF  41
0BAA:  MOVLW  04
0BAB:  MOVWF  43
0BAC:  MOVLW  20
0BAD:  MOVWF  45
0BAE:  MOVLW  AD
0BAF:  MOVWF  44
0BB0:  MOVLW  20
0BB1:  MOVWF  47
0BB2:  MOVLW  AC
0BB3:  MOVWF  46
0BB4:  MOVLP  00
0BB5:  MOVLB  00
0BB6:  CALL   646
0BB7:  MOVLP  08
0BB8:  MOVF   78,W
0BB9:  MOVLB  02
0BBA:  MOVWF  2A
....................  
....................   if ((status != MI_OK) || (len != 4) || ((buffer[0] & 0x0F) != 0x0A)) { 
0BBB:  MOVF   2A,F
0BBC:  BTFSS  03.2
0BBD:  GOTO   3C7
0BBE:  MOVF   2C,W
0BBF:  SUBLW  04
0BC0:  BTFSS  03.2
0BC1:  GOTO   3C7
0BC2:  MOVF   2D,W
0BC3:  ANDLW  0F
0BC4:  SUBLW  0A
0BC5:  BTFSC  03.2
0BC6:  GOTO   3C9
....................     status = MI_ERR; 
0BC7:  MOVLW  02
0BC8:  MOVWF  2A
....................   } 
....................  
....................  
....................   if (status == MI_OK) { 
0BC9:  MOVF   2A,F
0BCA:  BTFSS  03.2
0BCB:  GOTO   41E
....................        
....................     for (i = 0; i < 16; i++) { 
0BCC:  CLRF   2B
0BCD:  MOVF   2B,W
0BCE:  SUBLW  0F
0BCF:  BTFSS  03.0
0BD0:  GOTO   3EC
....................       buffer[i] = data[i]; 
0BD1:  MOVLW  AD
0BD2:  ADDWF  2B,W
0BD3:  MOVWF  78
0BD4:  MOVLW  20
0BD5:  MOVWF  7A
0BD6:  BTFSC  03.0
0BD7:  INCF   7A,F
0BD8:  MOVF   78,W
0BD9:  MOVWF  40
0BDA:  MOVF   7A,W
0BDB:  MOVWF  41
0BDC:  MOVF   2B,W
0BDD:  ADDWF  28,W
0BDE:  MOVWF  04
0BDF:  MOVLW  00
0BE0:  ADDWFC 29,W
0BE1:  MOVWF  05
0BE2:  MOVF   00,W
0BE3:  MOVWF  42
0BE4:  MOVF   41,W
0BE5:  MOVWF  05
0BE6:  MOVF   40,W
0BE7:  MOVWF  04
0BE8:  MOVF   42,W
0BE9:  MOVWF  00
0BEA:  INCF   2B,F
0BEB:  GOTO   3CD
....................     } 
....................     calculateCRC(buffer, 16, &buffer[16]); 
0BEC:  MOVLW  20
0BED:  MOVWF  41
0BEE:  MOVLW  AD
0BEF:  MOVWF  40
0BF0:  MOVLW  10
0BF1:  MOVWF  42
0BF2:  MOVLW  20
0BF3:  MOVWF  44
0BF4:  MOVLW  BD
0BF5:  MOVWF  43
0BF6:  MOVLB  00
0BF7:  CALL   029
....................     status = commandTag(MFRC522_TRANSCEIVE, buffer, 18, buffer, &len); 
0BF8:  MOVLW  0C
0BF9:  MOVLB  02
0BFA:  MOVWF  40
0BFB:  MOVLW  20
0BFC:  MOVWF  42
0BFD:  MOVLW  AD
0BFE:  MOVWF  41
0BFF:  MOVLW  12
0C00:  MOVWF  43
0C01:  MOVLW  20
0C02:  MOVWF  45
0C03:  MOVLW  AD
0C04:  MOVWF  44
0C05:  MOVLW  20
0C06:  MOVWF  47
0C07:  MOVLW  AC
0C08:  MOVWF  46
0C09:  MOVLP  00
0C0A:  MOVLB  00
0C0B:  CALL   646
0C0C:  MOVLP  08
0C0D:  MOVF   78,W
0C0E:  MOVLB  02
0C0F:  MOVWF  2A
....................  
....................     if ((status != MI_OK) || (len != 4) || ((buffer[0] & 0x0F) != 0x0A)) { 
0C10:  MOVF   2A,F
0C11:  BTFSS  03.2
0C12:  GOTO   41C
0C13:  MOVF   2C,W
0C14:  SUBLW  04
0C15:  BTFSS  03.2
0C16:  GOTO   41C
0C17:  MOVF   2D,W
0C18:  ANDLW  0F
0C19:  SUBLW  0A
0C1A:  BTFSC  03.2
0C1B:  GOTO   41E
....................       status = MI_ERR; 
0C1C:  MOVLW  02
0C1D:  MOVWF  2A
....................     } 
....................   } 
....................  
....................   return status; 
0C1E:  MOVF   2A,W
0C1F:  MOVWF  78
0C20:  MOVLB  00
0C21:  RETURN
.................... } 
....................  
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Sends a halt command to the current tag. 
....................   @returns Returns the result of the halt. 
....................            MI_ERR        If the command didn't complete properly. 
....................            MI_OK         If the command completed. 
....................  */ 
.................... /**************************************************************************/ 
.................... int haltTag() { 
....................   int status, len; 
....................   byte buffer[4]; 
....................  
....................   buffer[0] = MF1_HALT; 
*
0DAA:  MOVLW  50
0DAB:  MOVLB  01
0DAC:  MOVWF  5B
....................   buffer[1] = 0; 
0DAD:  CLRF   5C
....................   calculateCRC(buffer, 2, &buffer[2]); 
0DAE:  MOVLW  20
0DAF:  MOVLB  02
0DB0:  MOVWF  41
0DB1:  MOVLW  8B
0DB2:  MOVWF  40
0DB3:  MOVLW  02
0DB4:  MOVWF  42
0DB5:  MOVLW  20
0DB6:  MOVWF  44
0DB7:  MOVLW  8D
0DB8:  MOVWF  43
0DB9:  MOVLB  00
0DBA:  CALL   029
....................   status = commandTag(MFRC522_TRANSCEIVE, buffer, 4, buffer, &len); 
0DBB:  MOVLW  0C
0DBC:  MOVLB  02
0DBD:  MOVWF  40
0DBE:  MOVLW  20
0DBF:  MOVWF  42
0DC0:  MOVLW  8B
0DC1:  MOVWF  41
0DC2:  MOVLW  04
0DC3:  MOVWF  43
0DC4:  MOVLW  20
0DC5:  MOVWF  45
0DC6:  MOVLW  8B
0DC7:  MOVWF  44
0DC8:  MOVLW  20
0DC9:  MOVWF  47
0DCA:  MOVLW  8A
0DCB:  MOVWF  46
0DCC:  MOVLP  00
0DCD:  MOVLB  00
0DCE:  CALL   646
0DCF:  MOVLP  08
0DD0:  MOVF   78,W
0DD1:  MOVLB  01
0DD2:  MOVWF  59
....................   clearBitMask(Status2Reg, 0x08);  // turn off encryption 
0DD3:  MOVLW  08
0DD4:  MOVLB  02
0DD5:  MOVWF  4F
0DD6:  MOVWF  50
0DD7:  MOVLP  00
0DD8:  MOVLB  00
0DD9:  CALL   633
0DDA:  MOVLP  08
....................   return status; 
0DDB:  MOVLB  01
0DDC:  MOVF   59,W
0DDD:  MOVWF  78
0DDE:  MOVLP  08
0DDF:  MOVLB  00
0DE0:  GOTO   7D0 (RETURN)
.................... } 
....................  
....................  
.................... //// 
.................... //  Mifare Card Types Depending upon the codes of SAK from AN1083.PDF 
.................... //// 
....................  
.................... enum MIFARE_CARD_TYPE { 
....................     UID_FAILED = 0x00, 
....................     UID_NOT_COMPLETE = 0x04, 
....................     MIFARE_DESFIRE = 0x24, //MIFARE DESFire CL1, MIFARE DESFire EV1 CL1  
....................     MIFARE_MINI = 0x09, 
....................     MIFARE_CLASSIC_1K = 0x08, 
....................     MIFARE_CLASSIC_4K = 0x18, 
....................     MIFARE_DESFIRE = 0x20 
.................... }; 
....................  
....................  
....................  
....................  
.................... byte FoundTag; // Variable used to check if Tag was found 
.................... byte ReadTag; // Variable used to store anti-collision value to read Tag information 
.................... byte TagData[MAX_LEN]; // Variable used to store Full Tag Data 
.................... byte serial[5]; 
.................... byte i; //for looping 
.................... byte j; //for looping again 
.................... byte status; // to store the return status of command operations 
.................... byte data[MAX_LEN]; //to store any data 
....................  
.................... char buffer2[20]; 
....................  
.................... //keys for the card 
.................... byte keyA[6] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}; 
.................... byte keyB[6] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}; 
....................  
.................... byte LockKey[6] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06}; 
....................  
....................  
.................... //writeable data  
.................... byte writeableData[] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10}; 
....................  
....................  
....................  
.................... ///////// 
.................... ///     Check RFID Hardware 
.................... ///////// 
....................  
.................... int1 CheckRFIDHardware() { 
....................  
....................     char version;  
....................     ///Version of RFID read/writer is stored 
....................     // version 2.0 is 0x92 
....................     ///Version 1.0 is 0x91 
....................      
....................     printf("\r\nChecking If Rfid Is Connected"); 
*
0542:  MOVLW  03
0543:  MOVLB  10
0544:  MOVWF  1A
0545:  MOVLW  00
0546:  MOVWF  1B
0547:  MOVLB  00
0548:  CALL   3CB
....................  
....................     //Request from the register 
....................     version = readFromRegister(VersionReg); 
0549:  MOVLW  37
054A:  MOVLB  02
054B:  MOVWF  52
054C:  MOVLB  00
054D:  CALL   435
054E:  MOVF   78,W
054F:  MOVLB  01
0550:  MOVWF  59
....................     delay_ms(100); 
0551:  MOVLW  64
0552:  MOVLB  02
0553:  MOVWF  4F
0554:  MOVLB  00
0555:  CALL   1E5
....................  
....................  
....................     //response is 00 then hardware is not connected 
....................     if (!version) { 
0556:  MOVLB  01
0557:  MOVF   59,F
0558:  BTFSS  03.2
0559:  GOTO   576
....................         lcd_putc("\f RFID Not Found \n Check Again.."); 
055A:  MOVLW  13
055B:  MOVLB  10
055C:  MOVWF  1A
055D:  MOVLW  00
055E:  MOVWF  1B
055F:  MOVLB  00
0560:  CALL   351
....................         printf("\r\nRFID Hw not Found"); 
0561:  MOVLW  24
0562:  MOVLB  10
0563:  MOVWF  1A
0564:  MOVLW  00
0565:  MOVWF  1B
0566:  MOVLB  00
0567:  CALL   3CB
....................         delay_ms(5000); 
0568:  MOVLW  14
0569:  MOVLB  01
056A:  MOVWF  5A
056B:  MOVLW  FA
056C:  MOVLB  02
056D:  MOVWF  4F
056E:  MOVLB  00
056F:  CALL   1E5
0570:  MOVLB  01
0571:  DECFSZ 5A,F
0572:  GOTO   56B
....................         return 0; 
0573:  MOVLW  00
0574:  MOVWF  78
0575:  GOTO   630
....................     } 
....................     if (version) { 
0576:  MOVF   59,F
0577:  BTFSC  03.2
0578:  GOTO   62E
....................         lcd_putc("\f RFID Found"); 
0579:  MOVLW  2E
057A:  MOVLB  10
057B:  MOVWF  1A
057C:  MOVLW  00
057D:  MOVWF  1B
057E:  MOVLB  00
057F:  CALL   351
....................         printf(lcd_putc, "\nV: %x", version); 
0580:  MOVLW  35
0581:  MOVLB  10
0582:  MOVWF  1A
0583:  MOVLW  00
0584:  MOVWF  1B
0585:  BCF    03.0
0586:  MOVLW  04
0587:  MOVLB  01
0588:  MOVWF  5A
*
05DC:  MOVF   59,W
05DD:  MOVWF  5A
05DE:  MOVLW  57
05DF:  MOVWF  5B
....................         printf("\r\nRFID Found and HW version is: 0x%2X\r\n", version); 
*
0603:  MOVLW  39
0604:  MOVLB  10
0605:  MOVWF  1A
0606:  MOVLW  00
0607:  MOVWF  1B
0608:  BCF    03.0
0609:  MOVLW  22
060A:  MOVLB  02
060B:  MOVWF  27
060C:  MOVLB  00
060D:  CALL   4C5
060E:  MOVLB  01
060F:  MOVF   59,W
0610:  MOVLB  02
0611:  MOVWF  27
0612:  MOVLW  37
0613:  MOVWF  28
0614:  MOVLB  00
0615:  CALL   51D
0616:  MOVLW  0D
0617:  MOVLB  02
0618:  MOVWF  2B
0619:  MOVLB  00
061A:  CALL   39F
061B:  MOVLW  0A
061C:  MOVLB  02
061D:  MOVWF  2B
061E:  MOVLB  00
061F:  CALL   39F
....................         delay_ms(1000); 
0620:  MOVLW  04
0621:  MOVLB  01
0622:  MOVWF  5A
0623:  MOVLW  FA
0624:  MOVLB  02
0625:  MOVWF  4F
0626:  MOVLB  00
0627:  CALL   1E5
0628:  MOVLB  01
0629:  DECFSZ 5A,F
062A:  GOTO   623
....................         return 1; 
062B:  MOVLW  01
062C:  MOVWF  78
062D:  GOTO   630
....................     } 
....................      
....................     return 0; 
062E:  MOVLW  00
062F:  MOVWF  78
0630:  MOVLP  08
0631:  MOVLB  00
0632:  GOTO   67B (RETURN)
....................  
.................... } 
....................  
....................  
.................... ////// 
.................... ///     Function to read all the data from the card 
.................... ///     Read all the data from the mifare card and out puts to serial terminal     
.................... ///// 
....................  
.................... void readAll(void) { 
....................  
....................     //s50 has 64 blocks of memory 
....................     for (i = 0; i < 64; i++) { 
....................         // Try to authenticate each block first with the A key. 
....................         status = authenticate(MF1_AUTHENT1A, i, keyA, serial); 
....................         if (MI_OK == status) { 
....................             printf("Authenticated block 0x%2X with A\r\n",i); 
....................             printf("\r\n"); //a new line each block 
....................             //now read the block i  
....................             status = readFromTag(i, data); 
....................             if (MI_OK == status) { 
....................                 for (j = 0; j < 15; j++) { 
....................                     printf("0x%2X, ", data[j]); 
....................                 } 
....................                 printf("0x%2X", data[15]); 
....................             } else { 
....................                 printf("Read failed\r\n"); 
....................             } 
....................  
....................         } else { 
....................             //try to authenticate with key B 
....................             status = authenticate(MF1_AUTHENT1B, i, keyB, serial); 
....................             if (MI_OK == status) { 
....................                 printf("Authenticated block 0x%2X with key B",i); 
....................                 printf("\r\n"); //a new line each block 
....................  
....................                 //read from block 
....................                 status = readFromTag(i, data); 
....................  
....................                 if (MI_OK == status) { 
....................                     for (j = 0; j < 15; j++) { 
....................                         printf("%2X, ", data[j]); 
....................                     } 
....................                     printf("%2X, ", data[15]); 
....................                 } else { 
....................                     printf("Read failed \r\n"); 
....................                 } 
....................  
....................             } else { 
....................                 printf("Access denied at block 0x%2X", i); 
....................             } 
....................         } 
....................     } 
....................  
....................  
.................... } 
....................  
....................  
....................     // mifare classic has 16 sectors  
....................     // and 4 blocks each sector 
....................     // Sectors 0 to 15 
....................     // Blocks 0 to 3 
....................     // Block 3  is trailer block 
....................     // Block 0 from Sector 0 manufacturer block, non editable 
....................      
....................  
....................  
.................... void readBlock(int sector, int block, byte* readData) {     
*
09B8:  MOVLB  01
09B9:  RLF    59,W
09BA:  MOVWF  77
09BB:  RLF    77,F
09BC:  MOVLW  FC
09BD:  ANDWF  77,F
09BE:  MOVF   77,W
09BF:  ADDWF  5A,W
09C0:  MOVWF  5D
....................      
....................      
....................     //calculate block number for given sector and  
....................     // corresponding block number 
....................     int readBlock = ( sector * 4 ) + block;     
....................  
....................     // Try to authenticate each block first with the A key. 
....................     status = authenticate(MF1_AUTHENT1A, readBlock, keyA, serial); 
09C1:  MOVLW  60
09C2:  MOVLB  02
09C3:  MOVWF  27
09C4:  MOVLB  01
09C5:  MOVF   5D,W
09C6:  MOVLB  02
09C7:  MOVWF  28
09C8:  MOVLW  20
09C9:  MOVWF  2A
09CA:  MOVLW  44
09CB:  MOVWF  29
09CC:  MOVLW  20
09CD:  MOVWF  2C
09CE:  MOVLW  18
09CF:  MOVWF  2B
09D0:  MOVLB  00
09D1:  CALL   0EF
09D2:  MOVF   78,W
09D3:  MOVWF  3F
....................     if (MI_OK == status) { 
09D4:  MOVF   3F,F
09D5:  BTFSS  03.2
09D6:  GOTO   24C
....................         printf("Authenticated block 0x%2X with Key A\r\n",i); 
09D7:  MOVLW  90
09D8:  MOVLB  10
09D9:  MOVWF  1A
09DA:  MOVLW  00
09DB:  MOVWF  1B
09DC:  BCF    03.0
09DD:  MOVLW  16
09DE:  MOVLB  02
09DF:  MOVWF  27
09E0:  MOVLP  00
09E1:  MOVLB  00
09E2:  CALL   4C5
09E3:  MOVLP  08
09E4:  MOVF   3D,W
09E5:  MOVLB  02
09E6:  MOVWF  27
09E7:  MOVLW  37
09E8:  MOVWF  28
09E9:  MOVLP  00
09EA:  MOVLB  00
09EB:  CALL   51D
09EC:  MOVLP  08
09ED:  MOVLW  9C
09EE:  MOVLB  10
09EF:  MOVWF  1A
09F0:  MOVLW  00
09F1:  MOVWF  1B
09F2:  BSF    03.0
09F3:  MOVLW  0D
09F4:  MOVLB  02
09F5:  MOVWF  27
09F6:  MOVLP  00
09F7:  MOVLB  00
09F8:  CALL   4C5
09F9:  MOVLP  08
....................         printf("\r\n"); //a new line each block 
09FA:  MOVLW  0D
09FB:  MOVLB  02
09FC:  MOVWF  2B
09FD:  MOVLP  00
09FE:  MOVLB  00
09FF:  CALL   39F
0A00:  MOVLP  08
0A01:  MOVLW  0A
0A02:  MOVLB  02
0A03:  MOVWF  2B
0A04:  MOVLP  00
0A05:  MOVLB  00
0A06:  CALL   39F
0A07:  MOVLP  08
....................         //now read the block i  
....................         status = readFromTag(readBlock, data); 
0A08:  MOVLB  01
0A09:  MOVF   5D,W
0A0A:  MOVWF  61
0A0B:  MOVLW  20
0A0C:  MOVWF  63
0A0D:  MOVWF  62
0A0E:  MOVLB  00
0A0F:  CALL   161
0A10:  MOVF   78,W
0A11:  MOVWF  3F
....................         if (MI_OK == status) { 
0A12:  MOVF   3F,F
0A13:  BTFSS  03.2
0A14:  GOTO   242
....................             for (j = 0; j < 15; j++) {                 
0A15:  CLRF   3E
0A16:  MOVF   3E,W
0A17:  SUBLW  0E
0A18:  BTFSS  03.0
0A19:  GOTO   239
....................                 readData[j] = data[j]; 
0A1A:  MOVF   3E,W
0A1B:  MOVLB  01
0A1C:  ADDWF  5B,W
0A1D:  MOVWF  78
0A1E:  MOVLW  00
0A1F:  ADDWFC 5C,W
0A20:  MOVWF  7A
0A21:  MOVF   78,W
0A22:  MOVWF  5E
0A23:  MOVF   7A,W
0A24:  MOVWF  5F
0A25:  MOVLW  20
0A26:  MOVLB  00
0A27:  ADDWF  3E,W
0A28:  MOVWF  04
0A29:  MOVLW  20
0A2A:  MOVWF  05
0A2B:  BTFSC  03.0
0A2C:  INCF   05,F
0A2D:  MOVF   00,W
0A2E:  MOVLB  01
0A2F:  MOVWF  60
0A30:  MOVF   5F,W
0A31:  MOVWF  05
0A32:  MOVF   5E,W
0A33:  MOVWF  04
0A34:  MOVF   60,W
0A35:  MOVWF  00
0A36:  MOVLB  00
0A37:  INCF   3E,F
0A38:  GOTO   216
....................             } 
....................             readData[15] = data[15]; 
0A39:  MOVLB  01
0A3A:  MOVF   5B,W
0A3B:  MOVWF  04
0A3C:  MOVF   5C,W
0A3D:  MOVWF  05
0A3E:  MOVLB  00
0A3F:  MOVF   4F,W
0A40:  MOVWI  W,[FSR0+0F]
....................         } else { 
0A41:  GOTO   24B
....................             printf("Read failed\r\n"); 
0A42:  MOVLW  A4
0A43:  MOVLB  10
0A44:  MOVWF  1A
0A45:  MOVLW  00
0A46:  MOVWF  1B
0A47:  MOVLP  00
0A48:  MOVLB  00
0A49:  CALL   3CB
0A4A:  MOVLP  08
....................         } 
....................  
....................     } else { 
0A4B:  GOTO   2ED
....................         //try to authenticate with key B 
....................         status = authenticate(MF1_AUTHENT1B, readBlock, keyB, serial); 
0A4C:  MOVLW  61
0A4D:  MOVLB  02
0A4E:  MOVWF  27
0A4F:  MOVLB  01
0A50:  MOVF   5D,W
0A51:  MOVLB  02
0A52:  MOVWF  28
0A53:  MOVLW  20
0A54:  MOVWF  2A
0A55:  MOVLW  4A
0A56:  MOVWF  29
0A57:  MOVLW  20
0A58:  MOVWF  2C
0A59:  MOVLW  18
0A5A:  MOVWF  2B
0A5B:  MOVLB  00
0A5C:  CALL   0EF
0A5D:  MOVF   78,W
0A5E:  MOVWF  3F
....................         if (MI_OK == status) { 
0A5F:  MOVF   3F,F
0A60:  BTFSS  03.2
0A61:  GOTO   2D7
....................             printf("Authenticated block 0x%2X with key B",i); 
0A62:  MOVLW  AB
0A63:  MOVLB  10
0A64:  MOVWF  1A
0A65:  MOVLW  00
0A66:  MOVWF  1B
0A67:  BCF    03.0
0A68:  MOVLW  16
0A69:  MOVLB  02
0A6A:  MOVWF  27
0A6B:  MOVLP  00
0A6C:  MOVLB  00
0A6D:  CALL   4C5
0A6E:  MOVLP  08
0A6F:  MOVF   3D,W
0A70:  MOVLB  02
0A71:  MOVWF  27
0A72:  MOVLW  37
0A73:  MOVWF  28
0A74:  MOVLP  00
0A75:  MOVLB  00
0A76:  CALL   51D
0A77:  MOVLP  08
0A78:  MOVLW  B7
0A79:  MOVLB  10
0A7A:  MOVWF  1A
0A7B:  MOVLW  00
0A7C:  MOVWF  1B
0A7D:  BSF    03.0
0A7E:  MOVLW  0B
0A7F:  MOVLB  02
0A80:  MOVWF  27
0A81:  MOVLP  00
0A82:  MOVLB  00
0A83:  CALL   4C5
0A84:  MOVLP  08
....................             printf("\r\n"); //a new line each block 
0A85:  MOVLW  0D
0A86:  MOVLB  02
0A87:  MOVWF  2B
0A88:  MOVLP  00
0A89:  MOVLB  00
0A8A:  CALL   39F
0A8B:  MOVLP  08
0A8C:  MOVLW  0A
0A8D:  MOVLB  02
0A8E:  MOVWF  2B
0A8F:  MOVLP  00
0A90:  MOVLB  00
0A91:  CALL   39F
0A92:  MOVLP  08
....................  
....................             //read from block 
....................             status = readFromTag(i, data); 
0A93:  MOVF   3D,W
0A94:  MOVLB  01
0A95:  MOVWF  61
0A96:  MOVLW  20
0A97:  MOVWF  63
0A98:  MOVWF  62
0A99:  MOVLB  00
0A9A:  CALL   161
0A9B:  MOVF   78,W
0A9C:  MOVWF  3F
....................  
....................             if (MI_OK == status) { 
0A9D:  MOVF   3F,F
0A9E:  BTFSS  03.2
0A9F:  GOTO   2CD
....................                 for (j = 0; j < 15; j++) {                 
0AA0:  CLRF   3E
0AA1:  MOVF   3E,W
0AA2:  SUBLW  0E
0AA3:  BTFSS  03.0
0AA4:  GOTO   2C4
....................                     readData[j] = data[j]; 
0AA5:  MOVF   3E,W
0AA6:  MOVLB  01
0AA7:  ADDWF  5B,W
0AA8:  MOVWF  78
0AA9:  MOVLW  00
0AAA:  ADDWFC 5C,W
0AAB:  MOVWF  7A
0AAC:  MOVF   78,W
0AAD:  MOVWF  5E
0AAE:  MOVF   7A,W
0AAF:  MOVWF  5F
0AB0:  MOVLW  20
0AB1:  MOVLB  00
0AB2:  ADDWF  3E,W
0AB3:  MOVWF  04
0AB4:  MOVLW  20
0AB5:  MOVWF  05
0AB6:  BTFSC  03.0
0AB7:  INCF   05,F
0AB8:  MOVF   00,W
0AB9:  MOVLB  01
0ABA:  MOVWF  60
0ABB:  MOVF   5F,W
0ABC:  MOVWF  05
0ABD:  MOVF   5E,W
0ABE:  MOVWF  04
0ABF:  MOVF   60,W
0AC0:  MOVWF  00
0AC1:  MOVLB  00
0AC2:  INCF   3E,F
0AC3:  GOTO   2A1
....................                 } 
....................                 readData[15] = data[15]; 
0AC4:  MOVLB  01
0AC5:  MOVF   5B,W
0AC6:  MOVWF  04
0AC7:  MOVF   5C,W
0AC8:  MOVWF  05
0AC9:  MOVLB  00
0ACA:  MOVF   4F,W
0ACB:  MOVWI  W,[FSR0+0F]
....................             } else { 
0ACC:  GOTO   2D6
....................                 printf("Read failed \r\n"); 
0ACD:  MOVLW  BE
0ACE:  MOVLB  10
0ACF:  MOVWF  1A
0AD0:  MOVLW  00
0AD1:  MOVWF  1B
0AD2:  MOVLP  00
0AD3:  MOVLB  00
0AD4:  CALL   3CB
0AD5:  MOVLP  08
....................             } 
....................  
....................         } else { 
0AD6:  GOTO   2ED
....................             printf("Access denied at block 0x%2X", i); 
0AD7:  MOVLW  C6
0AD8:  MOVLB  10
0AD9:  MOVWF  1A
0ADA:  MOVLW  00
0ADB:  MOVWF  1B
0ADC:  BCF    03.0
0ADD:  MOVLW  19
0ADE:  MOVLB  02
0ADF:  MOVWF  27
0AE0:  MOVLP  00
0AE1:  MOVLB  00
0AE2:  CALL   4C5
0AE3:  MOVLP  08
0AE4:  MOVF   3D,W
0AE5:  MOVLB  02
0AE6:  MOVWF  27
0AE7:  MOVLW  37
0AE8:  MOVWF  28
0AE9:  MOVLP  00
0AEA:  MOVLB  00
0AEB:  CALL   51D
0AEC:  MOVLP  08
....................         } 
....................     } 
0AED:  MOVLP  08
0AEE:  GOTO   77B (RETURN)
.................... } 
....................  
.................... void writeBlock(int sector, int block, byte* writeData){   
*
0C22:  MOVLB  02
0C23:  RLF    22,W
0C24:  MOVWF  77
0C25:  RLF    77,F
0C26:  MOVLW  FC
0C27:  ANDWF  77,F
0C28:  MOVF   77,W
0C29:  ADDWF  23,W
0C2A:  MOVWF  26
....................      
....................     //calculate block number for given sector and  
....................     // corresponding block number 
....................     int writeBlock = ( sector * 4 ) + block; 
....................  
....................     status = authenticate(MF1_AUTHENT1A, writeBlock, keyA, serial); 
0C2B:  MOVLW  60
0C2C:  MOVWF  27
0C2D:  MOVF   26,W
0C2E:  MOVWF  28
0C2F:  MOVLW  20
0C30:  MOVWF  2A
0C31:  MOVLW  44
0C32:  MOVWF  29
0C33:  MOVLW  20
0C34:  MOVWF  2C
0C35:  MOVLW  18
0C36:  MOVWF  2B
0C37:  MOVLB  00
0C38:  CALL   0EF
0C39:  MOVF   78,W
0C3A:  MOVWF  3F
....................  
....................     //authenticated with key A 
....................     if (MI_OK == status) { 
0C3B:  MOVF   3F,F
0C3C:  BTFSS  03.2
0C3D:  GOTO   469
....................         printf("Authenticated with key A \r\n"); 
0C3E:  MOVLW  D5
0C3F:  MOVLB  10
0C40:  MOVWF  1A
0C41:  MOVLW  00
0C42:  MOVWF  1B
0C43:  MOVLP  00
0C44:  MOVLB  00
0C45:  CALL   3CB
0C46:  MOVLP  08
....................         status = writeToTag(writeBlock, writeData); 
0C47:  MOVLB  02
0C48:  MOVF   26,W
0C49:  MOVWF  27
0C4A:  MOVF   25,W
0C4B:  MOVWF  29
0C4C:  MOVF   24,W
0C4D:  MOVWF  28
0C4E:  MOVLB  00
0C4F:  CALL   392
0C50:  MOVF   78,W
0C51:  MOVWF  3F
....................         if (MI_OK == status) { 
0C52:  MOVF   3F,F
0C53:  BTFSS  03.2
0C54:  GOTO   45F
....................             printf("Write Successful\r\n"); 
0C55:  MOVLW  E3
0C56:  MOVLB  10
0C57:  MOVWF  1A
0C58:  MOVLW  00
0C59:  MOVWF  1B
0C5A:  MOVLP  00
0C5B:  MOVLB  00
0C5C:  CALL   3CB
0C5D:  MOVLP  08
....................         }else{ 
0C5E:  GOTO   468
....................             printf("Write failed\r\n"); 
0C5F:  MOVLW  ED
0C60:  MOVLB  10
0C61:  MOVWF  1A
0C62:  MOVLW  00
0C63:  MOVWF  1B
0C64:  MOVLP  00
0C65:  MOVLB  00
0C66:  CALL   3CB
0C67:  MOVLP  08
....................         } 
....................  
....................  
....................     } else { 
0C68:  GOTO   4CB
....................         //try to authenticate with key b 
....................         status = authenticate(MF1_AUTHENT1B, writeBlock, keyB, serial); 
0C69:  MOVLW  61
0C6A:  MOVLB  02
0C6B:  MOVWF  27
0C6C:  MOVF   26,W
0C6D:  MOVWF  28
0C6E:  MOVLW  20
0C6F:  MOVWF  2A
0C70:  MOVLW  4A
0C71:  MOVWF  29
0C72:  MOVLW  20
0C73:  MOVWF  2C
0C74:  MOVLW  18
0C75:  MOVWF  2B
0C76:  MOVLB  00
0C77:  CALL   0EF
0C78:  MOVF   78,W
0C79:  MOVWF  3F
....................         if (MI_OK == status) { 
0C7A:  MOVF   3F,F
0C7B:  BTFSS  03.2
0C7C:  GOTO   4A8
....................             printf("Authenticated with key B \r\n"); 
0C7D:  MOVLW  F5
0C7E:  MOVLB  10
0C7F:  MOVWF  1A
0C80:  MOVLW  00
0C81:  MOVWF  1B
0C82:  MOVLP  00
0C83:  MOVLB  00
0C84:  CALL   3CB
0C85:  MOVLP  08
....................             status = writeToTag(writeBlock, writeData); 
0C86:  MOVLB  02
0C87:  MOVF   26,W
0C88:  MOVWF  27
0C89:  MOVF   25,W
0C8A:  MOVWF  29
0C8B:  MOVF   24,W
0C8C:  MOVWF  28
0C8D:  MOVLB  00
0C8E:  CALL   392
0C8F:  MOVF   78,W
0C90:  MOVWF  3F
....................             if (MI_OK == status) { 
0C91:  MOVF   3F,F
0C92:  BTFSS  03.2
0C93:  GOTO   49E
....................                 printf("Write Successful\r\n"); 
0C94:  MOVLW  03
0C95:  MOVLB  10
0C96:  MOVWF  1A
0C97:  MOVLW  01
0C98:  MOVWF  1B
0C99:  MOVLP  00
0C9A:  MOVLB  00
0C9B:  CALL   3CB
0C9C:  MOVLP  08
....................             }else{ 
0C9D:  GOTO   4A7
....................                 printf("Write Failed"); 
0C9E:  MOVLW  0D
0C9F:  MOVLB  10
0CA0:  MOVWF  1A
0CA1:  MOVLW  01
0CA2:  MOVWF  1B
0CA3:  MOVLP  00
0CA4:  MOVLB  00
0CA5:  CALL   3CB
0CA6:  MOVLP  08
....................             } 
....................  
....................         } else { 
0CA7:  GOTO   4CB
....................             printf("Couldn't access block 0x%X write failed", 2); 
0CA8:  MOVLW  14
0CA9:  MOVLB  10
0CAA:  MOVWF  1A
0CAB:  MOVLW  01
0CAC:  MOVWF  1B
0CAD:  BCF    03.0
0CAE:  MOVLW  18
0CAF:  MOVLB  02
0CB0:  MOVWF  27
0CB1:  MOVLP  00
0CB2:  MOVLB  00
0CB3:  CALL   4C5
0CB4:  MOVLP  08
0CB5:  MOVLW  02
0CB6:  MOVLB  02
0CB7:  MOVWF  27
0CB8:  MOVLW  37
0CB9:  MOVWF  28
0CBA:  MOVLP  00
0CBB:  MOVLB  00
0CBC:  CALL   51D
0CBD:  MOVLP  08
0CBE:  MOVLW  21
0CBF:  MOVLB  10
0CC0:  MOVWF  1A
0CC1:  MOVLW  01
0CC2:  MOVWF  1B
0CC3:  BCF    03.0
0CC4:  MOVLW  0D
0CC5:  MOVLB  02
0CC6:  MOVWF  27
0CC7:  MOVLP  00
0CC8:  MOVLB  00
0CC9:  CALL   4C5
0CCA:  MOVLP  08
....................         } 
....................  
....................     } 
0CCB:  RETURN
.................... } 
....................  
.................... void writeLockedBlock(int sector, int block, byte* writeData, byte* lockKey){   
0CCC:  MOVLB  01
0CCD:  RLF    59,W
0CCE:  MOVWF  77
0CCF:  RLF    77,F
0CD0:  MOVLW  FC
0CD1:  ANDWF  77,F
0CD2:  MOVF   77,W
0CD3:  ADDWF  5A,W
0CD4:  MOVWF  5F
....................      
....................     int writeBlock = ( sector * 4 ) + block; 
....................  
....................     status = authenticate(MF1_AUTHENT1B, writeBlock, lockKey, serial); 
0CD5:  MOVLW  61
0CD6:  MOVLB  02
0CD7:  MOVWF  27
0CD8:  MOVLB  01
0CD9:  MOVF   5F,W
0CDA:  MOVLB  02
0CDB:  MOVWF  28
0CDC:  MOVLB  01
0CDD:  MOVF   5E,W
0CDE:  MOVLB  02
0CDF:  MOVWF  2A
0CE0:  MOVLB  01
0CE1:  MOVF   5D,W
0CE2:  MOVLB  02
0CE3:  MOVWF  29
0CE4:  MOVLW  20
0CE5:  MOVWF  2C
0CE6:  MOVLW  18
0CE7:  MOVWF  2B
0CE8:  MOVLB  00
0CE9:  CALL   0EF
0CEA:  MOVF   78,W
0CEB:  MOVWF  3F
....................  
....................     //authenticated with key A 
....................     if (MI_OK == status) { 
0CEC:  MOVF   3F,F
0CED:  BTFSS  03.2
0CEE:  GOTO   51F
....................         printf("Authenticated with Lockkey \r\n"); 
0CEF:  MOVLW  28
0CF0:  MOVLB  10
0CF1:  MOVWF  1A
0CF2:  MOVLW  01
0CF3:  MOVWF  1B
0CF4:  MOVLP  00
0CF5:  MOVLB  00
0CF6:  CALL   3CB
0CF7:  MOVLP  08
....................         status = writeToTag(writeBlock, writeData); 
0CF8:  MOVLB  01
0CF9:  MOVF   5F,W
0CFA:  MOVLB  02
0CFB:  MOVWF  27
0CFC:  MOVLB  01
0CFD:  MOVF   5C,W
0CFE:  MOVLB  02
0CFF:  MOVWF  29
0D00:  MOVLB  01
0D01:  MOVF   5B,W
0D02:  MOVLB  02
0D03:  MOVWF  28
0D04:  MOVLB  00
0D05:  CALL   392
0D06:  MOVF   78,W
0D07:  MOVWF  3F
....................         if (MI_OK == status) { 
0D08:  MOVF   3F,F
0D09:  BTFSS  03.2
0D0A:  GOTO   515
....................             printf("Write Successful\r\n"); 
0D0B:  MOVLW  37
0D0C:  MOVLB  10
0D0D:  MOVWF  1A
0D0E:  MOVLW  01
0D0F:  MOVWF  1B
0D10:  MOVLP  00
0D11:  MOVLB  00
0D12:  CALL   3CB
0D13:  MOVLP  08
....................         }else{ 
0D14:  GOTO   51E
....................             printf("Write failed\r\n"); 
0D15:  MOVLW  41
0D16:  MOVLB  10
0D17:  MOVWF  1A
0D18:  MOVLW  01
0D19:  MOVWF  1B
0D1A:  MOVLP  00
0D1B:  MOVLB  00
0D1C:  CALL   3CB
0D1D:  MOVLP  08
....................         } 
....................  
....................  
....................     } else{ 
0D1E:  GOTO   528
....................         printf("\nWrite failed, wrong key supplied \r\n"); 
0D1F:  MOVLW  49
0D20:  MOVLB  10
0D21:  MOVWF  1A
0D22:  MOVLW  01
0D23:  MOVWF  1B
0D24:  MOVLP  00
0D25:  MOVLB  00
0D26:  CALL   3CB
0D27:  MOVLP  08
....................     } 
0D28:  MOVLP  08
0D29:  GOTO   7C2 (RETURN)
.................... } 
....................  
....................  
....................  
.................... void readLockedBlock(int sector, int block, byte* readData, byte* lockKey) {     
*
0AEF:  MOVLB  01
0AF0:  RLF    59,W
0AF1:  MOVWF  77
0AF2:  RLF    77,F
0AF3:  MOVLW  FC
0AF4:  ANDWF  77,F
0AF5:  MOVF   77,W
0AF6:  ADDWF  5A,W
0AF7:  MOVWF  5F
....................      
....................      
....................     //calculate block number for given sector and  
....................     // corresponding block number 
....................     int readBlock = ( sector * 4 ) + block;     
....................  
....................     // Try to authenticate each block first with the A key. 
....................     status = authenticate(MF1_AUTHENT1B, readBlock, lockKey, serial); 
0AF8:  MOVLW  61
0AF9:  MOVLB  02
0AFA:  MOVWF  27
0AFB:  MOVLB  01
0AFC:  MOVF   5F,W
0AFD:  MOVLB  02
0AFE:  MOVWF  28
0AFF:  MOVLB  01
0B00:  MOVF   5E,W
0B01:  MOVLB  02
0B02:  MOVWF  2A
0B03:  MOVLB  01
0B04:  MOVF   5D,W
0B05:  MOVLB  02
0B06:  MOVWF  29
0B07:  MOVLW  20
0B08:  MOVWF  2C
0B09:  MOVLW  18
0B0A:  MOVWF  2B
0B0B:  MOVLB  00
0B0C:  CALL   0EF
0B0D:  MOVF   78,W
0B0E:  MOVWF  3F
....................     if (MI_OK == status) { 
0B0F:  MOVF   3F,F
0B10:  BTFSS  03.2
0B11:  GOTO   387
....................         printf("Authenticated block 0x%2X with LockKey \r\n",i); 
0B12:  MOVLW  5C
0B13:  MOVLB  10
0B14:  MOVWF  1A
0B15:  MOVLW  01
0B16:  MOVWF  1B
0B17:  BCF    03.0
0B18:  MOVLW  16
0B19:  MOVLB  02
0B1A:  MOVWF  27
0B1B:  MOVLP  00
0B1C:  MOVLB  00
0B1D:  CALL   4C5
0B1E:  MOVLP  08
0B1F:  MOVF   3D,W
0B20:  MOVLB  02
0B21:  MOVWF  27
0B22:  MOVLW  37
0B23:  MOVWF  28
0B24:  MOVLP  00
0B25:  MOVLB  00
0B26:  CALL   51D
0B27:  MOVLP  08
0B28:  MOVLW  68
0B29:  MOVLB  10
0B2A:  MOVWF  1A
0B2B:  MOVLW  01
0B2C:  MOVWF  1B
0B2D:  BSF    03.0
0B2E:  MOVLW  10
0B2F:  MOVLB  02
0B30:  MOVWF  27
0B31:  MOVLP  00
0B32:  MOVLB  00
0B33:  CALL   4C5
0B34:  MOVLP  08
....................         printf("\r\n"); //a new line each block 
0B35:  MOVLW  0D
0B36:  MOVLB  02
0B37:  MOVWF  2B
0B38:  MOVLP  00
0B39:  MOVLB  00
0B3A:  CALL   39F
0B3B:  MOVLP  08
0B3C:  MOVLW  0A
0B3D:  MOVLB  02
0B3E:  MOVWF  2B
0B3F:  MOVLP  00
0B40:  MOVLB  00
0B41:  CALL   39F
0B42:  MOVLP  08
....................         //now read the block i  
....................         status = readFromTag(readBlock, data); 
0B43:  MOVLB  01
0B44:  MOVF   5F,W
0B45:  MOVWF  61
0B46:  MOVLW  20
0B47:  MOVWF  63
0B48:  MOVWF  62
0B49:  MOVLB  00
0B4A:  CALL   161
0B4B:  MOVF   78,W
0B4C:  MOVWF  3F
....................         if (MI_OK == status) { 
0B4D:  MOVF   3F,F
0B4E:  BTFSS  03.2
0B4F:  GOTO   37D
....................             for (j = 0; j < 15; j++) {                 
0B50:  CLRF   3E
0B51:  MOVF   3E,W
0B52:  SUBLW  0E
0B53:  BTFSS  03.0
0B54:  GOTO   374
....................                 readData[j] = data[j]; 
0B55:  MOVF   3E,W
0B56:  MOVLB  01
0B57:  ADDWF  5B,W
0B58:  MOVWF  78
0B59:  MOVLW  00
0B5A:  ADDWFC 5C,W
0B5B:  MOVWF  7A
0B5C:  MOVF   78,W
0B5D:  MOVWF  61
0B5E:  MOVF   7A,W
0B5F:  MOVWF  62
0B60:  MOVLW  20
0B61:  MOVLB  00
0B62:  ADDWF  3E,W
0B63:  MOVWF  04
0B64:  MOVLW  20
0B65:  MOVWF  05
0B66:  BTFSC  03.0
0B67:  INCF   05,F
0B68:  MOVF   00,W
0B69:  MOVLB  01
0B6A:  MOVWF  63
0B6B:  MOVF   62,W
0B6C:  MOVWF  05
0B6D:  MOVF   61,W
0B6E:  MOVWF  04
0B6F:  MOVF   63,W
0B70:  MOVWF  00
0B71:  MOVLB  00
0B72:  INCF   3E,F
0B73:  GOTO   351
....................             } 
....................             readData[15] = data[15]; 
0B74:  MOVLB  01
0B75:  MOVF   5B,W
0B76:  MOVWF  04
0B77:  MOVF   5C,W
0B78:  MOVWF  05
0B79:  MOVLB  00
0B7A:  MOVF   4F,W
0B7B:  MOVWI  W,[FSR0+0F]
....................         } else { 
0B7C:  GOTO   386
....................             printf("Read failed\r\n"); 
0B7D:  MOVLW  71
0B7E:  MOVLB  10
0B7F:  MOVWF  1A
0B80:  MOVLW  01
0B81:  MOVWF  1B
0B82:  MOVLP  00
0B83:  MOVLB  00
0B84:  CALL   3CB
0B85:  MOVLP  08
....................         } 
....................  
....................     } else {        
0B86:  GOTO   390
....................         printf("\nRead failed, wrong key supplied \r\n"); 
0B87:  MOVLW  78
0B88:  MOVLB  10
0B89:  MOVWF  1A
0B8A:  MOVLW  01
0B8B:  MOVWF  1B
0B8C:  MOVLP  00
0B8D:  MOVLB  00
0B8E:  CALL   3CB
0B8F:  MOVLP  08
....................     } 
0B90:  MOVLP  08
0B91:  GOTO   78A (RETURN)
.................... } 
....................  
....................  
.................... //lock a sector with write key 
.................... //you can read only with readKey 
.................... //and you can write with writeKey 
....................  
.................... void LockSector(int sector, byte* readKey, byte* writeKey){ 
....................      
....................     byte accessBit[MAX_LEN]; 
....................      
....................     for(int i = 0; i< 6; i++){ 
*
0D2A:  MOVLB  01
0D2B:  CLRF   6E
0D2C:  MOVF   6E,W
0D2D:  SUBLW  05
0D2E:  BTFSS  03.0
0D2F:  GOTO   54F
....................       accessBit[i]  = readKey[i]; 
0D30:  MOVLW  8E
0D31:  ADDWF  6E,W
0D32:  MOVWF  78
0D33:  MOVLW  20
0D34:  MOVWF  7A
0D35:  BTFSC  03.0
0D36:  INCF   7A,F
0D37:  MOVF   78,W
0D38:  MOVLB  02
0D39:  MOVWF  22
0D3A:  MOVF   7A,W
0D3B:  MOVWF  23
0D3C:  MOVLB  01
0D3D:  MOVF   6E,W
0D3E:  ADDWF  5A,W
0D3F:  MOVWF  04
0D40:  MOVLW  00
0D41:  ADDWFC 5B,W
0D42:  MOVWF  05
0D43:  MOVF   00,W
0D44:  MOVLB  02
0D45:  MOVWF  24
0D46:  MOVF   23,W
0D47:  MOVWF  05
0D48:  MOVF   22,W
0D49:  MOVWF  04
0D4A:  MOVF   24,W
0D4B:  MOVWF  00
0D4C:  MOVLB  01
0D4D:  INCF   6E,F
0D4E:  GOTO   52C
....................     }     
....................      
....................     accessBit[6] = 0x78; 
0D4F:  MOVLW  78
0D50:  MOVWF  64
....................      
....................     accessBit[7] = 0x77; 
0D51:  MOVLW  77
0D52:  MOVWF  65
....................      
....................     accessBit[8] = 0x88; 
0D53:  MOVLW  88
0D54:  MOVWF  66
....................      
....................     accessBit[9] = 0x69; 
0D55:  MOVLW  69
0D56:  MOVWF  67
....................      
....................     for(int j = 0; j < 6; j++){ 
0D57:  CLRF   6F
0D58:  MOVF   6F,W
0D59:  SUBLW  05
0D5A:  BTFSS  03.0
0D5B:  GOTO   57B
....................         accessBit[10+j] = writeKey[j]; 
0D5C:  MOVLW  98
0D5D:  ADDWF  6F,W
0D5E:  MOVWF  78
0D5F:  MOVLW  20
0D60:  MOVWF  7A
0D61:  BTFSC  03.0
0D62:  INCF   7A,F
0D63:  MOVF   78,W
0D64:  MOVLB  02
0D65:  MOVWF  22
0D66:  MOVF   7A,W
0D67:  MOVWF  23
0D68:  MOVLB  01
0D69:  MOVF   6F,W
0D6A:  ADDWF  5C,W
0D6B:  MOVWF  04
0D6C:  MOVLW  00
0D6D:  ADDWFC 5D,W
0D6E:  MOVWF  05
0D6F:  MOVF   00,W
0D70:  MOVLB  02
0D71:  MOVWF  24
0D72:  MOVF   23,W
0D73:  MOVWF  05
0D74:  MOVF   22,W
0D75:  MOVWF  04
0D76:  MOVF   24,W
0D77:  MOVWF  00
0D78:  MOVLB  01
0D79:  INCF   6F,F
0D7A:  GOTO   558
....................     } 
....................      
....................     for(int a = 0; a < 16; a++){ 
0D7B:  MOVLB  02
0D7C:  CLRF   20
0D7D:  MOVF   20,W
0D7E:  SUBLW  0F
0D7F:  BTFSS  03.0
0D80:  GOTO   59C
....................         printf(" %2X",accessBit[a]); 
0D81:  MOVLW  8E
0D82:  ADDWF  20,W
0D83:  MOVWF  04
0D84:  MOVLW  20
0D85:  MOVWF  05
0D86:  BTFSC  03.0
0D87:  INCF   05,F
0D88:  MOVF   00,W
0D89:  MOVWF  22
0D8A:  MOVLW  20
0D8B:  MOVWF  2B
0D8C:  MOVLP  00
0D8D:  MOVLB  00
0D8E:  CALL   39F
0D8F:  MOVLP  08
0D90:  MOVLB  02
0D91:  MOVF   22,W
0D92:  MOVWF  27
0D93:  MOVLW  37
0D94:  MOVWF  28
0D95:  MOVLP  00
0D96:  MOVLB  00
0D97:  CALL   51D
0D98:  MOVLP  08
0D99:  MOVLB  02
0D9A:  INCF   20,F
0D9B:  GOTO   57D
....................     } 
....................      
....................     writeBlock(sector,3, accessBit); 
0D9C:  MOVLB  01
0D9D:  MOVF   59,W
0D9E:  MOVLB  02
0D9F:  MOVWF  22
0DA0:  MOVLW  03
0DA1:  MOVWF  23
0DA2:  MOVLW  20
0DA3:  MOVWF  25
0DA4:  MOVLW  8E
0DA5:  MOVWF  24
0DA6:  MOVLB  00
0DA7:  CALL   422
0DA8:  MOVLP  08
0DA9:  GOTO   7CF (RETURN)
.................... } 
....................  
....................  
.................... void main() { 
*
0DE1:  MOVLW  55
0DE2:  MOVLB  1D
0DE3:  MOVWF  0F
0DE4:  MOVLW  AA
0DE5:  MOVWF  0F
0DE6:  BCF    0F.0
0DE7:  MOVLW  15
0DE8:  MOVLB  1E
0DE9:  MOVWF  25
0DEA:  MOVLW  10
0DEB:  MOVWF  26
0DEC:  MOVLW  55
0DED:  MOVLB  1D
0DEE:  MOVWF  0F
0DEF:  MOVLW  AA
0DF0:  MOVWF  0F
0DF1:  BSF    0F.0
0DF2:  MOVLB  11
0DF3:  CLRF   12
0DF4:  CLRF   0F
0DF5:  CLRF   11
0DF6:  CLRF   13
0DF7:  MOVLW  70
0DF8:  MOVWF  0D
0DF9:  MOVLB  00
0DFA:  BCF    13.6
0DFB:  BSF    18.6
0DFC:  MOVLB  01
0DFD:  CLRF   37
0DFE:  CLRF   36
0DFF:  MOVLB  1E
0E00:  CLRF   38
0E01:  CLRF   43
0E02:  CLRF   4E
0E03:  MOVLB  13
0E04:  CLRF   11
0E05:  CLRF   12
0E06:  CLRF   13
0E07:  CLRF   10
0E08:  CLRF   15
0E09:  CLRF   16
0E0A:  CLRF   17
0E0B:  CLRF   14
0E0C:  GOTO   630
0E0D:  DATA 02,34
0E0E:  DATA 00,34
0E0F:  DATA 20,34
0E10:  DATA 00,34
0E11:  DATA 00,34
0E12:  DATA 0C,34
0E13:  DATA 40,34
0E14:  DATA 64,34
0E15:  DATA FF,34
0E16:  DATA 16,34
0E17:  DATA 00,34
0E18:  DATA A0,34
0E19:  DATA 01,34
0E1A:  DATA 02,34
0E1B:  DATA 03,34
0E1C:  DATA 04,34
0E1D:  DATA 05,34
0E1E:  DATA 06,34
0E1F:  DATA 01,34
0E20:  DATA 02,34
0E21:  DATA 03,34
0E22:  DATA 04,34
0E23:  DATA 05,34
0E24:  DATA 06,34
0E25:  DATA 07,34
0E26:  DATA 08,34
0E27:  DATA 09,34
0E28:  DATA 0A,34
0E29:  DATA 0B,34
0E2A:  DATA 0C,34
0E2B:  DATA 0D,34
0E2C:  DATA 0E,34
0E2D:  DATA 0F,34
0E2E:  DATA 10,34
0E2F:  DATA 00,34
0E30:  MOVLW  0E
0E31:  MOVWF  05
0E32:  MOVLW  0D
0E33:  MOVWF  04
0E34:  BSF    05.7
0E35:  MOVIW  [FSR0++],W
0E36:  MOVWF  77
0E37:  XORLW  00
0E38:  BTFSC  03.2
0E39:  GOTO   64A
0E3A:  MOVIW  [FSR0++],W
0E3B:  MOVWF  78
0E3C:  BTFSC  78.7
0E3D:  GOTO   642
0E3E:  ANDLW  0F
0E3F:  MOVWF  07
0E40:  MOVIW  [FSR0++],W
0E41:  MOVWF  06
0E42:  BTFSC  78.6
0E43:  MOVIW  [FSR0++],W
0E44:  BTFSS  78.6
0E45:  MOVIW  [FSR0++],W
0E46:  MOVWI  W,[FSR1++]
0E47:  DECFSZ 77,F
0E48:  GOTO   644
0E49:  GOTO   635
....................  
....................     //setup spi line  
....................  
....................     setup_spi(SPI_MASTER | SPI_MODE_0 | SPI_CLK_DIV_16); 
0E4A:  MOVLB  03
0E4B:  BCF    10.5
0E4C:  MOVLB  00
0E4D:  BCF    13.5
0E4E:  MOVLW  21
0E4F:  MOVLB  03
0E50:  MOVWF  10
0E51:  MOVLW  40
0E52:  MOVWF  0F
....................  
....................     delay_ms(20); 
0E53:  MOVLW  14
0E54:  MOVLB  02
0E55:  MOVWF  4F
0E56:  MOVLP  00
0E57:  MOVLB  00
0E58:  CALL   1E5
0E59:  MOVLP  08
....................  
....................     //init lcd and put some string 
....................     lcd_init(); 
0E5A:  MOVLP  00
0E5B:  GOTO   2B1
0E5C:  MOVLP  08
....................  
....................     lcd_putc("\f Starting..."); 
0E5D:  MOVLW  8A
0E5E:  MOVLB  10
0E5F:  MOVWF  1A
0E60:  MOVLW  01
0E61:  MOVWF  1B
0E62:  MOVLP  00
0E63:  MOVLB  00
0E64:  CALL   351
0E65:  MOVLP  08
....................  
....................     printf("\r\nstarting.."); //output to terminal     
0E66:  MOVLW  91
0E67:  MOVLB  10
0E68:  MOVWF  1A
0E69:  MOVLW  01
0E6A:  MOVWF  1B
0E6B:  MOVLP  00
0E6C:  MOVLB  00
0E6D:  CALL   3CB
0E6E:  MOVLP  08
....................  
....................     //initialize RFID Reader 
....................  
....................     delay_ms(100); 
0E6F:  MOVLW  64
0E70:  MOVLB  02
0E71:  MOVWF  4F
0E72:  MOVLP  00
0E73:  MOVLB  00
0E74:  CALL   1E5
0E75:  MOVLP  08
....................      
....................     MFRC_begin(); 
0E76:  MOVLP  00
0E77:  CALL   468
0E78:  MOVLP  08
....................  
....................     //check if the card reader is connected. 
....................     while(CheckRFIDHardware() == 0){ 
0E79:  MOVLP  00
0E7A:  GOTO   542
0E7B:  MOVLP  08
0E7C:  MOVF   78,F
0E7D:  BTFSS  03.2
0E7E:  GOTO   68A
....................          
....................         delay_ms(100); 
0E7F:  MOVLW  64
0E80:  MOVLB  02
0E81:  MOVWF  4F
0E82:  MOVLP  00
0E83:  MOVLB  00
0E84:  CALL   1E5
0E85:  MOVLP  08
....................      
....................         MFRC_begin(); 
0E86:  MOVLP  00
0E87:  CALL   468
0E88:  MOVLP  08
0E89:  GOTO   679
....................     } 
....................     //keep looping trying to find hardware 
....................  
....................     //in while loop keep checking for any new card 
....................     while (TRUE) { 
....................          
....................         printf("\r\nSearching for card"); 
0E8A:  MOVLW  98
0E8B:  MOVLB  10
0E8C:  MOVWF  1A
0E8D:  MOVLW  01
0E8E:  MOVWF  1B
0E8F:  MOVLP  00
0E90:  MOVLB  00
0E91:  CALL   3CB
0E92:  MOVLP  08
....................          
....................         lcd_putc("\f Searching for \nrfid..."); 
0E93:  MOVLW  A3
0E94:  MOVLB  10
0E95:  MOVWF  1A
0E96:  MOVLW  01
0E97:  MOVWF  1B
0E98:  MOVLP  00
0E99:  MOVLB  00
0E9A:  CALL   351
0E9B:  MOVLP  08
....................  
....................         //      //  Check to see if a Tag was detected 
....................         //     // If yes, then the variable FoundTag will contain "MI_OK" 
....................         FoundTag = requestTag(MF1_REQIDL, TagData); 
0E9C:  MOVLW  26
0E9D:  MOVLB  01
0E9E:  MOVWF  59
0E9F:  MOVLW  20
0EA0:  MOVWF  5B
0EA1:  MOVLW  08
0EA2:  MOVWF  5A
0EA3:  MOVLP  00
0EA4:  MOVLB  00
0EA5:  GOTO   73D
0EA6:  MOVLP  08
0EA7:  MOVF   78,W
0EA8:  MOVWF  26
....................         // 
....................         //If tag found 
....................         if (FoundTag == MI_OK) { 
0EA9:  MOVF   26,F
0EAA:  BTFSS  03.2
0EAB:  GOTO   7D0
....................  
....................             printf("\r\nFound Tag: ");             
0EAC:  MOVLW  B0
0EAD:  MOVLB  10
0EAE:  MOVWF  1A
0EAF:  MOVLW  01
0EB0:  MOVWF  1B
0EB1:  MOVLP  00
0EB2:  MOVLB  00
0EB3:  CALL   3CB
0EB4:  MOVLP  08
....................             lcd_putc("\r\nFound Tag: "); 
0EB5:  MOVLW  B7
0EB6:  MOVLB  10
0EB7:  MOVWF  1A
0EB8:  MOVLW  01
0EB9:  MOVWF  1B
0EBA:  MOVLP  00
0EBB:  MOVLB  00
0EBC:  CALL   351
0EBD:  MOVLP  08
....................              
....................             //when multiple cards in horizon choose one. 
....................             ReadTag = antiCollision(TagData); 
0EBE:  MOVLW  20
0EBF:  MOVLB  01
0EC0:  MOVWF  5A
0EC1:  MOVLW  08
0EC2:  MOVWF  59
0EC3:  MOVLP  00
0EC4:  MOVLB  00
0EC5:  GOTO   777
0EC6:  MOVLP  08
0EC7:  MOVF   78,W
0EC8:  MOVWF  27
....................  
....................             ///has tag passed anti collision test? 
....................             if (ReadTag == MI_OK) { 
0EC9:  MOVF   27,F
0ECA:  BTFSS  03.2
0ECB:  GOTO   7D0
....................  
....................                 //then put out UUID  
....................                 for (i = 0; i <= 2; i++) { 
0ECC:  CLRF   3D
0ECD:  MOVF   3D,W
0ECE:  SUBLW  02
0ECF:  BTFSS  03.0
0ED0:  GOTO   703
....................                     sprintf(buffer2, "%2X", (TagData[i])); //display version in hexadecimal 
0ED1:  MOVLW  08
0ED2:  ADDWF  3D,W
0ED3:  MOVWF  04
0ED4:  MOVLW  20
0ED5:  MOVWF  05
0ED6:  BTFSC  03.0
0ED7:  INCF   05,F
0ED8:  MOVF   00,W
0ED9:  MOVLB  01
0EDA:  MOVWF  59
0EDB:  MOVLW  20
0EDC:  MOVWF  37
0EDD:  MOVLW  30
0EDE:  MOVWF  36
0EDF:  MOVF   59,W
0EE0:  MOVWF  5A
0EE1:  MOVLW  37
0EE2:  MOVWF  5B
0EE3:  MOVLB  00
0EE4:  CALL   000
....................                     delay_ms(20); 
0EE5:  MOVLW  14
0EE6:  MOVLB  02
0EE7:  MOVWF  4F
0EE8:  MOVLP  00
0EE9:  MOVLB  00
0EEA:  CALL   1E5
0EEB:  MOVLP  08
....................                     printf(buffer2); 
0EEC:  MOVLW  20
0EED:  MOVWF  05
0EEE:  MOVLW  30
0EEF:  MOVWF  04
0EF0:  MOVLP  00
0EF1:  CALL   7E0
0EF2:  MOVLP  08
....................                     printf(", "); 
0EF3:  MOVLW  2C
0EF4:  MOVLB  02
0EF5:  MOVWF  2B
0EF6:  MOVLP  00
0EF7:  MOVLB  00
0EF8:  CALL   39F
0EF9:  MOVLP  08
0EFA:  MOVLW  20
0EFB:  MOVLB  02
0EFC:  MOVWF  2B
0EFD:  MOVLP  00
0EFE:  MOVLB  00
0EFF:  CALL   39F
0F00:  MOVLP  08
0F01:  INCF   3D,F
0F02:  GOTO   6CD
....................                 } 
....................                 sprintf(buffer2, "%2X", (TagData[i])); //display version in hexadecimal 
0F03:  MOVLW  08
0F04:  ADDWF  3D,W
0F05:  MOVWF  04
0F06:  MOVLW  20
0F07:  MOVWF  05
0F08:  BTFSC  03.0
0F09:  INCF   05,F
0F0A:  MOVF   00,W
0F0B:  MOVLB  01
0F0C:  MOVWF  59
0F0D:  MOVLW  20
0F0E:  MOVWF  37
0F0F:  MOVLW  30
0F10:  MOVWF  36
0F11:  MOVF   59,W
0F12:  MOVWF  5A
0F13:  MOVLW  37
0F14:  MOVWF  5B
0F15:  MOVLB  00
0F16:  CALL   000
....................                 printf(buffer2); 
0F17:  MOVLW  20
0F18:  MOVWF  05
0F19:  MOVLW  30
0F1A:  MOVWF  04
0F1B:  MOVLP  00
0F1C:  CALL   7E0
0F1D:  MOVLP  08
....................                  
....................                 //copy tag serial number to `serial` variable 
....................                 memcpy(serial, TagData, 5); 
0F1E:  MOVF   28,W
0F1F:  MOVWF  38
0F20:  MOVF   29,W
0F21:  MOVWF  39
0F22:  MOVF   2A,W
0F23:  MOVWF  3A
0F24:  MOVF   2B,W
0F25:  MOVWF  3B
0F26:  MOVF   2C,W
0F27:  MOVWF  3C
....................  
....................                 //now get SAK for card version check 
....................                 byte sak = selectTag(serial); 
0F28:  MOVLW  20
0F29:  MOVLB  01
0F2A:  MOVWF  5A
0F2B:  MOVLW  18
0F2C:  MOVWF  59
0F2D:  MOVLB  00
0F2E:  GOTO   094
0F2F:  MOVF   78,W
0F30:  MOVLB  01
0F31:  MOVWF  38
....................  
....................                 printf("\r\nSAK: 0x%2x", sak); 
0F32:  MOVLW  BE
0F33:  MOVLB  10
0F34:  MOVWF  1A
0F35:  MOVLW  01
0F36:  MOVWF  1B
0F37:  BCF    03.0
0F38:  MOVLW  09
0F39:  MOVLB  02
0F3A:  MOVWF  27
0F3B:  MOVLP  00
0F3C:  MOVLB  00
0F3D:  CALL   4C5
0F3E:  MOVLP  08
0F3F:  MOVLB  01
0F40:  MOVF   38,W
0F41:  MOVLB  02
0F42:  MOVWF  27
0F43:  MOVLW  57
0F44:  MOVWF  28
0F45:  MOVLP  00
0F46:  MOVLB  00
0F47:  CALL   51D
0F48:  MOVLP  08
....................  
....................  
....................                 if (UID_FAILED == sak) { 
0F49:  MOVLB  01
0F4A:  MOVF   38,F
0F4B:  BTFSS  03.2
0F4C:  GOTO   758
....................                     printf("\r\n Failed to read card"); 
0F4D:  MOVLW  C5
0F4E:  MOVLB  10
0F4F:  MOVWF  1A
0F50:  MOVLW  01
0F51:  MOVWF  1B
0F52:  MOVLP  00
0F53:  MOVLB  00
0F54:  CALL   3CB
0F55:  MOVLP  08
....................                 }//UID was read incompletely 
0F56:  GOTO   7D0
0F57:  MOVLB  01
....................                 else if (UID_NOT_COMPLETE == sak) { 
0F58:  MOVF   38,W
0F59:  SUBLW  04
0F5A:  BTFSS  03.2
0F5B:  GOTO   767
....................                     printf("\r\n Incomplete UID"); 
0F5C:  MOVLW  D1
0F5D:  MOVLB  10
0F5E:  MOVWF  1A
0F5F:  MOVLW  01
0F60:  MOVWF  1B
0F61:  MOVLP  00
0F62:  MOVLB  00
0F63:  CALL   3CB
0F64:  MOVLP  08
....................                 } else { 
0F65:  GOTO   7D0
0F66:  MOVLB  01
....................                     printf("\r\n Is a Mifare Card\n"); 
0F67:  MOVLW  DA
0F68:  MOVLB  10
0F69:  MOVWF  1A
0F6A:  MOVLW  01
0F6B:  MOVWF  1B
0F6C:  MOVLP  00
0F6D:  MOVLB  00
0F6E:  CALL   3CB
0F6F:  MOVLP  08
....................                     //everything went well so far                         
....................                     //now start reading memory 
....................                      
.................... //                  //if you wan to read whole card 
....................                     //readAll(); 
....................                      
....................                     //MAX_LINE is 16 
....................                     byte readData[MAX_LEN];                     
....................                      
....................                     //if you want to read from 
....................                     // sector 6 
....................                     // block 2 
....................                     // data into readData array of size 16 bytes 
....................                      
....................                     //read a block with keyA or keyB                     
....................                     readBlock( 6, 2, readData );                     
0F70:  MOVLW  06
0F71:  MOVLB  01
0F72:  MOVWF  59
0F73:  MOVLW  02
0F74:  MOVWF  5A
0F75:  MOVLW  20
0F76:  MOVWF  5C
0F77:  MOVLW  69
0F78:  MOVWF  5B
0F79:  MOVLB  00
0F7A:  GOTO   1B8
....................                      
....................                     readLockedBlock(6,3,readData,LockKey); 
0F7B:  MOVLW  06
0F7C:  MOVLB  01
0F7D:  MOVWF  59
0F7E:  MOVLW  03
0F7F:  MOVWF  5A
0F80:  MOVLW  20
0F81:  MOVWF  5C
0F82:  MOVLW  69
0F83:  MOVWF  5B
0F84:  MOVLW  20
0F85:  MOVWF  5E
0F86:  MOVLW  50
0F87:  MOVWF  5D
0F88:  MOVLB  00
0F89:  GOTO   2EF
....................                      
.................... //                     
.................... //                   for(int x=0;x<MAX_LEN;x++){ 
.................... //                       printf("%2X ",readData[x]); 
.................... //                    } 
....................                      
....................                      
....................                      
....................                     //if you want to write something to card 
....................                     byte writedata[] = {0x0F, 0x0F, 0x0F, 0x0F, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10}; 
0F8A:  MOVLW  0F
0F8B:  MOVLB  01
0F8C:  MOVWF  49
0F8D:  MOVWF  4A
0F8E:  MOVWF  4B
0F8F:  MOVWF  4C
0F90:  MOVLW  05
0F91:  MOVWF  4D
0F92:  MOVLW  06
0F93:  MOVWF  4E
0F94:  MOVLW  07
0F95:  MOVWF  4F
0F96:  MOVLW  08
0F97:  MOVWF  50
0F98:  MOVLW  09
0F99:  MOVWF  51
0F9A:  MOVLW  0A
0F9B:  MOVWF  52
0F9C:  MOVLW  0B
0F9D:  MOVWF  53
0F9E:  MOVLW  0C
0F9F:  MOVWF  54
0FA0:  MOVLW  0D
0FA1:  MOVWF  55
0FA2:  MOVLW  0E
0FA3:  MOVWF  56
0FA4:  MOVLW  0F
0FA5:  MOVWF  57
0FA6:  MOVLW  10
0FA7:  MOVWF  58
....................                      
....................                     writeBlock(6, 2, writedata); 
0FA8:  MOVLW  06
0FA9:  MOVLB  02
0FAA:  MOVWF  22
0FAB:  MOVLW  02
0FAC:  MOVWF  23
0FAD:  MOVLW  20
0FAE:  MOVWF  25
0FAF:  MOVLW  79
0FB0:  MOVWF  24
0FB1:  MOVLB  00
0FB2:  CALL   422
....................                      
....................                     //if you want to write to a block in locked sector 
....................                     writeLockedBlock(6, 2, writedata, LockKey); 
0FB3:  MOVLW  06
0FB4:  MOVLB  01
0FB5:  MOVWF  59
0FB6:  MOVLW  02
0FB7:  MOVWF  5A
0FB8:  MOVLW  20
0FB9:  MOVWF  5C
0FBA:  MOVLW  79
0FBB:  MOVWF  5B
0FBC:  MOVLW  20
0FBD:  MOVWF  5E
0FBE:  MOVLW  50
0FBF:  MOVWF  5D
0FC0:  MOVLB  00
0FC1:  GOTO   4CC
....................                      
....................                      
....................                     //if you want to lock a sector with new key 
....................                     // keyA is a key you want to use to read and can be public 
....................                     //lockKey is key you want lock sector with, it should be private 
....................                     //we can modify locked content with LockKey 
....................                     LockSector(6,keyA,LockKey);                     
0FC2:  MOVLW  06
0FC3:  MOVLB  01
0FC4:  MOVWF  59
0FC5:  MOVLW  20
0FC6:  MOVWF  5B
0FC7:  MOVLW  44
0FC8:  MOVWF  5A
0FC9:  MOVLW  20
0FCA:  MOVWF  5D
0FCB:  MOVLW  50
0FCC:  MOVWF  5C
0FCD:  MOVLB  00
0FCE:  GOTO   52A
....................                      
....................                      
....................                     //always halt tag once the card is processed 
....................                     haltTag(); 
0FCF:  GOTO   5AA
....................                 } 
....................             } 
....................         } 
....................  
....................         delay_ms(2000); 
0FD0:  MOVLW  08
0FD1:  MOVLB  01
0FD2:  MOVWF  59
0FD3:  MOVLW  FA
0FD4:  MOVLB  02
0FD5:  MOVWF  4F
0FD6:  MOVLP  00
0FD7:  MOVLB  00
0FD8:  CALL   1E5
0FD9:  MOVLP  08
0FDA:  MOVLB  01
0FDB:  DECFSZ 59,F
0FDC:  GOTO   7D3
0FDD:  MOVLB  00
0FDE:  GOTO   68A
....................         //     
....................     } 
....................  
....................     return; 
.................... } 
....................  
0FDF:  SLEEP

Configuration Fuses:
   Word  1: 3FFE   ECM RSTOSC_EXT NOCLKOUT CKS FCMEN
   Word  2: 3FFD   MCLR PUT NOLPBOR BROWNOUT BORV24 ZCDDIS PPS1WAY STVREN NODEBUG
   Word  3: 3F9F   WDTSW NOWDT WDTWIN_SW WDTCLK_SW
   Word  4: 1FFF   NOWRT SCANE NOLVP
   Word  5: 3FFF   NOPROTECT NOCPD
