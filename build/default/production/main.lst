CCS PCM C Compiler, Version 5.078, 43599               07-Jul-18 13:31

               Filename:   C:\Users\Shashikant\Documents\GitHub\RFID.X\build\default\production\main.lst

               ROM used:   3001 words (37%)
                           Largest free fragment is 2048
               RAM used:   107 (29%) at main() level
                           148 (40%) worst case
               Stack used: 5 locations
               Stack size: 8

*
0000:  MOVLW  0A
0001:  MOVWF  0A
0002:  GOTO   26E
0003:  NOP
.................... /*  
....................  * File:   main.c 
....................  * Author: Shashikant 
....................  * 
....................  * Created on 2 July, 2018, 12:43 PM 
....................  */ 
....................  
.................... //Options 
.................... #include <16F877A.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
0004:  DATA 0C,10
0005:  DATA 43,34
0006:  DATA E5,31
0007:  DATA EB,34
0008:  DATA EE,33
0009:  DATA 20,29
000A:  DATA C6,24
000B:  DATA 44,17
000C:  DATA 2E,17
000D:  DATA 00,00
000E:  DATA 0D,05
000F:  DATA 43,34
0010:  DATA E5,31
0011:  DATA EB,34
0012:  DATA EE,33
0013:  DATA A0,24
0014:  DATA 66,10
0015:  DATA 52,33
0016:  DATA 69,32
0017:  DATA A0,24
0018:  DATA 73,10
0019:  DATA C3,37
001A:  DATA 6E,37
001B:  DATA E5,31
001C:  DATA F4,32
001D:  DATA 64,00
001E:  DATA 0C,10
001F:  DATA 52,23
0020:  DATA 49,22
0021:  DATA 20,27
0022:  DATA 6F,3A
0023:  DATA 20,23
0024:  DATA EF,3A
0025:  DATA 6E,32
0026:  DATA 20,05
0027:  DATA A0,21
0028:  DATA E8,32
0029:  DATA E3,35
002A:  DATA A0,20
002B:  DATA E7,30
002C:  DATA 69,37
002D:  DATA 2E,17
002E:  DATA 00,01
002F:  DATA 0D,05
0030:  DATA 52,23
0031:  DATA 49,22
0032:  DATA 20,24
0033:  DATA 77,10
0034:  DATA EE,37
0035:  DATA 74,10
0036:  DATA C6,37
0037:  DATA 75,37
0038:  DATA 64,00
0039:  DATA 0C,10
003A:  DATA 52,23
003B:  DATA 49,22
003C:  DATA 20,23
003D:  DATA EF,3A
003E:  DATA 6E,32
003F:  DATA 00,01
0040:  DATA 0A,2B
0041:  DATA 3A,10
0042:  DATA 25,3C
0043:  DATA 00,00
0044:  DATA 0D,05
0045:  DATA 52,23
0046:  DATA 49,22
0047:  DATA 20,23
0048:  DATA EF,3A
0049:  DATA 6E,32
004A:  DATA A0,30
004B:  DATA 6E,32
004C:  DATA 20,24
004D:  DATA 57,10
004E:  DATA F6,32
004F:  DATA F2,39
0050:  DATA E9,37
0051:  DATA 6E,10
0052:  DATA E9,39
0053:  DATA 3A,10
0054:  DATA 30,3C
0055:  DATA 25,19
0056:  DATA D8,06
0057:  DATA 0A,00
0058:  DATA D2,32
0059:  DATA 61,32
005A:  DATA 20,33
005B:  DATA E1,34
005C:  DATA EC,32
005D:  DATA E4,06
005E:  DATA 0A,00
005F:  DATA D2,32
0060:  DATA 61,32
0061:  DATA 20,33
0062:  DATA E1,34
0063:  DATA EC,32
0064:  DATA 64,10
0065:  DATA 0D,05
0066:  DATA 00,01
0067:  DATA C1,31
0068:  DATA E3,32
0069:  DATA F3,39
006A:  DATA 20,32
006B:  DATA 65,37
006C:  DATA E9,32
006D:  DATA 64,10
006E:  DATA 61,3A
006F:  DATA 20,31
0070:  DATA EC,37
0071:  DATA E3,35
0072:  DATA 20,18
0073:  DATA F8,12
0074:  DATA 32,2C
0075:  DATA 00,00
0076:  DATA C1,3A
0077:  DATA 74,34
0078:  DATA 65,37
0079:  DATA F4,34
007A:  DATA E3,30
007B:  DATA F4,32
007C:  DATA 64,10
007D:  DATA F7,34
007E:  DATA 74,34
007F:  DATA A0,35
0080:  DATA E5,3C
0081:  DATA A0,20
0082:  DATA A0,06
0083:  DATA 0A,00
0084:  DATA 57,39
0085:  DATA 69,3A
0086:  DATA 65,10
0087:  DATA D3,3A
0088:  DATA E3,31
0089:  DATA E5,39
008A:  DATA 73,33
008B:  DATA 75,36
008C:  DATA 0D,05
008D:  DATA 00,01
008E:  DATA 57,39
008F:  DATA 69,3A
0090:  DATA 65,10
0091:  DATA E6,30
0092:  DATA 69,36
0093:  DATA 65,32
0094:  DATA 0D,05
0095:  DATA 00,01
0096:  DATA C1,3A
0097:  DATA 74,34
0098:  DATA 65,37
0099:  DATA F4,34
009A:  DATA E3,30
009B:  DATA F4,32
009C:  DATA 64,10
009D:  DATA F7,34
009E:  DATA 74,34
009F:  DATA A0,35
00A0:  DATA E5,3C
00A1:  DATA 20,21
00A2:  DATA A0,06
00A3:  DATA 0A,00
00A4:  DATA 57,39
00A5:  DATA 69,3A
00A6:  DATA 65,10
00A7:  DATA D3,3A
00A8:  DATA E3,31
00A9:  DATA E5,39
00AA:  DATA 73,33
00AB:  DATA 75,36
00AC:  DATA 0D,05
00AD:  DATA 00,01
00AE:  DATA 57,39
00AF:  DATA 69,3A
00B0:  DATA 65,10
00B1:  DATA C6,30
00B2:  DATA 69,36
00B3:  DATA 65,32
00B4:  DATA 00,01
00B5:  DATA C3,37
00B6:  DATA 75,36
00B7:  DATA 64,37
00B8:  DATA 27,3A
00B9:  DATA A0,30
00BA:  DATA E3,31
00BB:  DATA E5,39
00BC:  DATA 73,10
00BD:  DATA 62,36
00BE:  DATA EF,31
00BF:  DATA 6B,10
00C0:  DATA 30,3C
00C1:  DATA 25,2C
00C2:  DATA A0,3B
00C3:  DATA F2,34
00C4:  DATA F4,32
00C5:  DATA 20,33
00C6:  DATA E1,34
00C7:  DATA EC,32
00C8:  DATA 64,00
00C9:  DATA 0C,10
00CA:  DATA 53,3A
00CB:  DATA 61,39
00CC:  DATA F4,34
00CD:  DATA EE,33
00CE:  DATA 2E,17
00CF:  DATA 2E,00
00D0:  DATA 0D,05
00D1:  DATA 73,3A
00D2:  DATA 61,39
00D3:  DATA F4,34
00D4:  DATA EE,33
00D5:  DATA 2E,17
00D6:  DATA 00,01
00D7:  DATA 0D,05
00D8:  DATA C6,37
00D9:  DATA 75,37
00DA:  DATA 64,10
00DB:  DATA D4,30
00DC:  DATA 67,1D
00DD:  DATA 20,00
00DE:  DATA 0D,05
00DF:  DATA D3,20
00E0:  DATA 4B,1D
00E1:  DATA 20,18
00E2:  DATA F8,12
00E3:  DATA 32,3C
00E4:  DATA 00,01
00E5:  DATA 0D,05
00E6:  DATA 20,23
00E7:  DATA E1,34
00E8:  DATA EC,32
00E9:  DATA 64,10
00EA:  DATA F4,37
00EB:  DATA 20,39
00EC:  DATA E5,30
00ED:  DATA 64,10
00EE:  DATA E3,30
00EF:  DATA 72,32
00F0:  DATA 00,01
00F1:  DATA 0D,05
00F2:  DATA A0,24
00F3:  DATA EE,31
00F4:  DATA EF,36
00F5:  DATA 70,36
00F6:  DATA 65,3A
00F7:  DATA 65,10
00F8:  DATA D5,24
00F9:  DATA 44,00
00FA:  DATA 0D,05
00FB:  DATA A0,24
00FC:  DATA 73,10
00FD:  DATA 61,10
00FE:  DATA CD,34
00FF:  DATA E6,30
0100:  DATA F2,32
0101:  DATA A0,21
0102:  DATA 61,39
0103:  DATA 64,00
*
0285:  MOVF   0B,W
0286:  BSF    03.5
0287:  MOVWF  32
0288:  BCF    03.5
0289:  BCF    0B.7
028A:  BSF    03.5
028B:  BSF    03.6
028C:  BSF    0C.7
028D:  BSF    0C.0
028E:  NOP
028F:  NOP
0290:  BCF    03.6
0291:  BTFSS  32.7
0292:  GOTO   296
0293:  BCF    03.5
0294:  BSF    0B.7
0295:  BSF    03.5
0296:  BCF    03.5
0297:  BSF    03.6
0298:  MOVF   0C,W
0299:  ANDLW  7F
029A:  BTFSC  03.2
029B:  GOTO   2F7
029C:  BSF    03.5
029D:  BCF    03.6
029E:  MOVWF  32
029F:  BCF    03.5
02A0:  BSF    03.6
02A1:  MOVF   0D,W
02A2:  BSF    03.5
02A3:  BCF    03.6
02A4:  MOVWF  33
02A5:  BCF    03.5
02A6:  BSF    03.6
02A7:  MOVF   0F,W
02A8:  BSF    03.5
02A9:  BCF    03.6
02AA:  MOVWF  34
02AB:  MOVF   32,W
02AC:  MOVWF  36
02AD:  BCF    03.5
02AE:  CALL   24B
02AF:  BSF    03.5
02B0:  MOVF   33,W
02B1:  BCF    03.5
02B2:  BSF    03.6
02B3:  MOVWF  0D
02B4:  BSF    03.5
02B5:  BCF    03.6
02B6:  MOVF   34,W
02B7:  BCF    03.5
02B8:  BSF    03.6
02B9:  MOVWF  0F
02BA:  BCF    03.6
02BB:  MOVF   0B,W
02BC:  BSF    03.5
02BD:  MOVWF  35
02BE:  BCF    03.5
02BF:  BCF    0B.7
02C0:  BSF    03.5
02C1:  BSF    03.6
02C2:  BSF    0C.7
02C3:  BSF    0C.0
02C4:  NOP
02C5:  NOP
02C6:  BCF    03.6
02C7:  BTFSS  35.7
02C8:  GOTO   2CC
02C9:  BCF    03.5
02CA:  BSF    0B.7
02CB:  BSF    03.5
02CC:  BCF    03.5
02CD:  BSF    03.6
02CE:  RLF    0C,W
02CF:  RLF    0E,W
02D0:  ANDLW  7F
02D1:  BTFSC  03.2
02D2:  GOTO   2F7
02D3:  BSF    03.5
02D4:  BCF    03.6
02D5:  MOVWF  32
02D6:  BCF    03.5
02D7:  BSF    03.6
02D8:  MOVF   0D,W
02D9:  BSF    03.5
02DA:  BCF    03.6
02DB:  MOVWF  33
02DC:  BCF    03.5
02DD:  BSF    03.6
02DE:  MOVF   0F,W
02DF:  BSF    03.5
02E0:  BCF    03.6
02E1:  MOVWF  34
02E2:  MOVF   32,W
02E3:  MOVWF  36
02E4:  BCF    03.5
02E5:  CALL   24B
02E6:  BSF    03.5
02E7:  MOVF   33,W
02E8:  BCF    03.5
02E9:  BSF    03.6
02EA:  MOVWF  0D
02EB:  BSF    03.5
02EC:  BCF    03.6
02ED:  MOVF   34,W
02EE:  BCF    03.5
02EF:  BSF    03.6
02F0:  MOVWF  0F
02F1:  INCF   0D,F
02F2:  BTFSC  03.2
02F3:  INCF   0F,F
02F4:  BCF    03.6
02F5:  GOTO   285
02F6:  BSF    03.6
02F7:  BCF    03.6
02F8:  RETURN
02F9:  MOVF   0B,W
02FA:  BSF    03.5
02FB:  MOVWF  32
02FC:  BCF    03.5
02FD:  BCF    0B.7
02FE:  BSF    03.5
02FF:  BSF    03.6
0300:  BSF    0C.7
0301:  BSF    0C.0
0302:  NOP
0303:  NOP
0304:  BCF    03.6
0305:  BTFSS  32.7
0306:  GOTO   30A
0307:  BCF    03.5
0308:  BSF    0B.7
0309:  BSF    03.5
030A:  BCF    03.5
030B:  BSF    03.6
030C:  MOVF   0C,W
030D:  ANDLW  7F
030E:  BTFSC  03.2
030F:  GOTO   36D
0310:  BSF    03.5
0311:  BCF    03.6
0312:  MOVWF  32
0313:  BCF    03.5
0314:  BSF    03.6
0315:  MOVF   0D,W
0316:  BSF    03.5
0317:  BCF    03.6
0318:  MOVWF  33
0319:  BCF    03.5
031A:  BSF    03.6
031B:  MOVF   0F,W
031C:  BSF    03.5
031D:  BCF    03.6
031E:  MOVWF  34
031F:  MOVF   32,W
0320:  BCF    03.5
0321:  BTFSS  0C.4
0322:  GOTO   321
0323:  MOVWF  19
0324:  BSF    03.5
0325:  MOVF   33,W
0326:  BCF    03.5
0327:  BSF    03.6
0328:  MOVWF  0D
0329:  BSF    03.5
032A:  BCF    03.6
032B:  MOVF   34,W
032C:  BCF    03.5
032D:  BSF    03.6
032E:  MOVWF  0F
032F:  BCF    03.6
0330:  MOVF   0B,W
0331:  BSF    03.5
0332:  MOVWF  35
0333:  BCF    03.5
0334:  BCF    0B.7
0335:  BSF    03.5
0336:  BSF    03.6
0337:  BSF    0C.7
0338:  BSF    0C.0
0339:  NOP
033A:  NOP
033B:  BCF    03.6
033C:  BTFSS  35.7
033D:  GOTO   341
033E:  BCF    03.5
033F:  BSF    0B.7
0340:  BSF    03.5
0341:  BCF    03.5
0342:  BSF    03.6
0343:  RLF    0C,W
0344:  RLF    0E,W
0345:  ANDLW  7F
0346:  BTFSC  03.2
0347:  GOTO   36D
0348:  BSF    03.5
0349:  BCF    03.6
034A:  MOVWF  32
034B:  BCF    03.5
034C:  BSF    03.6
034D:  MOVF   0D,W
034E:  BSF    03.5
034F:  BCF    03.6
0350:  MOVWF  33
0351:  BCF    03.5
0352:  BSF    03.6
0353:  MOVF   0F,W
0354:  BSF    03.5
0355:  BCF    03.6
0356:  MOVWF  34
0357:  MOVF   32,W
0358:  BCF    03.5
0359:  BTFSS  0C.4
035A:  GOTO   359
035B:  MOVWF  19
035C:  BSF    03.5
035D:  MOVF   33,W
035E:  BCF    03.5
035F:  BSF    03.6
0360:  MOVWF  0D
0361:  BSF    03.5
0362:  BCF    03.6
0363:  MOVF   34,W
0364:  BCF    03.5
0365:  BSF    03.6
0366:  MOVWF  0F
0367:  INCF   0D,F
0368:  BTFSC  03.2
0369:  INCF   0F,F
036A:  BCF    03.6
036B:  GOTO   2F9
036C:  BSF    03.6
036D:  BCF    03.6
036E:  RETURN
*
042A:  MOVF   0B,W
042B:  BSF    03.5
042C:  MOVWF  33
042D:  BCF    03.5
042E:  BCF    0B.7
042F:  BSF    03.5
0430:  BSF    03.6
0431:  BSF    0C.7
0432:  BSF    0C.0
0433:  NOP
0434:  NOP
0435:  BCF    03.6
0436:  BTFSS  33.7
0437:  GOTO   43B
0438:  BCF    03.5
0439:  BSF    0B.7
043A:  BSF    03.5
043B:  BTFSC  03.0
043C:  GOTO   475
043D:  BCF    03.5
043E:  BSF    03.6
043F:  MOVF   0C,W
0440:  ANDLW  7F
0441:  BSF    03.5
0442:  BCF    03.6
0443:  MOVWF  33
0444:  BCF    03.5
0445:  BSF    03.6
0446:  MOVF   0D,W
0447:  BSF    03.5
0448:  BCF    03.6
0449:  MOVWF  34
044A:  BCF    03.5
044B:  BSF    03.6
044C:  MOVF   0F,W
044D:  BSF    03.5
044E:  BCF    03.6
044F:  MOVWF  35
0450:  MOVF   33,W
0451:  BCF    03.5
0452:  BTFSS  0C.4
0453:  GOTO   452
0454:  MOVWF  19
0455:  BSF    03.5
0456:  MOVF   34,W
0457:  BCF    03.5
0458:  BSF    03.6
0459:  MOVWF  0D
045A:  BSF    03.5
045B:  BCF    03.6
045C:  MOVF   35,W
045D:  BCF    03.5
045E:  BSF    03.6
045F:  MOVWF  0F
0460:  BCF    03.6
0461:  MOVF   0B,W
0462:  BSF    03.5
0463:  MOVWF  36
0464:  BCF    03.5
0465:  BCF    0B.7
0466:  BSF    03.5
0467:  BSF    03.6
0468:  BSF    0C.7
0469:  BSF    0C.0
046A:  NOP
046B:  NOP
046C:  BCF    03.6
046D:  BTFSS  36.7
046E:  GOTO   472
046F:  BCF    03.5
0470:  BSF    0B.7
0471:  BSF    03.5
0472:  DECFSZ 32,F
0473:  GOTO   475
0474:  GOTO   4A4
0475:  BCF    03.5
0476:  BSF    03.6
0477:  RLF    0C,W
0478:  RLF    0E,W
0479:  ANDLW  7F
047A:  BSF    03.5
047B:  BCF    03.6
047C:  MOVWF  33
047D:  BCF    03.5
047E:  BSF    03.6
047F:  MOVF   0D,W
0480:  BSF    03.5
0481:  BCF    03.6
0482:  MOVWF  34
0483:  BCF    03.5
0484:  BSF    03.6
0485:  MOVF   0F,W
0486:  BSF    03.5
0487:  BCF    03.6
0488:  MOVWF  35
0489:  MOVF   33,W
048A:  BCF    03.5
048B:  BTFSS  0C.4
048C:  GOTO   48B
048D:  MOVWF  19
048E:  BSF    03.5
048F:  MOVF   34,W
0490:  BCF    03.5
0491:  BSF    03.6
0492:  MOVWF  0D
0493:  BSF    03.5
0494:  BCF    03.6
0495:  MOVF   35,W
0496:  BCF    03.5
0497:  BSF    03.6
0498:  MOVWF  0F
0499:  INCF   0D,F
049A:  BTFSC  03.2
049B:  INCF   0F,F
049C:  BCF    03.0
049D:  BSF    03.5
049E:  BCF    03.6
049F:  DECFSZ 32,F
04A0:  GOTO   4A2
04A1:  GOTO   4A4
04A2:  BCF    03.5
04A3:  GOTO   42A
04A4:  BCF    03.5
04A5:  RETURN
04A6:  BSF    03.5
04A7:  BTFSC  33.7
04A8:  GOTO   4BC
04A9:  MOVLW  0F
04AA:  MOVWF  77
04AB:  SWAPF  32,W
04AC:  ANDWF  77,F
04AD:  MOVLW  0A
04AE:  SUBWF  77,W
04AF:  BTFSC  03.0
04B0:  GOTO   4B4
04B1:  MOVLW  30
04B2:  ADDWF  77,F
04B3:  GOTO   4B6
04B4:  MOVF   33,W
04B5:  ADDWF  77,F
04B6:  MOVF   77,W
04B7:  BCF    03.5
04B8:  BTFSS  0C.4
04B9:  GOTO   4B8
04BA:  MOVWF  19
04BB:  BSF    03.5
04BC:  MOVLW  0F
04BD:  ANDWF  32,F
04BE:  MOVLW  0A
04BF:  SUBWF  32,W
04C0:  BTFSC  03.0
04C1:  GOTO   4C4
04C2:  MOVLW  30
04C3:  GOTO   4C6
04C4:  BCF    33.7
04C5:  MOVF   33,W
04C6:  ADDWF  32,F
04C7:  MOVF   32,W
04C8:  BCF    03.5
04C9:  BTFSS  0C.4
04CA:  GOTO   4C9
04CB:  MOVWF  19
04CC:  RETURN
*
0519:  BCF    03.5
051A:  MOVF   0B,W
051B:  BSF    03.5
051C:  MOVWF  33
051D:  BCF    03.5
051E:  BCF    0B.7
051F:  BSF    03.5
0520:  BSF    03.6
0521:  BSF    0C.7
0522:  BSF    0C.0
0523:  NOP
0524:  NOP
0525:  BCF    03.6
0526:  BTFSS  33.7
0527:  GOTO   52B
0528:  BCF    03.5
0529:  BSF    0B.7
052A:  BSF    03.5
052B:  BTFSC  03.0
052C:  GOTO   564
052D:  BCF    03.5
052E:  BSF    03.6
052F:  MOVF   0C,W
0530:  ANDLW  7F
0531:  BSF    03.5
0532:  BCF    03.6
0533:  MOVWF  33
0534:  BCF    03.5
0535:  BSF    03.6
0536:  MOVF   0D,W
0537:  BSF    03.5
0538:  BCF    03.6
0539:  MOVWF  34
053A:  BCF    03.5
053B:  BSF    03.6
053C:  MOVF   0F,W
053D:  BSF    03.5
053E:  BCF    03.6
053F:  MOVWF  35
0540:  MOVF   33,W
0541:  MOVWF  36
0542:  BCF    03.5
0543:  CALL   24B
0544:  BSF    03.5
0545:  MOVF   34,W
0546:  BCF    03.5
0547:  BSF    03.6
0548:  MOVWF  0D
0549:  BSF    03.5
054A:  BCF    03.6
054B:  MOVF   35,W
054C:  BCF    03.5
054D:  BSF    03.6
054E:  MOVWF  0F
054F:  BCF    03.6
0550:  MOVF   0B,W
0551:  BSF    03.5
0552:  MOVWF  36
0553:  BCF    03.5
0554:  BCF    0B.7
0555:  BSF    03.5
0556:  BSF    03.6
0557:  BSF    0C.7
0558:  BSF    0C.0
0559:  NOP
055A:  NOP
055B:  BCF    03.6
055C:  BTFSS  36.7
055D:  GOTO   561
055E:  BCF    03.5
055F:  BSF    0B.7
0560:  BSF    03.5
0561:  DECFSZ 32,F
0562:  GOTO   564
0563:  GOTO   58F
0564:  BCF    03.5
0565:  BSF    03.6
0566:  RLF    0C,W
0567:  RLF    0E,W
0568:  ANDLW  7F
0569:  BSF    03.5
056A:  BCF    03.6
056B:  MOVWF  33
056C:  BCF    03.5
056D:  BSF    03.6
056E:  MOVF   0D,W
056F:  BSF    03.5
0570:  BCF    03.6
0571:  MOVWF  34
0572:  BCF    03.5
0573:  BSF    03.6
0574:  MOVF   0F,W
0575:  BSF    03.5
0576:  BCF    03.6
0577:  MOVWF  35
0578:  MOVF   33,W
0579:  MOVWF  36
057A:  BCF    03.5
057B:  CALL   24B
057C:  BSF    03.5
057D:  MOVF   34,W
057E:  BCF    03.5
057F:  BSF    03.6
0580:  MOVWF  0D
0581:  BSF    03.5
0582:  BCF    03.6
0583:  MOVF   35,W
0584:  BCF    03.5
0585:  BSF    03.6
0586:  MOVWF  0F
0587:  INCF   0D,F
0588:  BTFSC  03.2
0589:  INCF   0F,F
058A:  BCF    03.0
058B:  BSF    03.5
058C:  BCF    03.6
058D:  DECFSZ 32,F
058E:  GOTO   519
*
0593:  BTFSC  33.7
0594:  GOTO   5A7
0595:  MOVLW  0F
0596:  MOVWF  77
0597:  SWAPF  32,W
0598:  ANDWF  77,F
0599:  MOVLW  0A
059A:  SUBWF  77,W
059B:  BTFSC  03.0
059C:  GOTO   5A0
059D:  MOVLW  30
059E:  ADDWF  77,F
059F:  GOTO   5A2
05A0:  MOVF   33,W
05A1:  ADDWF  77,F
05A2:  MOVF   77,W
05A3:  MOVWF  36
05A4:  BCF    03.5
05A5:  CALL   24B
05A6:  BSF    03.5
05A7:  MOVLW  0F
05A8:  ANDWF  32,F
05A9:  MOVLW  0A
05AA:  SUBWF  32,W
05AB:  BTFSC  03.0
05AC:  GOTO   5AF
05AD:  MOVLW  30
05AE:  GOTO   5B1
05AF:  BCF    33.7
05B0:  MOVF   33,W
05B1:  ADDWF  32,F
05B2:  MOVF   32,W
05B3:  MOVWF  36
05B4:  BCF    03.5
05B5:  CALL   24B
*
0774:  MOVF   71,W
0775:  MOVWF  04
0776:  BCF    03.7
0777:  BTFSC  72.0
0778:  BSF    03.7
0779:  BSF    03.5
077A:  MOVF   34,W
077B:  MOVWF  00
077C:  INCF   04,F
077D:  CLRF   00
077E:  INCF   71,F
077F:  BTFSC  03.2
0780:  INCF   72,F
0781:  BCF    03.5
0782:  RETURN
0783:  BSF    03.5
0784:  BTFSC  33.7
0785:  GOTO   798
0786:  MOVLW  0F
0787:  MOVWF  77
0788:  SWAPF  32,W
0789:  ANDWF  77,F
078A:  MOVLW  0A
078B:  SUBWF  77,W
078C:  BTFSC  03.0
078D:  GOTO   791
078E:  MOVLW  30
078F:  ADDWF  77,F
0790:  GOTO   793
0791:  MOVF   33,W
0792:  ADDWF  77,F
0793:  MOVF   77,W
0794:  MOVWF  34
0795:  BCF    03.5
0796:  CALL   774
0797:  BSF    03.5
0798:  MOVLW  0F
0799:  ANDWF  32,F
079A:  MOVLW  0A
079B:  SUBWF  32,W
079C:  BTFSC  03.0
079D:  GOTO   7A0
079E:  MOVLW  30
079F:  GOTO   7A2
07A0:  BCF    33.7
07A1:  MOVF   33,W
07A2:  ADDWF  32,F
07A3:  MOVF   32,W
07A4:  MOVWF  34
07A5:  BCF    03.5
07A6:  CALL   774
07A7:  RETURN
07A8:  MOVF   00,F
07A9:  BTFSC  03.2
07AA:  GOTO   7C5
07AB:  BSF    03.5
07AC:  CLRF   32
07AD:  MOVF   04,W
07AE:  MOVWF  31
07AF:  BCF    32.0
07B0:  BTFSC  03.7
07B1:  BSF    32.0
07B2:  MOVF   00,W
07B3:  BCF    03.5
07B4:  BTFSS  0C.4
07B5:  GOTO   7B4
07B6:  MOVWF  19
07B7:  BSF    03.5
07B8:  MOVF   31,W
07B9:  MOVWF  04
07BA:  BCF    03.7
07BB:  BTFSC  32.0
07BC:  BSF    03.7
07BD:  INCF   04,F
07BE:  BTFSS  03.2
07BF:  GOTO   7C3
07C0:  BCF    03.5
07C1:  INCF   05,F
07C2:  BSF    03.5
07C3:  BCF    03.5
07C4:  GOTO   7A8
07C5:  RETURN
....................  
.................... #list 
....................  
.................... //#include<18F45K22.h> 
.................... #fuses NOPROTECT,NOLVP,NOWDT 
.................... #use delay(crystal=4000000) 
*
0104:  MOVLW  D4
0105:  MOVWF  04
0106:  BCF    03.7
0107:  MOVF   00,W
0108:  BTFSC  03.2
0109:  GOTO   118
010A:  MOVLW  01
010B:  MOVWF  78
010C:  CLRF   77
010D:  DECFSZ 77,F
010E:  GOTO   10D
010F:  DECFSZ 78,F
0110:  GOTO   10C
0111:  MOVLW  4A
0112:  MOVWF  77
0113:  DECFSZ 77,F
0114:  GOTO   113
0115:  GOTO   116
0116:  DECFSZ 00,F
0117:  GOTO   10A
0118:  RETURN
.................... #use rs232( baud=19200, xmit=PIN_C6, rcv=PIN_C7, bits=8,ERRORS) 
....................  
.................... //LCD module connections 
.................... #define LCD_RS_PIN PIN_D0 
.................... #define LCD_RW_PIN PIN_D1 
.................... #define LCD_ENABLE_PIN PIN_D2 
.................... #define LCD_DATA4 PIN_D4 
.................... #define LCD_DATA5 PIN_D5 
.................... #define LCD_DATA6 PIN_D6 
.................... #define LCD_DATA7 PIN_D7 
.................... //End LCD module connections 
....................  
.................... #define CS PIN_A5 
....................  
....................  
....................  
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
0189:  BSF    08.4
....................    output_float(LCD_DATA5); 
018A:  BSF    08.5
....................    output_float(LCD_DATA6); 
018B:  BSF    08.6
....................    output_float(LCD_DATA7); 
018C:  BSF    08.7
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
018D:  BCF    03.5
018E:  BSF    08.1
018F:  BSF    03.5
0190:  BCF    08.1
....................    delay_cycles(1); 
0191:  NOP
....................    lcd_output_enable(1); 
0192:  BCF    03.5
0193:  BSF    08.2
0194:  BSF    03.5
0195:  BCF    08.2
....................    delay_cycles(1); 
0196:  NOP
....................    high = lcd_read_nibble(); 
0197:  BCF    03.5
0198:  CALL   14E
0199:  MOVF   78,W
019A:  BSF    03.5
019B:  MOVWF  3E
....................        
....................    lcd_output_enable(0); 
019C:  BCF    03.5
019D:  BCF    08.2
019E:  BSF    03.5
019F:  BCF    08.2
....................    delay_cycles(1); 
01A0:  NOP
....................    lcd_output_enable(1); 
01A1:  BCF    03.5
01A2:  BSF    08.2
01A3:  BSF    03.5
01A4:  BCF    08.2
....................    delay_us(1); 
01A5:  NOP
....................    low = lcd_read_nibble(); 
01A6:  BCF    03.5
01A7:  CALL   14E
01A8:  MOVF   78,W
01A9:  BSF    03.5
01AA:  MOVWF  3D
....................        
....................    lcd_output_enable(0); 
01AB:  BCF    03.5
01AC:  BCF    08.2
01AD:  BSF    03.5
01AE:  BCF    08.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
01AF:  BCF    08.4
....................    output_drive(LCD_DATA5); 
01B0:  BCF    08.5
....................    output_drive(LCD_DATA6); 
01B1:  BCF    08.6
....................    output_drive(LCD_DATA7); 
01B2:  BCF    08.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
01B3:  SWAPF  3E,W
01B4:  MOVWF  77
01B5:  MOVLW  F0
01B6:  ANDWF  77,F
01B7:  MOVF   77,W
01B8:  IORWF  3D,W
01B9:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
014E:  BSF    03.5
014F:  CLRF   3F
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
0150:  BSF    08.4
0151:  MOVLW  00
0152:  BCF    03.5
0153:  BTFSC  08.4
0154:  MOVLW  01
0155:  BSF    03.5
0156:  IORWF  3F,F
....................    n |= input(LCD_DATA5) << 1; 
0157:  BSF    08.5
0158:  MOVLW  00
0159:  BCF    03.5
015A:  BTFSC  08.5
015B:  MOVLW  01
015C:  MOVWF  77
015D:  BCF    03.0
015E:  RLF    77,F
015F:  MOVF   77,W
0160:  BSF    03.5
0161:  IORWF  3F,F
....................    n |= input(LCD_DATA6) << 2; 
0162:  BSF    08.6
0163:  MOVLW  00
0164:  BCF    03.5
0165:  BTFSC  08.6
0166:  MOVLW  01
0167:  MOVWF  77
0168:  RLF    77,F
0169:  RLF    77,F
016A:  MOVLW  FC
016B:  ANDWF  77,F
016C:  MOVF   77,W
016D:  BSF    03.5
016E:  IORWF  3F,F
....................    n |= input(LCD_DATA7) << 3; 
016F:  BSF    08.7
0170:  MOVLW  00
0171:  BCF    03.5
0172:  BTFSC  08.7
0173:  MOVLW  01
0174:  MOVWF  77
0175:  RLF    77,F
0176:  RLF    77,F
0177:  RLF    77,F
0178:  MOVLW  F8
0179:  ANDWF  77,F
017A:  MOVF   77,W
017B:  BSF    03.5
017C:  IORWF  3F,F
....................     
....................    return(n); 
017D:  MOVF   3F,W
017E:  MOVWF  78
....................   #else 
017F:  BCF    03.5
0180:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
0119:  BSF    03.5
011A:  BTFSC  3E.0
011B:  GOTO   120
011C:  BCF    03.5
011D:  BCF    08.4
011E:  GOTO   122
011F:  BSF    03.5
0120:  BCF    03.5
0121:  BSF    08.4
0122:  BSF    03.5
0123:  BCF    08.4
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
0124:  BTFSC  3E.1
0125:  GOTO   12A
0126:  BCF    03.5
0127:  BCF    08.5
0128:  GOTO   12C
0129:  BSF    03.5
012A:  BCF    03.5
012B:  BSF    08.5
012C:  BSF    03.5
012D:  BCF    08.5
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
012E:  BTFSC  3E.2
012F:  GOTO   134
0130:  BCF    03.5
0131:  BCF    08.6
0132:  GOTO   136
0133:  BSF    03.5
0134:  BCF    03.5
0135:  BSF    08.6
0136:  BSF    03.5
0137:  BCF    08.6
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
0138:  BTFSC  3E.3
0139:  GOTO   13E
013A:  BCF    03.5
013B:  BCF    08.7
013C:  GOTO   140
013D:  BSF    03.5
013E:  BCF    03.5
013F:  BSF    08.7
0140:  BSF    03.5
0141:  BCF    08.7
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
0142:  NOP
....................    lcd_output_enable(1); 
0143:  BCF    03.5
0144:  BSF    08.2
0145:  BSF    03.5
0146:  BCF    08.2
....................    delay_us(2); 
0147:  GOTO   148
....................    lcd_output_enable(0); 
0148:  BCF    03.5
0149:  BCF    08.2
014A:  BSF    03.5
014B:  BCF    08.2
014C:  BCF    03.5
014D:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
0181:  BSF    03.5
0182:  BCF    08.2
....................    lcd_rs_tris(); 
0183:  BCF    08.0
....................    lcd_rw_tris(); 
0184:  BCF    08.1
....................   #endif 
....................  
....................    lcd_output_rs(0); 
0185:  BCF    03.5
0186:  BCF    08.0
0187:  BSF    03.5
0188:  BCF    08.0
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
01BA:  MOVF   78,W
01BB:  MOVWF  3D
01BC:  BTFSC  3D.7
01BD:  GOTO   189
....................    lcd_output_rs(address); 
01BE:  MOVF   3B,F
01BF:  BTFSS  03.2
01C0:  GOTO   1C5
01C1:  BCF    03.5
01C2:  BCF    08.0
01C3:  GOTO   1C7
01C4:  BSF    03.5
01C5:  BCF    03.5
01C6:  BSF    08.0
01C7:  BSF    03.5
01C8:  BCF    08.0
....................    delay_cycles(1); 
01C9:  NOP
....................    lcd_output_rw(0); 
01CA:  BCF    03.5
01CB:  BCF    08.1
01CC:  BSF    03.5
01CD:  BCF    08.1
....................    delay_cycles(1); 
01CE:  NOP
....................    lcd_output_enable(0); 
01CF:  BCF    03.5
01D0:  BCF    08.2
01D1:  BSF    03.5
01D2:  BCF    08.2
....................    lcd_send_nibble(n >> 4); 
01D3:  SWAPF  3C,W
01D4:  MOVWF  3D
01D5:  MOVLW  0F
01D6:  ANDWF  3D,F
01D7:  MOVF   3D,W
01D8:  MOVWF  3E
01D9:  BCF    03.5
01DA:  CALL   119
....................    lcd_send_nibble(n & 0xf); 
01DB:  BSF    03.5
01DC:  MOVF   3C,W
01DD:  ANDLW  0F
01DE:  MOVWF  3D
01DF:  MOVWF  3E
01E0:  BCF    03.5
01E1:  CALL   119
01E2:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
01E3:  MOVLW  28
01E4:  BSF    03.5
01E5:  MOVWF  32
01E6:  MOVLW  0C
01E7:  MOVWF  33
01E8:  MOVLW  01
01E9:  MOVWF  34
01EA:  MOVLW  06
01EB:  MOVWF  35
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
01EC:  BCF    03.5
01ED:  BCF    08.2
01EE:  BSF    03.5
01EF:  BCF    08.2
....................    lcd_output_rs(0); 
01F0:  BCF    03.5
01F1:  BCF    08.0
01F2:  BSF    03.5
01F3:  BCF    08.0
....................    lcd_output_rw(0); 
01F4:  BCF    03.5
01F5:  BCF    08.1
01F6:  BSF    03.5
01F7:  BCF    08.1
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
01F8:  BCF    08.4
....................    output_drive(LCD_DATA5); 
01F9:  BCF    08.5
....................    output_drive(LCD_DATA6); 
01FA:  BCF    08.6
....................    output_drive(LCD_DATA7); 
01FB:  BCF    08.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
01FC:  BCF    08.2
....................    lcd_rs_tris(); 
01FD:  BCF    08.0
....................    lcd_rw_tris(); 
01FE:  BCF    08.1
....................  #endif 
....................      
....................    delay_ms(15); 
01FF:  MOVLW  0F
0200:  MOVWF  54
0201:  BCF    03.5
0202:  CALL   104
....................    for(i=1;i<=3;++i) 
0203:  MOVLW  01
0204:  BSF    03.5
0205:  MOVWF  31
0206:  MOVF   31,W
0207:  SUBLW  03
0208:  BTFSS  03.0
0209:  GOTO   216
....................    { 
....................        lcd_send_nibble(3); 
020A:  MOVLW  03
020B:  MOVWF  3E
020C:  BCF    03.5
020D:  CALL   119
....................        delay_ms(5); 
020E:  MOVLW  05
020F:  BSF    03.5
0210:  MOVWF  54
0211:  BCF    03.5
0212:  CALL   104
0213:  BSF    03.5
0214:  INCF   31,F
0215:  GOTO   206
....................    } 
....................     
....................    lcd_send_nibble(2); 
0216:  MOVLW  02
0217:  MOVWF  3E
0218:  BCF    03.5
0219:  CALL   119
....................    delay_ms(5); 
021A:  MOVLW  05
021B:  BSF    03.5
021C:  MOVWF  54
021D:  BCF    03.5
021E:  CALL   104
....................    for(i=0;i<=3;++i) 
021F:  BSF    03.5
0220:  CLRF   31
0221:  MOVF   31,W
0222:  SUBLW  03
0223:  BTFSS  03.0
0224:  GOTO   233
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
0225:  MOVLW  B2
0226:  ADDWF  31,W
0227:  MOVWF  04
0228:  BCF    03.7
0229:  MOVF   00,W
022A:  MOVWF  36
022B:  CLRF   3B
022C:  MOVF   36,W
022D:  MOVWF  3C
022E:  BCF    03.5
022F:  CALL   181
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0230:  BSF    03.5
0231:  INCF   31,F
0232:  GOTO   221
0233:  BCF    03.5
0234:  BSF    0A.3
0235:  BCF    0A.4
0236:  GOTO   2D1 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
0237:  BSF    03.5
0238:  DECFSZ 38,W
0239:  GOTO   23B
023A:  GOTO   23E
....................       address=LCD_LINE_TWO; 
023B:  MOVLW  40
023C:  MOVWF  39
023D:  GOTO   23F
....................    else 
....................       address=0; 
023E:  CLRF   39
....................       
....................    address+=x-1; 
023F:  MOVLW  01
0240:  SUBWF  37,W
0241:  ADDWF  39,F
....................    lcd_send_byte(0,0x80|address); 
0242:  MOVF   39,W
0243:  IORLW  80
0244:  MOVWF  3A
0245:  CLRF   3B
0246:  MOVF   3A,W
0247:  MOVWF  3C
0248:  BCF    03.5
0249:  CALL   181
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
024A:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
024B:  BSF    03.5
024C:  MOVF   36,W
024D:  XORLW  07
024E:  BCF    03.5
024F:  BTFSC  03.2
0250:  GOTO   25B
0251:  XORLW  0B
0252:  BTFSC  03.2
0253:  GOTO   262
0254:  XORLW  06
0255:  BTFSC  03.2
0256:  GOTO   26E
0257:  XORLW  02
0258:  BTFSC  03.2
0259:  GOTO   276
025A:  GOTO   27D
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
025B:  MOVLW  01
025C:  BSF    03.5
025D:  MOVWF  37
025E:  MOVWF  38
025F:  BCF    03.5
0260:  CALL   237
0261:  GOTO   284
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
0262:  BSF    03.5
0263:  CLRF   3B
0264:  MOVLW  01
0265:  MOVWF  3C
0266:  BCF    03.5
0267:  CALL   181
....................                      delay_ms(2); 
0268:  MOVLW  02
0269:  BSF    03.5
026A:  MOVWF  54
026B:  BCF    03.5
026C:  CALL   104
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
026D:  GOTO   284
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
026E:  MOVLW  01
026F:  BSF    03.5
0270:  MOVWF  37
0271:  MOVLW  02
0272:  MOVWF  38
0273:  BCF    03.5
0274:  CALL   237
0275:  GOTO   284
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
0276:  BSF    03.5
0277:  CLRF   3B
0278:  MOVLW  10
0279:  MOVWF  3C
027A:  BCF    03.5
027B:  CALL   181
027C:  GOTO   284
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
027D:  MOVLW  01
027E:  BSF    03.5
027F:  MOVWF  3B
0280:  MOVF   36,W
0281:  MOVWF  3C
0282:  BCF    03.5
0283:  CALL   181
....................      #endif 
....................    } 
0284:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
0A86:  BCF    03.5
0A87:  CLRF   21
0A88:  CLRF   22
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... //spi modes 
.................... #define SPI_MODE_0  (SPI_L_TO_H | SPI_XMIT_L_TO_H) 
.................... #define SPI_MODE_1  (SPI_L_TO_H) 
.................... #define SPI_MODE_2  (SPI_H_TO_L) 
.................... #define SPI_MODE_3  (SPI_H_TO_L | SPI_XMIT_L_TO_H) 
....................  
.................... #include "rfid.h" 
.................... /*  
....................  * File:   rfid.h 
....................  * Author: Shashikant 
....................  * 
....................  * Created on 2 July, 2018, 1:34 PM 
....................  */ 
....................  
.................... #ifndef RFID_H 
.................... #define	RFID_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................  
....................  
....................  
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* RFID_H */ 
....................  
.................... #define     MAX_LEN               16        // Maximum length of an array. CHECK IF IT IS MAXIMUM LENGTH/SIZE OF FIFO!!!!!!!!!!! 
....................  
.................... //MF522 MFRC522 error codes. 
.................... #define     MI_OK                 0         // Everything A-OK. 
.................... #define     MI_NOTAGERR           1         // No tag error 
.................... #define     MI_ERR                2         // General error 
....................  
.................... //MF522 Command word 
.................... #define     MFRC522_IDLE          0x00      // NO action; Cancel the current command 
.................... #define     MFRC522_MEM           0x01      // Store 25 byte into the internal buffer. 
.................... #define     MFRC522_GENID         0x02      // Generates a 10 byte random ID number. 
.................... #define     MFRC522_CALCCRC       0x03      // CRC Calculate or selftest. 
.................... #define     MFRC522_TRANSMIT      0x04      // Transmit data 
.................... #define     MFRC522_NOCMDCH       0x07      // No command change. 
.................... #define     MFRC522_RECEIVE       0x08      // Receive Data 
.................... #define     MFRC522_TRANSCEIVE    0x0C      // Transmit and receive data, 
.................... #define     MFRC522_AUTHENT       0x0E      // Authentication Key 
.................... #define     MFRC522_SOFTRESET     0x0F      // Reset 
....................  
.................... //Mifare_One tag command word 
.................... #define     MF1_REQIDL            0x26      // find the antenna area does not enter hibernation 
.................... #define     MF1_REQALL            0x52      // find all the tags antenna area 
.................... #define     MF1_ANTICOLL          0x93      // anti-collision 
.................... #define     MF1_SELECTTAG         0x93      // election tag 
.................... #define     MF1_AUTHENT1A         0x60      // authentication key A 
.................... #define     MF1_AUTHENT1B         0x61      // authentication key B 
.................... #define     MF1_READ              0x30      // Read Block 
.................... #define     MF1_WRITE             0xA0      // write block 
.................... #define     MF1_DECREMENT         0xC0      // debit 
.................... #define     MF1_INCREMENT         0xC1      // recharge 
.................... #define     MF1_RESTORE           0xC2      // transfer block data to the buffer 
.................... #define     MF1_TRANSFER          0xB0      // save the data in the buffer 
.................... #define     MF1_HALT              0x50      // Sleep 
....................  
....................  
.................... //------------------ MFRC522 registers--------------- 
.................... //Page 0:Command and Status 
.................... #define     Reserved00            0x00 
.................... #define     CommandReg            0x01 
.................... #define     CommIEnReg            0x02 
.................... #define     DivIEnReg             0x03 
.................... #define     CommIrqReg            0x04 
.................... #define     DivIrqReg             0x05 
.................... #define     ErrorReg              0x06 
.................... #define     Status1Reg            0x07 
.................... #define     Status2Reg            0x08 
.................... #define     FIFODataReg           0x09 
.................... #define     FIFOLevelReg          0x0A 
.................... #define     WaterLevelReg         0x0B 
.................... #define     ControlReg            0x0C 
.................... #define     BitFramingReg         0x0D 
.................... #define     CollReg               0x0E 
.................... #define     Reserved01            0x0F 
.................... //Page 1:Command 
.................... #define     Reserved10            0x10 
.................... #define     ModeReg               0x11 
.................... #define     TxModeReg             0x12 
.................... #define     RxModeReg             0x13 
.................... #define     TxControlReg          0x14 
.................... #define     TxAutoReg             0x15 
.................... #define     TxSelReg              0x16 
.................... #define     RxSelReg              0x17 
.................... #define     RxThresholdReg        0x18 
.................... #define     DemodReg              0x19 
.................... #define     Reserved11            0x1A 
.................... #define     Reserved12            0x1B 
.................... #define     MifareReg             0x1C 
.................... #define     Reserved13            0x1D 
.................... #define     Reserved14            0x1E 
.................... #define     SerialSpeedReg        0x1F 
.................... //Page 2:CFG 
.................... #define     Reserved20            0x20 
.................... #define     CRCResultRegM         0x21 
.................... #define     CRCResultRegL         0x22 
.................... #define     Reserved21            0x23 
.................... #define     ModWidthReg           0x24 
.................... #define     Reserved22            0x25 
.................... #define     RFCfgReg              0x26 
.................... #define     GsNReg                0x27 
.................... #define     CWGsPReg              0x28 
.................... #define     ModGsPReg             0x29 
.................... #define     TModeReg              0x2A 
.................... #define     TPrescalerReg         0x2B 
.................... #define     TReloadRegH           0x2C 
.................... #define     TReloadRegL           0x2D 
.................... #define     TCounterValueRegH     0x2E 
.................... #define     TCounterValueRegL     0x2F 
.................... //Page 3:TestRegister 
.................... #define     Reserved30            0x30 
.................... #define     TestSel1Reg           0x31 
.................... #define     TestSel2Reg           0x32 
.................... #define     TestPinEnReg          0x33 
.................... #define     TestPinValueReg       0x34 
.................... #define     TestBusReg            0x35 
.................... #define     AutoTestReg           0x36 
.................... #define     VersionReg            0x37 
.................... #define     AnalogTestReg         0x38 
.................... #define     TestDAC1Reg           0x39 
.................... #define     TestDAC2Reg           0x3A 
.................... #define     TestADCReg            0x3B 
.................... #define     Reserved31            0x3C 
.................... #define     Reserved32            0x3D 
.................... #define     Reserved33            0x3E 
.................... #define     Reserved34            0x3F 
.................... //-----------------------------------------------  
....................  
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Writes value to a register. 
....................   @param   addr  The address a register. 
....................   @param   val   The value to write to a register. 
....................  */ 
.................... /**************************************************************************/ 
.................... void writeToRegister(byte addr, byte val) { 
....................   output_low(CS); 
*
036F:  BSF    03.5
0370:  BCF    05.5
0371:  BCF    03.5
0372:  BCF    05.5
....................   //Address format: 0XXXXXX0 
....................   spi_write((addr<<1)&0x7E); 
0373:  BCF    03.0
0374:  BSF    03.5
0375:  RLF    58,W
0376:  ANDLW  7E
0377:  MOVWF  5A
0378:  BCF    03.5
0379:  MOVF   13,W
037A:  BSF    03.5
037B:  MOVF   5A,W
037C:  BCF    03.5
037D:  MOVWF  13
037E:  BSF    03.5
037F:  RRF    14,W
0380:  BTFSS  03.0
0381:  GOTO   37F
....................   spi_write(val); 
0382:  BCF    03.5
0383:  MOVF   13,W
0384:  BSF    03.5
0385:  MOVF   59,W
0386:  BCF    03.5
0387:  MOVWF  13
0388:  BSF    03.5
0389:  RRF    14,W
038A:  BTFSS  03.0
038B:  GOTO   389
....................   output_high(CS); 
038C:  BCF    05.5
038D:  BCF    03.5
038E:  BSF    05.5
038F:  RETURN
.................... } 
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Reads the value at a register. 
....................   @param   addr  The address a register. 
....................   @returns The byte at the register. 
....................  */ 
.................... /**************************************************************************/ 
.................... byte readFromRegister(byte addr) { 
....................   byte val; 
....................   output_low(CS); 
0390:  BSF    03.5
0391:  BCF    05.5
0392:  BCF    03.5
0393:  BCF    05.5
....................   spi_write(((addr<<1)&0x7E) | 0x80); 
0394:  BCF    03.0
0395:  BSF    03.5
0396:  RLF    57,W
0397:  ANDLW  7E
0398:  IORLW  80
0399:  MOVWF  59
039A:  BCF    03.5
039B:  MOVF   13,W
039C:  BSF    03.5
039D:  MOVF   59,W
039E:  BCF    03.5
039F:  MOVWF  13
03A0:  BSF    03.5
03A1:  RRF    14,W
03A2:  BTFSS  03.0
03A3:  GOTO   3A1
....................   val =spi_read(0x00); 
03A4:  BCF    03.5
03A5:  MOVF   13,W
03A6:  CLRF   13
03A7:  BSF    03.5
03A8:  RRF    14,W
03A9:  BTFSS  03.0
03AA:  GOTO   3A8
03AB:  BCF    03.5
03AC:  MOVF   13,W
03AD:  BSF    03.5
03AE:  MOVWF  58
....................   output_high(CS); 
03AF:  BCF    05.5
03B0:  BCF    03.5
03B1:  BSF    05.5
....................   return val; 
03B2:  BSF    03.5
03B3:  MOVF   58,W
03B4:  MOVWF  78
03B5:  BCF    03.5
03B6:  RETURN
.................... } 
....................  
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Adds a bitmask to a register. 
....................   @param   addr   The address a register. 
....................   @param   mask  The mask to update the register with. 
....................  */ 
.................... /**************************************************************************/ 
.................... void setBitMask(byte addr, byte mask) { 
....................   byte current; 
....................   current = readFromRegister(addr); 
03B7:  BSF    03.5
03B8:  MOVF   54,W
03B9:  MOVWF  57
03BA:  BCF    03.5
03BB:  CALL   390
03BC:  MOVF   78,W
03BD:  BSF    03.5
03BE:  MOVWF  56
....................   writeToRegister(addr, current | mask); 
03BF:  MOVF   56,W
03C0:  IORWF  55,W
03C1:  MOVWF  57
03C2:  MOVF   54,W
03C3:  MOVWF  58
03C4:  MOVF   57,W
03C5:  MOVWF  59
03C6:  BCF    03.5
03C7:  CALL   36F
03C8:  RETURN
.................... } 
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Removes a bitmask from the register. 
....................   @param   reg   The address a register. 
....................   @param   mask  The mask to update the register with. 
....................  */ 
.................... /**************************************************************************/ 
.................... void clearBitMask(byte addr, byte mask) { 
....................   byte current; 
....................   current = readFromRegister(addr); 
*
05DF:  BSF    03.5
05E0:  MOVF   54,W
05E1:  MOVWF  57
05E2:  BCF    03.5
05E3:  CALL   390
05E4:  MOVF   78,W
05E5:  BSF    03.5
05E6:  MOVWF  56
....................   writeToRegister(addr, current & (~mask)); 
05E7:  MOVF   55,W
05E8:  XORLW  FF
05E9:  ANDWF  56,W
05EA:  MOVWF  57
05EB:  MOVF   54,W
05EC:  MOVWF  58
05ED:  MOVF   57,W
05EE:  MOVWF  59
05EF:  BCF    03.5
05F0:  CALL   36F
05F1:  RETURN
.................... } 
....................  
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Sends a SOFTRESET command to the MFRC522 chip. 
....................  */ 
.................... /**************************************************************************/ 
.................... void reset() { 
....................   writeToRegister(CommandReg, MFRC522_SOFTRESET); 
*
03CD:  MOVLW  01
03CE:  BSF    03.5
03CF:  MOVWF  58
03D0:  MOVLW  0F
03D1:  MOVWF  59
03D2:  BCF    03.5
03D3:  CALL   36F
.................... } 
....................  
....................  
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Does the setup for the MFRC522. 
....................  */ 
.................... /**************************************************************************/ 
.................... void MFRC_begin() { 
....................   output_high(CS); 
*
03C9:  BSF    03.5
03CA:  BCF    05.5
03CB:  BCF    03.5
03CC:  BSF    05.5
....................   reset(); 
....................   //Timer: TPrescaler*TreloadVal/6.78MHz = 24ms 
....................   writeToRegister(TModeReg, 0x8D);    
*
03D4:  MOVLW  2A
03D5:  BSF    03.5
03D6:  MOVWF  58
03D7:  MOVLW  8D
03D8:  MOVWF  59
03D9:  BCF    03.5
03DA:  CALL   36F
....................   delay_ms(20); // Tauto=1; f(Timer) = 6.78MHz/TPreScaler 
03DB:  MOVLW  14
03DC:  BSF    03.5
03DD:  MOVWF  54
03DE:  BCF    03.5
03DF:  CALL   104
....................   writeToRegister(TPrescalerReg, 0x3E);  // TModeReg[3..0] + TPrescalerReg 
03E0:  MOVLW  2B
03E1:  BSF    03.5
03E2:  MOVWF  58
03E3:  MOVLW  3E
03E4:  MOVWF  59
03E5:  BCF    03.5
03E6:  CALL   36F
....................   delay_ms(20); 
03E7:  MOVLW  14
03E8:  BSF    03.5
03E9:  MOVWF  54
03EA:  BCF    03.5
03EB:  CALL   104
....................   writeToRegister(TReloadRegL, 30); 
03EC:  MOVLW  2D
03ED:  BSF    03.5
03EE:  MOVWF  58
03EF:  MOVLW  1E
03F0:  MOVWF  59
03F1:  BCF    03.5
03F2:  CALL   36F
....................   delay_ms(20); 
03F3:  MOVLW  14
03F4:  BSF    03.5
03F5:  MOVWF  54
03F6:  BCF    03.5
03F7:  CALL   104
....................   writeToRegister(TReloadRegH, 0); 
03F8:  MOVLW  2C
03F9:  BSF    03.5
03FA:  MOVWF  58
03FB:  CLRF   59
03FC:  BCF    03.5
03FD:  CALL   36F
....................   delay_ms(20); 
03FE:  MOVLW  14
03FF:  BSF    03.5
0400:  MOVWF  54
0401:  BCF    03.5
0402:  CALL   104
....................   writeToRegister(TxAutoReg, 0x40);      // 100%ASK 
0403:  MOVLW  15
0404:  BSF    03.5
0405:  MOVWF  58
0406:  MOVLW  40
0407:  MOVWF  59
0408:  BCF    03.5
0409:  CALL   36F
....................   delay_ms(20); 
040A:  MOVLW  14
040B:  BSF    03.5
040C:  MOVWF  54
040D:  BCF    03.5
040E:  CALL   104
....................   writeToRegister(ModeReg, 0x3D);        // CRC initial value 0x6363 
040F:  MOVLW  11
0410:  BSF    03.5
0411:  MOVWF  58
0412:  MOVLW  3D
0413:  MOVWF  59
0414:  BCF    03.5
0415:  CALL   36F
....................   delay_ms(20); 
0416:  MOVLW  14
0417:  BSF    03.5
0418:  MOVWF  54
0419:  BCF    03.5
041A:  CALL   104
....................  //writeToRegister(TxControlReg, 0x82);      
....................   delay_ms(20); 
041B:  MOVLW  14
041C:  BSF    03.5
041D:  MOVWF  54
041E:  BCF    03.5
041F:  CALL   104
....................  setBitMask(TxControlReg, 0x03);        // Turn antenna on. 
0420:  MOVLW  14
0421:  BSF    03.5
0422:  MOVWF  54
0423:  MOVLW  03
0424:  MOVWF  55
0425:  BCF    03.5
0426:  CALL   3B7
0427:  BSF    0A.3
0428:  BCF    0A.4
0429:  GOTO   2ED (RETURN)
.................... } 
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Checks the firmware version of the chip. 
....................   @returns The firmware version of the MFRC522 chip. 
....................  */ 
.................... /**************************************************************************/ 
.................... byte getFirmwareVersion() { 
....................   byte response; 
....................   response = readFromRegister(VersionReg); 
....................   return response; 
.................... } 
....................  
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................  
....................   @brief   Sends a command to a tag. 
....................  
....................   @param   cmd     The command to the MFRC522 to send a command to the tag. 
....................   @param   data    The data that is needed to complete the command. 
....................   @param   dlen    The length of the data. 
....................   @param   result  The result returned by the tag. 
....................   @param   rlen    The number of valid bits in the resulting value. 
....................  
....................   @returns Returns the status of the calculation. 
....................            MI_ERR        if something went wrong, 
....................            MI_NOTAGERR   if there was no tag to send the command to. 
....................            MI_OK         if everything went OK. 
....................  
....................  */ 
.................... /**************************************************************************/ 
....................  
.................... int commandTag(byte cmd, byte *data, int dlen, byte *result, int *rlen) { 
*
05F2:  MOVLW  02
05F3:  BSF    03.5
05F4:  MOVWF  4E
05F5:  CLRF   4F
05F6:  CLRF   50
....................   int status = MI_ERR; 
....................   byte irqEn = 0x00; 
....................   byte waitIRq = 0x00; 
....................   byte lastBits, n; 
....................   int i; 
....................  
....................   switch (cmd) { 
05F7:  MOVF   46,W
05F8:  XORLW  0E
05F9:  BCF    03.5
05FA:  BTFSC  03.2
05FB:  GOTO   600
05FC:  XORLW  02
05FD:  BTFSC  03.2
05FE:  GOTO   606
05FF:  GOTO   60D
....................   case MFRC522_AUTHENT: 
....................     irqEn = 0x12; 
0600:  MOVLW  12
0601:  BSF    03.5
0602:  MOVWF  4F
....................     waitIRq = 0x10; 
0603:  MOVLW  10
0604:  MOVWF  50
....................     break; 
0605:  GOTO   60E
....................   case MFRC522_TRANSCEIVE: 
....................     irqEn = 0x77; 
0606:  MOVLW  77
0607:  BSF    03.5
0608:  MOVWF  4F
....................     waitIRq = 0x30; 
0609:  MOVLW  30
060A:  MOVWF  50
....................     break; 
060B:  GOTO   60E
060C:  BCF    03.5
....................   default: 
....................     break; 
060D:  BSF    03.5
....................   } 
....................  
....................   writeToRegister(CommIEnReg, irqEn|0x80);    // interrupt request 
060E:  MOVF   4F,W
060F:  IORLW  80
0610:  MOVWF  54
0611:  MOVLW  02
0612:  MOVWF  58
0613:  MOVF   54,W
0614:  MOVWF  59
0615:  BCF    03.5
0616:  CALL   36F
....................   clearBitMask(CommIrqReg, 0x80);             // Clear all interrupt requests bits. 
0617:  MOVLW  04
0618:  BSF    03.5
0619:  MOVWF  54
061A:  MOVLW  80
061B:  MOVWF  55
061C:  BCF    03.5
061D:  CALL   5DF
....................   setBitMask(FIFOLevelReg, 0x80);             // FlushBuffer=1, FIFO initialization. 
061E:  MOVLW  0A
061F:  BSF    03.5
0620:  MOVWF  54
0621:  MOVLW  80
0622:  MOVWF  55
0623:  BCF    03.5
0624:  CALL   3B7
....................  
....................   writeToRegister(CommandReg, MFRC522_IDLE);  // No action, cancel the current command. 
0625:  MOVLW  01
0626:  BSF    03.5
0627:  MOVWF  58
0628:  CLRF   59
0629:  BCF    03.5
062A:  CALL   36F
....................  
....................   // Write to FIFO 
....................   for (i=0; i < dlen; i++) { 
062B:  BSF    03.5
062C:  CLRF   53
062D:  MOVF   49,W
062E:  SUBWF  53,W
062F:  BTFSC  03.0
0630:  GOTO   642
....................     writeToRegister(FIFODataReg, data[i]); 
0631:  MOVF   53,W
0632:  ADDWF  47,W
0633:  MOVWF  04
0634:  BCF    03.7
0635:  BTFSC  48.0
0636:  BSF    03.7
0637:  MOVF   00,W
0638:  MOVWF  54
0639:  MOVLW  09
063A:  MOVWF  58
063B:  MOVF   54,W
063C:  MOVWF  59
063D:  BCF    03.5
063E:  CALL   36F
063F:  BSF    03.5
0640:  INCF   53,F
0641:  GOTO   62D
....................   } 
....................  
....................   // Execute the command. 
....................   writeToRegister(CommandReg, cmd); 
0642:  MOVLW  01
0643:  MOVWF  58
0644:  MOVF   46,W
0645:  MOVWF  59
0646:  BCF    03.5
0647:  CALL   36F
....................   if (cmd == MFRC522_TRANSCEIVE) { 
0648:  BSF    03.5
0649:  MOVF   46,W
064A:  SUBLW  0C
064B:  BTFSS  03.2
064C:  GOTO   654
....................     setBitMask(BitFramingReg, 0x80);  // StartSend=1, transmission of data starts 
064D:  MOVLW  0D
064E:  MOVWF  54
064F:  MOVLW  80
0650:  MOVWF  55
0651:  BCF    03.5
0652:  CALL   3B7
0653:  BSF    03.5
....................   } 
....................  
....................   // Waiting for the command to complete so we can receive data. 
....................   i = 25; // Max wait time is 25ms. 
0654:  MOVLW  19
0655:  MOVWF  53
....................   do { 
....................     delay_ms(1); 
0656:  MOVLW  01
0657:  MOVWF  54
0658:  BCF    03.5
0659:  CALL   104
....................     // CommIRqReg[7..0] 
....................     // Set1 TxIRq RxIRq IdleIRq HiAlerIRq LoAlertIRq ErrIRq TimerIRq 
....................     n = readFromRegister(CommIrqReg); 
065A:  MOVLW  04
065B:  BSF    03.5
065C:  MOVWF  57
065D:  BCF    03.5
065E:  CALL   390
065F:  MOVF   78,W
0660:  BSF    03.5
0661:  MOVWF  52
....................     i--; 
0662:  DECF   53,F
....................   } while ((i!=0) && !(n&0x01) && !(n&waitIRq)); 
0663:  MOVF   53,F
0664:  BTFSC  03.2
0665:  GOTO   66C
0666:  BTFSC  52.0
0667:  GOTO   66C
0668:  MOVF   52,W
0669:  ANDWF  50,W
066A:  BTFSC  03.2
066B:  GOTO   656
....................  
....................   clearBitMask(BitFramingReg, 0x80);  // StartSend=0 
066C:  MOVLW  0D
066D:  MOVWF  54
066E:  MOVLW  80
066F:  MOVWF  55
0670:  BCF    03.5
0671:  CALL   5DF
....................  
....................   if (i != 0) { // Request did not time out. 
0672:  BSF    03.5
0673:  MOVF   53,F
0674:  BTFSC  03.2
0675:  GOTO   6E9
....................     if(!(readFromRegister(ErrorReg) & 0x1D)) {  // BufferOvfl Collerr CRCErr ProtocolErr 
0676:  MOVLW  06
0677:  MOVWF  57
0678:  BCF    03.5
0679:  CALL   390
067A:  MOVF   78,W
067B:  ANDLW  1D
067C:  BTFSS  03.2
067D:  GOTO   6E6
....................       status = MI_OK; 
067E:  BSF    03.5
067F:  CLRF   4E
....................       if (n & irqEn & 0x01) { 
0680:  MOVF   52,W
0681:  ANDWF  4F,W
0682:  ANDLW  01
0683:  BTFSC  03.2
0684:  GOTO   687
....................         status = MI_NOTAGERR; 
0685:  MOVLW  01
0686:  MOVWF  4E
....................       } 
....................  
....................       if (cmd == MFRC522_TRANSCEIVE) { 
0687:  MOVF   46,W
0688:  SUBLW  0C
0689:  BTFSS  03.2
068A:  GOTO   6E4
....................         n = readFromRegister(FIFOLevelReg); 
068B:  MOVLW  0A
068C:  MOVWF  57
068D:  BCF    03.5
068E:  CALL   390
068F:  MOVF   78,W
0690:  BSF    03.5
0691:  MOVWF  52
....................         lastBits = readFromRegister(ControlReg) & 0x07; 
0692:  MOVLW  0C
0693:  MOVWF  57
0694:  BCF    03.5
0695:  CALL   390
0696:  MOVF   78,W
0697:  ANDLW  07
0698:  BSF    03.5
0699:  MOVWF  51
....................         if (lastBits) { 
069A:  MOVF   51,F
069B:  BTFSC  03.2
069C:  GOTO   6AE
....................           *rlen = (n-1)*8 + lastBits; 
069D:  MOVF   4C,W
069E:  MOVWF  04
069F:  BCF    03.7
06A0:  BTFSC  4D.0
06A1:  BSF    03.7
06A2:  MOVLW  01
06A3:  SUBWF  52,W
06A4:  MOVWF  77
06A5:  RLF    77,F
06A6:  RLF    77,F
06A7:  RLF    77,F
06A8:  MOVLW  F8
06A9:  ANDWF  77,F
06AA:  MOVF   77,W
06AB:  ADDWF  51,W
06AC:  MOVWF  00
....................         } else { 
06AD:  GOTO   6BB
....................           *rlen = n*8; 
06AE:  MOVF   4C,W
06AF:  MOVWF  04
06B0:  BCF    03.7
06B1:  BTFSC  4D.0
06B2:  BSF    03.7
06B3:  RLF    52,W
06B4:  MOVWF  77
06B5:  RLF    77,F
06B6:  RLF    77,F
06B7:  MOVLW  F8
06B8:  ANDWF  77,F
06B9:  MOVF   77,W
06BA:  MOVWF  00
....................         } 
....................  
....................         if (n == 0) { 
06BB:  MOVF   52,F
06BC:  BTFSS  03.2
06BD:  GOTO   6C0
....................           n = 1; 
06BE:  MOVLW  01
06BF:  MOVWF  52
....................         } 
....................  
....................         if (n > MAX_LEN) { 
06C0:  MOVF   52,W
06C1:  SUBLW  10
06C2:  BTFSC  03.0
06C3:  GOTO   6C6
....................           n = MAX_LEN; 
06C4:  MOVLW  10
06C5:  MOVWF  52
....................         } 
....................  
....................         // Reading the recieved data from FIFO. 
....................         for (i=0; i<n; i++) { 
06C6:  CLRF   53
06C7:  MOVF   52,W
06C8:  SUBWF  53,W
06C9:  BTFSC  03.0
06CA:  GOTO   6E4
....................           result[i] = readFromRegister(FIFODataReg); 
06CB:  MOVF   53,W
06CC:  ADDWF  4A,W
06CD:  MOVWF  78
06CE:  MOVF   4B,W
06CF:  MOVWF  7A
06D0:  BTFSC  03.0
06D1:  INCF   7A,F
06D2:  MOVF   78,W
06D3:  MOVWF  54
06D4:  MOVF   7A,W
06D5:  MOVWF  55
06D6:  MOVLW  09
06D7:  MOVWF  57
06D8:  BCF    03.5
06D9:  CALL   390
06DA:  BSF    03.5
06DB:  MOVF   54,W
06DC:  MOVWF  04
06DD:  BCF    03.7
06DE:  BTFSC  55.0
06DF:  BSF    03.7
06E0:  MOVF   78,W
06E1:  MOVWF  00
06E2:  INCF   53,F
06E3:  GOTO   6C7
....................         } 
....................       } 
....................     } else { 
06E4:  GOTO   6E9
06E5:  BCF    03.5
....................       status = MI_ERR; 
06E6:  MOVLW  02
06E7:  BSF    03.5
06E8:  MOVWF  4E
....................     } 
....................   } 
....................   return status; 
06E9:  MOVF   4E,W
06EA:  MOVWF  78
06EB:  BCF    03.5
06EC:  RETURN
.................... } 
....................  
....................  
.................... /**************************************************************************/ 
.................... /* 
....................  
....................   @brief   Checks to see if there is a tag in the vicinity. 
....................  
....................   @param   mode  The mode we are requsting in. 
....................   @param   type  If we find a tag, this will be the type of that tag. 
....................                  0x4400 = Mifare_UltraLight 
....................                  0x0400 = Mifare_One(S50) 
....................                  0x0200 = Mifare_One(S70) 
....................                  0x0800 = Mifare_Pro(X) 
....................                  0x4403 = Mifare_DESFire 
....................  
....................   @returns Returns the status of the request. 
....................            MI_ERR        if something went wrong, 
....................            MI_NOTAGERR   if there was no tag to send the command to. 
....................            MI_OK         if everything went OK. 
....................  
....................  */ 
.................... /**************************************************************************/ 
.................... int requestTag(byte mode, byte *data) { 
....................   int status, len; 
....................   writeToRegister(BitFramingReg, 0x07);  // TxLastBists = BitFramingReg[2..0] 
06ED:  MOVLW  0D
06EE:  BSF    03.5
06EF:  MOVWF  58
06F0:  MOVLW  07
06F1:  MOVWF  59
06F2:  BCF    03.5
06F3:  CALL   36F
....................  
....................   data[0] = mode; 
06F4:  BSF    03.5
06F5:  MOVF   32,W
06F6:  MOVWF  04
06F7:  BCF    03.7
06F8:  BTFSC  33.0
06F9:  BSF    03.7
06FA:  MOVF   31,W
06FB:  MOVWF  00
....................   status = commandTag(MFRC522_TRANSCEIVE, data, 1, data, &len); 
06FC:  MOVLW  0C
06FD:  MOVWF  46
06FE:  MOVF   33,W
06FF:  MOVWF  48
0700:  MOVF   32,W
0701:  MOVWF  47
0702:  MOVLW  01
0703:  MOVWF  49
0704:  MOVF   33,W
0705:  MOVWF  4B
0706:  MOVF   32,W
0707:  MOVWF  4A
0708:  CLRF   4D
0709:  MOVLW  B5
070A:  MOVWF  4C
070B:  BCF    03.5
070C:  CALL   5F2
070D:  MOVF   78,W
070E:  BSF    03.5
070F:  MOVWF  34
....................  
....................   if ((status != MI_OK) || (len != 0x10)) { 
0710:  MOVF   34,F
0711:  BTFSS  03.2
0712:  GOTO   717
0713:  MOVF   35,W
0714:  SUBLW  10
0715:  BTFSC  03.2
0716:  GOTO   719
....................     status = MI_ERR; 
0717:  MOVLW  02
0718:  MOVWF  34
....................   } 
....................  
....................   return status; 
0719:  MOVF   34,W
071A:  MOVWF  78
071B:  BCF    03.5
071C:  BSF    0A.3
071D:  BCF    0A.4
071E:  GOTO   2FA (RETURN)
.................... } 
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................  
....................   @brief   Handles collisions that might occur if there are multiple 
....................            tags available. 
....................  
....................   @param   serial  The serial nb of the tag. 
....................  
....................   @returns Returns the status of the collision detection. 
....................            MI_ERR        if something went wrong, 
....................            MI_NOTAGERR   if there was no tag to send the command to. 
....................            MI_OK         if everything went OK. 
....................  
....................  */ 
.................... /**************************************************************************/ 
.................... int antiCollision(byte *serial) { 
071F:  BSF    03.5
0720:  CLRF   36
....................   int status, i, len; 
....................   byte check = 0x00; 
....................  
....................   writeToRegister(BitFramingReg, 0x00);  // TxLastBits = BitFramingReg[2..0] 
0721:  MOVLW  0D
0722:  MOVWF  58
0723:  CLRF   59
0724:  BCF    03.5
0725:  CALL   36F
....................  
....................   serial[0] = MF1_ANTICOLL; 
0726:  BSF    03.5
0727:  MOVF   31,W
0728:  MOVWF  04
0729:  BCF    03.7
072A:  BTFSC  32.0
072B:  BSF    03.7
072C:  MOVLW  93
072D:  MOVWF  00
....................   serial[1] = 0x20; 
072E:  MOVLW  01
072F:  ADDWF  31,W
0730:  MOVWF  04
0731:  BCF    03.7
0732:  BTFSC  32.0
0733:  BSF    03.7
0734:  MOVLW  20
0735:  MOVWF  00
....................   status = commandTag(MFRC522_TRANSCEIVE, serial, 2, serial, &len); 
0736:  MOVLW  0C
0737:  MOVWF  46
0738:  MOVF   32,W
0739:  MOVWF  48
073A:  MOVF   31,W
073B:  MOVWF  47
073C:  MOVLW  02
073D:  MOVWF  49
073E:  MOVF   32,W
073F:  MOVWF  4B
0740:  MOVF   31,W
0741:  MOVWF  4A
0742:  CLRF   4D
0743:  MOVLW  B5
0744:  MOVWF  4C
0745:  BCF    03.5
0746:  CALL   5F2
0747:  MOVF   78,W
0748:  BSF    03.5
0749:  MOVWF  33
....................   len = len / 8; // len is in bits, and we want each byte. 
074A:  RRF    35,F
074B:  RRF    35,F
074C:  RRF    35,F
074D:  MOVLW  1F
074E:  ANDWF  35,F
....................   if (status == MI_OK) { 
074F:  MOVF   33,F
0750:  BTFSS  03.2
0751:  GOTO   76E
....................     // The checksum of the tag is the ^ of all the values. 
....................     for (i = 0; i < len-1; i++) { 
0752:  CLRF   34
0753:  MOVLW  01
0754:  SUBWF  35,W
0755:  SUBWF  34,W
0756:  BTFSC  03.0
0757:  GOTO   762
....................       check ^= serial[i]; 
0758:  MOVF   34,W
0759:  ADDWF  31,W
075A:  MOVWF  04
075B:  BCF    03.7
075C:  BTFSC  32.0
075D:  BSF    03.7
075E:  MOVF   00,W
075F:  XORWF  36,F
0760:  INCF   34,F
0761:  GOTO   753
....................     } 
....................     // The checksum should be the same as the one provided from the 
....................     // tag (serial[4]). 
....................     if (check != serial[i]) { 
0762:  MOVF   34,W
0763:  ADDWF  31,W
0764:  MOVWF  04
0765:  BCF    03.7
0766:  BTFSC  32.0
0767:  BSF    03.7
0768:  MOVF   00,W
0769:  SUBWF  36,W
076A:  BTFSC  03.2
076B:  GOTO   76E
....................       status = MI_ERR; 
076C:  MOVLW  02
076D:  MOVWF  33
....................     } 
....................   } 
....................  
....................   return status; 
076E:  MOVF   33,W
076F:  MOVWF  78
0770:  BCF    03.5
0771:  BSF    0A.3
0772:  BCF    0A.4
0773:  GOTO   310 (RETURN)
.................... } 
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................  
....................   @brief   Calculates the CRC value for some data that should be sent to 
....................            a tag. 
....................  
....................   @param   data    The data to calculate the value for. 
....................   @param   len     The length of the data. 
....................   @param   result  The result of the CRC calculation. 
....................  
....................  */ 
.................... /**************************************************************************/ 
.................... void calculateCRC(byte *data, int len, byte *result) { 
....................   int i; 
....................   byte n; 
....................  
....................   clearBitMask(DivIrqReg, 0x04);   // CRCIrq = 0 
*
0800:  MOVLW  05
0801:  BSF    03.5
0802:  MOVWF  54
0803:  MOVLW  04
0804:  MOVWF  55
0805:  BCF    0A.3
0806:  BCF    03.5
0807:  CALL   5DF
0808:  BSF    0A.3
....................   setBitMask(FIFOLevelReg, 0x80);  // Clear the FIFO pointer 
0809:  MOVLW  0A
080A:  BSF    03.5
080B:  MOVWF  54
080C:  MOVLW  80
080D:  MOVWF  55
080E:  BCF    0A.3
080F:  BCF    03.5
0810:  CALL   3B7
0811:  BSF    0A.3
....................  
....................   //Writing data to the FIFO. 
....................   for (i = 0; i < len; i++) { 
0812:  BSF    03.5
0813:  CLRF   45
0814:  MOVF   42,W
0815:  SUBWF  45,W
0816:  BTFSC  03.0
0817:  GOTO   02B
....................     writeToRegister(FIFODataReg, data[i]); 
0818:  MOVF   45,W
0819:  ADDWF  40,W
081A:  MOVWF  04
081B:  BCF    03.7
081C:  BTFSC  41.0
081D:  BSF    03.7
081E:  MOVF   00,W
081F:  MOVWF  47
0820:  MOVLW  09
0821:  MOVWF  58
0822:  MOVF   47,W
0823:  MOVWF  59
0824:  BCF    0A.3
0825:  BCF    03.5
0826:  CALL   36F
0827:  BSF    0A.3
0828:  BSF    03.5
0829:  INCF   45,F
082A:  GOTO   014
....................   } 
....................   writeToRegister(CommandReg, MFRC522_CALCCRC); 
082B:  MOVLW  01
082C:  MOVWF  58
082D:  MOVLW  03
082E:  MOVWF  59
082F:  BCF    0A.3
0830:  BCF    03.5
0831:  CALL   36F
0832:  BSF    0A.3
....................  
....................   // Wait for the CRC calculation to complete. 
....................   i = 0xFF; 
0833:  MOVLW  FF
0834:  BSF    03.5
0835:  MOVWF  45
....................   do { 
....................     n = readFromRegister(DivIrqReg); 
0836:  MOVLW  05
0837:  MOVWF  57
0838:  BCF    0A.3
0839:  BCF    03.5
083A:  CALL   390
083B:  BSF    0A.3
083C:  MOVF   78,W
083D:  BSF    03.5
083E:  MOVWF  46
....................     i--; 
083F:  DECF   45,F
....................   } while ((i != 0) && !(n & 0x04));  //CRCIrq = 1 
0840:  MOVF   45,F
0841:  BTFSC  03.2
0842:  GOTO   045
0843:  BTFSS  46.2
0844:  GOTO   036
....................  
....................   // Read the result from the CRC calculation. 
....................   result[0] = readFromRegister(CRCResultRegL); 
0845:  MOVF   43,W
0846:  MOVWF  47
0847:  MOVF   44,W
0848:  MOVWF  48
0849:  MOVLW  22
084A:  MOVWF  57
084B:  BCF    0A.3
084C:  BCF    03.5
084D:  CALL   390
084E:  BSF    0A.3
084F:  BSF    03.5
0850:  MOVF   47,W
0851:  MOVWF  04
0852:  BCF    03.7
0853:  BTFSC  48.0
0854:  BSF    03.7
0855:  MOVF   78,W
0856:  MOVWF  00
....................   result[1] = readFromRegister(CRCResultRegM); 
0857:  MOVLW  01
0858:  ADDWF  43,W
0859:  MOVWF  47
085A:  MOVF   44,W
085B:  MOVWF  48
085C:  BTFSC  03.0
085D:  INCF   48,F
085E:  MOVLW  21
085F:  MOVWF  57
0860:  BCF    0A.3
0861:  BCF    03.5
0862:  CALL   390
0863:  BSF    0A.3
0864:  BSF    03.5
0865:  MOVF   47,W
0866:  MOVWF  04
0867:  BCF    03.7
0868:  BTFSC  48.0
0869:  BSF    03.7
086A:  MOVF   78,W
086B:  MOVWF  00
086C:  BCF    03.5
086D:  RETURN
.................... } 
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Selects a tag for processing. 
....................   @param   serial  The serial number of the tag that is to be selected. 
....................   @returns The SAK response from the tag. 
....................  */ 
.................... /**************************************************************************/ 
.................... byte selectTag(byte *serial) { 
....................   int i, status, len; 
....................   byte sak; 
....................   byte buffer[9]; 
....................  
....................   buffer[0] = MF1_SELECTTAG; 
086E:  MOVLW  93
086F:  BSF    03.5
0870:  MOVWF  37
....................   buffer[1] = 0x70; 
0871:  MOVLW  70
0872:  MOVWF  38
....................   for (i = 0; i < 5; i++) { 
0873:  CLRF   33
0874:  MOVF   33,W
0875:  SUBLW  04
0876:  BTFSS  03.0
0877:  GOTO   094
....................     buffer[i+2] = serial[i]; 
0878:  MOVLW  02
0879:  ADDWF  33,W
087A:  ADDLW  B7
087B:  MOVWF  78
087C:  CLRF   7A
087D:  BTFSC  03.0
087E:  INCF   7A,F
087F:  MOVF   78,W
0880:  MOVWF  40
0881:  MOVF   7A,W
0882:  MOVWF  41
0883:  MOVF   33,W
0884:  ADDWF  31,W
0885:  MOVWF  04
0886:  BCF    03.7
0887:  BTFSC  32.0
0888:  BSF    03.7
0889:  MOVF   00,W
088A:  MOVWF  42
088B:  MOVF   40,W
088C:  MOVWF  04
088D:  BCF    03.7
088E:  BTFSC  41.0
088F:  BSF    03.7
0890:  MOVF   42,W
0891:  MOVWF  00
0892:  INCF   33,F
0893:  GOTO   074
....................   } 
....................   calculateCRC(buffer, 7, &buffer[7]); 
0894:  CLRF   41
0895:  MOVLW  B7
0896:  MOVWF  40
0897:  MOVLW  07
0898:  MOVWF  42
0899:  CLRF   44
089A:  MOVLW  BE
089B:  MOVWF  43
089C:  BCF    03.5
089D:  CALL   000
....................  
....................   status = commandTag(MFRC522_TRANSCEIVE, buffer, 9, buffer, &len); 
089E:  MOVLW  0C
089F:  BSF    03.5
08A0:  MOVWF  46
08A1:  CLRF   48
08A2:  MOVLW  B7
08A3:  MOVWF  47
08A4:  MOVLW  09
08A5:  MOVWF  49
08A6:  CLRF   4B
08A7:  MOVLW  B7
08A8:  MOVWF  4A
08A9:  CLRF   4D
08AA:  MOVLW  B5
08AB:  MOVWF  4C
08AC:  BCF    0A.3
08AD:  BCF    03.5
08AE:  CALL   5F2
08AF:  BSF    0A.3
08B0:  MOVF   78,W
08B1:  BSF    03.5
08B2:  MOVWF  34
....................  
....................   if ((status == MI_OK) && (len == 0x18)) { 
08B3:  MOVF   34,F
08B4:  BTFSS  03.2
08B5:  GOTO   0BD
08B6:  MOVF   35,W
08B7:  SUBLW  18
08B8:  BTFSS  03.2
08B9:  GOTO   0BD
....................     sak = buffer[0]; 
08BA:  MOVF   37,W
08BB:  MOVWF  36
....................   } 
08BC:  GOTO   0BE
....................   else { 
....................     sak = 0; 
08BD:  CLRF   36
....................   } 
....................  
....................   return sak; 
08BE:  MOVF   36,W
08BF:  MOVWF  78
08C0:  BCF    03.5
08C1:  BSF    0A.3
08C2:  BCF    0A.4
08C3:  GOTO   36C (RETURN)
.................... } 
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Handles the authentication between the tag and the reader. 
....................   @param   mode    What authentication key to use. 
....................   @param   block   The block that we want to read. 
....................   @param   key     The authentication key. 
....................   @param   serial  The serial of the tag. 
....................   @returns Returns the status of the collision detection. 
....................            MI_ERR        if something went wrong, 
....................            MI_OK         if everything went OK. 
....................  */ 
.................... /**************************************************************************/ 
.................... int authenticate(byte mode, byte block, byte *key, byte *serial) { 
....................   int i, status, len; 
....................   byte buffer[12]; 
....................  
....................   //Verify the command block address + sector + password + tag serial number 
....................   buffer[0] = mode;          // 0th byte is the mode 
08C4:  BSF    03.5
08C5:  MOVF   31,W
08C6:  MOVWF  3A
....................   buffer[1] = block;         // 1st byte is the block to address. 
08C7:  MOVF   32,W
08C8:  MOVWF  3B
....................   for (i = 0; i < 6; i++) {  // 2nd to 7th byte is the authentication key. 
08C9:  CLRF   37
08CA:  MOVF   37,W
08CB:  SUBLW  05
08CC:  BTFSS  03.0
08CD:  GOTO   0EA
....................     buffer[i+2] = key[i]; 
08CE:  MOVLW  02
08CF:  ADDWF  37,W
08D0:  ADDLW  BA
08D1:  MOVWF  78
08D2:  CLRF   7A
08D3:  BTFSC  03.0
08D4:  INCF   7A,F
08D5:  MOVF   78,W
08D6:  MOVWF  46
08D7:  MOVF   7A,W
08D8:  MOVWF  47
08D9:  MOVF   37,W
08DA:  ADDWF  33,W
08DB:  MOVWF  04
08DC:  BCF    03.7
08DD:  BTFSC  34.0
08DE:  BSF    03.7
08DF:  MOVF   00,W
08E0:  MOVWF  48
08E1:  MOVF   46,W
08E2:  MOVWF  04
08E3:  BCF    03.7
08E4:  BTFSC  47.0
08E5:  BSF    03.7
08E6:  MOVF   48,W
08E7:  MOVWF  00
08E8:  INCF   37,F
08E9:  GOTO   0CA
....................   } 
....................   for (i = 0; i < 4; i++) {  // 8th to 11th byte is the serial of the tag. 
08EA:  CLRF   37
08EB:  MOVF   37,W
08EC:  SUBLW  03
08ED:  BTFSS  03.0
08EE:  GOTO   10B
....................     buffer[i+8] = serial[i]; 
08EF:  MOVLW  08
08F0:  ADDWF  37,W
08F1:  ADDLW  BA
08F2:  MOVWF  78
08F3:  CLRF   7A
08F4:  BTFSC  03.0
08F5:  INCF   7A,F
08F6:  MOVF   78,W
08F7:  MOVWF  46
08F8:  MOVF   7A,W
08F9:  MOVWF  47
08FA:  MOVF   37,W
08FB:  ADDWF  35,W
08FC:  MOVWF  04
08FD:  BCF    03.7
08FE:  BTFSC  36.0
08FF:  BSF    03.7
0900:  MOVF   00,W
0901:  MOVWF  48
0902:  MOVF   46,W
0903:  MOVWF  04
0904:  BCF    03.7
0905:  BTFSC  47.0
0906:  BSF    03.7
0907:  MOVF   48,W
0908:  MOVWF  00
0909:  INCF   37,F
090A:  GOTO   0EB
....................   } 
....................  
....................   status = commandTag(MFRC522_AUTHENT, buffer, 12, buffer, &len); 
090B:  MOVLW  0E
090C:  MOVWF  46
090D:  CLRF   48
090E:  MOVLW  BA
090F:  MOVWF  47
0910:  MOVLW  0C
0911:  MOVWF  49
0912:  CLRF   4B
0913:  MOVLW  BA
0914:  MOVWF  4A
0915:  CLRF   4D
0916:  MOVLW  B9
0917:  MOVWF  4C
0918:  BCF    0A.3
0919:  BCF    03.5
091A:  CALL   5F2
091B:  BSF    0A.3
091C:  MOVF   78,W
091D:  BSF    03.5
091E:  MOVWF  38
....................  
....................   if ((status != MI_OK) || (!(readFromRegister(Status2Reg) & 0x08))) { 
091F:  MOVF   38,F
0920:  BTFSS  03.2
0921:  GOTO   12B
0922:  MOVLW  08
0923:  MOVWF  57
0924:  BCF    0A.3
0925:  BCF    03.5
0926:  CALL   390
0927:  BSF    0A.3
0928:  BTFSC  78.3
0929:  GOTO   12E
092A:  BSF    03.5
....................     status = MI_ERR; 
092B:  MOVLW  02
092C:  MOVWF  38
092D:  BCF    03.5
....................   } 
....................  
....................   return status; 
092E:  BSF    03.5
092F:  MOVF   38,W
0930:  MOVWF  78
0931:  BCF    03.5
0932:  RETURN
.................... } 
....................  
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Tries to read from the current (authenticated) tag. 
....................   @param   block   The block that we want to read. 
....................   @param   result  The resulting value returned from the tag. 
....................   @returns Returns the status of the collision detection. 
....................            MI_ERR        if something went wrong, 
....................            MI_OK         if everything went OK. 
....................  */ 
.................... /**************************************************************************/ 
.................... int readFromTag(byte block, byte *result) { 
....................   int status, len; 
....................  
....................   result[0] = MF1_READ; 
0933:  BSF    03.5
0934:  MOVF   32,W
0935:  MOVWF  04
0936:  BCF    03.7
0937:  BTFSC  33.0
0938:  BSF    03.7
0939:  MOVLW  30
093A:  MOVWF  00
....................   result[1] = block; 
093B:  MOVLW  01
093C:  ADDWF  32,W
093D:  MOVWF  04
093E:  BCF    03.7
093F:  BTFSC  33.0
0940:  BSF    03.7
0941:  MOVF   31,W
0942:  MOVWF  00
....................   calculateCRC(result, 2, &result[2]); 
0943:  MOVLW  02
0944:  ADDWF  32,W
0945:  MOVWF  78
0946:  MOVF   33,W
0947:  MOVWF  7A
0948:  BTFSC  03.0
0949:  INCF   7A,F
094A:  MOVF   78,W
094B:  MOVWF  36
094C:  MOVF   7A,W
094D:  MOVWF  37
094E:  MOVF   33,W
094F:  MOVWF  41
0950:  MOVF   32,W
0951:  MOVWF  40
0952:  MOVLW  02
0953:  MOVWF  42
0954:  MOVF   37,W
0955:  MOVWF  44
0956:  MOVF   36,W
0957:  MOVWF  43
0958:  BCF    03.5
0959:  CALL   000
....................   status = commandTag(MFRC522_TRANSCEIVE, result, 4, result, &len); 
095A:  MOVLW  0C
095B:  BSF    03.5
095C:  MOVWF  46
095D:  MOVF   33,W
095E:  MOVWF  48
095F:  MOVF   32,W
0960:  MOVWF  47
0961:  MOVLW  04
0962:  MOVWF  49
0963:  MOVF   33,W
0964:  MOVWF  4B
0965:  MOVF   32,W
0966:  MOVWF  4A
0967:  CLRF   4D
0968:  MOVLW  B5
0969:  MOVWF  4C
096A:  BCF    0A.3
096B:  BCF    03.5
096C:  CALL   5F2
096D:  BSF    0A.3
096E:  MOVF   78,W
096F:  BSF    03.5
0970:  MOVWF  34
....................  
....................   if ((status != MI_OK) || (len != 0x90)) { 
0971:  MOVF   34,F
0972:  BTFSS  03.2
0973:  GOTO   178
0974:  MOVF   35,W
0975:  SUBLW  90
0976:  BTFSC  03.2
0977:  GOTO   17A
....................     status = MI_ERR; 
0978:  MOVLW  02
0979:  MOVWF  34
....................   } 
....................  
....................   return status; 
097A:  MOVF   34,W
097B:  MOVWF  78
097C:  BCF    03.5
097D:  RETURN
.................... } 
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Tries to write to a block on the current tag. 
....................   @param   block  The block that we want to write to. 
....................   @param   data   The data that we should write to the block. 
....................   @returns Returns the status of the collision detection. 
....................            MI_ERR        if something went wrong, 
....................            MI_OK         if everything went OK. 
....................  */ 
.................... /**************************************************************************/ 
.................... int writeToTag(byte block, byte *data) { 
....................   int status, i, len; 
....................   byte buffer[18]; 
....................  
....................   buffer[0] = MF1_WRITE; 
....................   buffer[1] = block; 
....................   calculateCRC(buffer, 2, &buffer[2]); 
....................   status = commandTag(MFRC522_TRANSCEIVE, buffer, 4, buffer, &len); 
....................  
....................   if ((status != MI_OK) || (len != 4) || ((buffer[0] & 0x0F) != 0x0A)) { 
....................     status = MI_ERR; 
....................   } 
....................  
....................  
....................   if (status == MI_OK) { 
....................        
....................     for (i = 0; i < 16; i++) { 
....................       buffer[i] = data[i]; 
....................     } 
....................     calculateCRC(buffer, 16, &buffer[16]); 
....................     status = commandTag(MFRC522_TRANSCEIVE, buffer, 18, buffer, &len); 
....................  
....................     if ((status != MI_OK) || (len != 4) || ((buffer[0] & 0x0F) != 0x0A)) { 
....................       status = MI_ERR; 
....................     } 
....................   } 
....................  
....................   return status; 
.................... } 
....................  
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................   @brief   Sends a halt command to the current tag. 
....................   @returns Returns the result of the halt. 
....................            MI_ERR        If the command didn't complete properly. 
....................            MI_OK         If the command completed. 
....................  */ 
.................... /**************************************************************************/ 
.................... int haltTag() { 
....................   int status, len; 
....................   byte buffer[4]; 
....................  
....................   buffer[0] = MF1_HALT; 
*
07C6:  MOVLW  50
07C7:  BSF    03.5
07C8:  MOVWF  33
....................   buffer[1] = 0; 
07C9:  CLRF   34
....................   calculateCRC(buffer, 2, &buffer[2]); 
07CA:  CLRF   41
07CB:  MOVLW  B3
07CC:  MOVWF  40
07CD:  MOVLW  02
07CE:  MOVWF  42
07CF:  CLRF   44
07D0:  MOVLW  B5
07D1:  MOVWF  43
07D2:  BSF    0A.3
07D3:  BCF    03.5
07D4:  CALL   000
07D5:  BCF    0A.3
....................   status = commandTag(MFRC522_TRANSCEIVE, buffer, 4, buffer, &len); 
07D6:  MOVLW  0C
07D7:  BSF    03.5
07D8:  MOVWF  46
07D9:  CLRF   48
07DA:  MOVLW  B3
07DB:  MOVWF  47
07DC:  MOVLW  04
07DD:  MOVWF  49
07DE:  CLRF   4B
07DF:  MOVLW  B3
07E0:  MOVWF  4A
07E1:  CLRF   4D
07E2:  MOVLW  B2
07E3:  MOVWF  4C
07E4:  BCF    03.5
07E5:  CALL   5F2
07E6:  MOVF   78,W
07E7:  BSF    03.5
07E8:  MOVWF  31
....................   clearBitMask(Status2Reg, 0x08);  // turn off encryption 
07E9:  MOVLW  08
07EA:  MOVWF  54
07EB:  MOVWF  55
07EC:  BCF    03.5
07ED:  CALL   5DF
....................   return status; 
07EE:  BSF    03.5
07EF:  MOVF   31,W
07F0:  MOVWF  78
07F1:  BCF    03.5
07F2:  BSF    0A.3
07F3:  BCF    0A.4
07F4:  GOTO   3B4 (RETURN)
.................... } 
....................  
....................  
.................... //// 
.................... //  Mifare Card Types Depending upon the codes of SAK from AN1083.PDF 
.................... //// 
....................  
.................... enum MIFARE_CARD_TYPE { 
....................     UID_FAILED = 0x00, 
....................     UID_NOT_COMPLETE = 0x04, 
....................     MIFARE_MINI = 0x09, 
....................     MIFARE_CLASSIC_1K = 0x08, 
....................     MIFARE_CLASSIC_4K = 0x18, 
....................     MIFARE_DESFIRE = 0x20 
.................... }; 
....................  
....................  
....................  
....................  
.................... byte FoundTag; // Variable used to check if Tag was found 
.................... byte ReadTag; // Variable used to store anti-collision value to read Tag information 
.................... byte TagData[MAX_LEN]; // Variable used to store Full Tag Data 
.................... byte serial[5]; 
.................... byte i; //for looping 
.................... byte j; //for looping again 
.................... byte status; // to store the return status of command operations 
.................... byte data[MAX_LEN]; //to store any data 
....................  
.................... char buffer2[20]; 
....................  
.................... //keys for the card 
.................... byte keyA[6] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}; 
*
0A89:  MOVLW  FF
0A8A:  MOVWF  65
0A8B:  MOVWF  66
0A8C:  MOVWF  67
0A8D:  MOVWF  68
0A8E:  MOVWF  69
0A8F:  MOVWF  6A
.................... byte keyB[6] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}; 
0A90:  MOVWF  6B
0A91:  MOVWF  6C
0A92:  MOVWF  6D
0A93:  MOVWF  6E
0A94:  MOVWF  6F
0A95:  MOVWF  70
....................  
....................  
.................... //writeable data  
.................... byte writeData[] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10}; 
0A96:  MOVLW  01
0A97:  BSF    03.5
0A98:  MOVWF  20
0A99:  MOVLW  02
0A9A:  MOVWF  21
0A9B:  MOVLW  03
0A9C:  MOVWF  22
0A9D:  MOVLW  04
0A9E:  MOVWF  23
0A9F:  MOVLW  05
0AA0:  MOVWF  24
0AA1:  MOVLW  06
0AA2:  MOVWF  25
0AA3:  MOVLW  07
0AA4:  MOVWF  26
0AA5:  MOVLW  08
0AA6:  MOVWF  27
0AA7:  MOVLW  09
0AA8:  MOVWF  28
0AA9:  MOVLW  0A
0AAA:  MOVWF  29
0AAB:  MOVLW  0B
0AAC:  MOVWF  2A
0AAD:  MOVLW  0C
0AAE:  MOVWF  2B
0AAF:  MOVLW  0D
0AB0:  MOVWF  2C
0AB1:  MOVLW  0E
0AB2:  MOVWF  2D
0AB3:  MOVLW  0F
0AB4:  MOVWF  2E
0AB5:  MOVLW  10
0AB6:  MOVWF  2F
....................  
....................  
....................  
.................... ///////// 
.................... ///     Check RFID Hardware 
.................... ///////// 
....................  
.................... void CheckRFIDHardware() { 
....................  
....................     char version; ///Version of RFID read/writer is stored 0x92 is version 2.0 
....................     ///Version 1.0 is 0x91 
....................  
....................     lcd_putc("\f Checking RFID..."); 
*
04CD:  MOVLW  04
04CE:  BSF    03.6
04CF:  MOVWF  0D
04D0:  MOVLW  00
04D1:  MOVWF  0F
04D2:  BCF    03.6
04D3:  CALL   285
....................     printf("\r\nChecking If Rfid Is Connected"); 
04D4:  MOVLW  0E
04D5:  BSF    03.6
04D6:  MOVWF  0D
04D7:  MOVLW  00
04D8:  MOVWF  0F
04D9:  BCF    03.6
04DA:  CALL   2F9
....................  
....................     //Request from the register 
....................     version = readFromRegister(VersionReg); 
04DB:  MOVLW  37
04DC:  BSF    03.5
04DD:  MOVWF  57
04DE:  BCF    03.5
04DF:  CALL   390
04E0:  MOVF   78,W
04E1:  BSF    03.5
04E2:  MOVWF  31
....................     delay_ms(100); 
04E3:  MOVLW  64
04E4:  MOVWF  54
04E5:  BCF    03.5
04E6:  CALL   104
....................  
....................  
....................     //response is 00 then hardware is not connected 
....................     if (!version) { 
04E7:  BSF    03.5
04E8:  MOVF   31,F
04E9:  BTFSS  03.2
04EA:  GOTO   504
....................         lcd_putc("\f RFID Not Found \n Check Again.."); 
04EB:  MOVLW  1E
04EC:  BCF    03.5
04ED:  BSF    03.6
04EE:  MOVWF  0D
04EF:  MOVLW  00
04F0:  MOVWF  0F
04F1:  BCF    03.6
04F2:  CALL   285
....................         printf("\r\nRFID Hw not Found"); 
04F3:  MOVLW  2F
04F4:  BSF    03.6
04F5:  MOVWF  0D
04F6:  MOVLW  00
04F7:  MOVWF  0F
04F8:  BCF    03.6
04F9:  CALL   2F9
....................         delay_ms(5000); 
04FA:  MOVLW  14
04FB:  BSF    03.5
04FC:  MOVWF  32
04FD:  MOVLW  FA
04FE:  MOVWF  54
04FF:  BCF    03.5
0500:  CALL   104
0501:  BSF    03.5
0502:  DECFSZ 32,F
0503:  GOTO   4FD
....................     } 
....................     if (version) { 
0504:  MOVF   31,F
0505:  BTFSC  03.2
0506:  GOTO   5DB
....................         lcd_putc("\f RFID Found"); 
0507:  MOVLW  39
0508:  BCF    03.5
0509:  BSF    03.6
050A:  MOVWF  0D
050B:  MOVLW  00
050C:  MOVWF  0F
050D:  BCF    03.6
050E:  CALL   285
....................         printf(lcd_putc, "\nV: %x", version); 
050F:  MOVLW  40
0510:  BSF    03.6
0511:  MOVWF  0D
0512:  MOVLW  00
0513:  MOVWF  0F
0514:  BCF    03.0
0515:  MOVLW  04
0516:  BSF    03.5
0517:  BCF    03.6
0518:  MOVWF  32
*
058F:  MOVF   31,W
0590:  MOVWF  32
0591:  MOVLW  57
0592:  MOVWF  33
....................         printf("\r\nRFID Found and HW version is: 0x%2X\r\n", version); 
*
05B6:  MOVLW  44
05B7:  BSF    03.6
05B8:  MOVWF  0D
05B9:  MOVLW  00
05BA:  MOVWF  0F
05BB:  BCF    03.0
05BC:  MOVLW  22
05BD:  BSF    03.5
05BE:  BCF    03.6
05BF:  MOVWF  32
05C0:  BCF    03.5
05C1:  CALL   42A
05C2:  BSF    03.5
05C3:  MOVF   31,W
05C4:  MOVWF  32
05C5:  MOVLW  37
05C6:  MOVWF  33
05C7:  BCF    03.5
05C8:  CALL   4A6
05C9:  MOVLW  0D
05CA:  BTFSS  0C.4
05CB:  GOTO   5CA
05CC:  MOVWF  19
05CD:  MOVLW  0A
05CE:  BTFSS  0C.4
05CF:  GOTO   5CE
05D0:  MOVWF  19
....................         delay_ms(1000); 
05D1:  MOVLW  04
05D2:  BSF    03.5
05D3:  MOVWF  32
05D4:  MOVLW  FA
05D5:  MOVWF  54
05D6:  BCF    03.5
05D7:  CALL   104
05D8:  BSF    03.5
05D9:  DECFSZ 32,F
05DA:  GOTO   5D4
....................     } 
05DB:  BCF    03.5
05DC:  BSF    0A.3
05DD:  BCF    0A.4
05DE:  GOTO   2F0 (RETURN)
....................  
.................... } 
....................  
....................  
.................... ////// 
.................... ///     Function to read all the data from the card 
.................... ///     Read all the data from the mifare card and out puts to serial terminal     
.................... ///// 
....................  
.................... void readMifareCard(void) { 
....................  
....................     //s50 has 64 blocks of memory 
....................     for (i = 0; i < 64; i++) { 
*
097E:  CLRF   3E
097F:  MOVF   3E,W
0980:  SUBLW  3F
0981:  BTFSS  03.0
0982:  GOTO   26B
....................         // Try to authenticate each block first with the A key. 
....................         status = authenticate(MF1_AUTHENT1A, i, keyA, serial); 
0983:  MOVLW  60
0984:  BSF    03.5
0985:  MOVWF  31
0986:  BCF    03.5
0987:  MOVF   3E,W
0988:  BSF    03.5
0989:  MOVWF  32
098A:  CLRF   34
098B:  MOVLW  65
098C:  MOVWF  33
098D:  CLRF   36
098E:  MOVLW  39
098F:  MOVWF  35
0990:  BCF    03.5
0991:  CALL   0C4
0992:  MOVF   78,W
0993:  MOVWF  40
....................         if (MI_OK == status) { 
0994:  MOVF   40,F
0995:  BTFSS  03.2
0996:  GOTO   1F0
....................             // printf("Authenticated block 0x%2X with A\r\n",i); 
....................             printf("\r\n"); //a new line each block 
0997:  MOVLW  0D
0998:  BTFSS  0C.4
0999:  GOTO   198
099A:  MOVWF  19
099B:  MOVLW  0A
099C:  BTFSS  0C.4
099D:  GOTO   19C
099E:  MOVWF  19
....................             //now read the block i  
....................             status = readFromTag(i, data); 
099F:  MOVF   3E,W
09A0:  BSF    03.5
09A1:  MOVWF  31
09A2:  CLRF   33
09A3:  MOVLW  41
09A4:  MOVWF  32
09A5:  BCF    03.5
09A6:  CALL   133
09A7:  MOVF   78,W
09A8:  MOVWF  40
....................             if (MI_OK == status) { 
09A9:  MOVF   40,F
09AA:  BTFSS  03.2
09AB:  GOTO   1E6
....................                 for (j = 0; j < 15; j++) { 
09AC:  CLRF   3F
09AD:  MOVF   3F,W
09AE:  SUBLW  0E
09AF:  BTFSS  03.0
09B0:  GOTO   1D4
....................                     printf("0x%2X, ", data[j]); 
09B1:  MOVLW  41
09B2:  ADDWF  3F,W
09B3:  MOVWF  04
09B4:  BCF    03.7
09B5:  MOVF   00,W
09B6:  BSF    03.5
09B7:  MOVWF  31
09B8:  MOVLW  30
09B9:  BCF    03.5
09BA:  BTFSS  0C.4
09BB:  GOTO   1BA
09BC:  MOVWF  19
09BD:  MOVLW  78
09BE:  BTFSS  0C.4
09BF:  GOTO   1BE
09C0:  MOVWF  19
09C1:  BSF    03.5
09C2:  MOVF   31,W
09C3:  MOVWF  32
09C4:  MOVLW  37
09C5:  MOVWF  33
09C6:  BCF    0A.3
09C7:  BCF    03.5
09C8:  CALL   4A6
09C9:  BSF    0A.3
09CA:  MOVLW  2C
09CB:  BTFSS  0C.4
09CC:  GOTO   1CB
09CD:  MOVWF  19
09CE:  MOVLW  20
09CF:  BTFSS  0C.4
09D0:  GOTO   1CF
09D1:  MOVWF  19
09D2:  INCF   3F,F
09D3:  GOTO   1AD
....................                 } 
....................                 printf("0x%2X", data[15]); 
09D4:  MOVLW  30
09D5:  BTFSS  0C.4
09D6:  GOTO   1D5
09D7:  MOVWF  19
09D8:  MOVLW  78
09D9:  BTFSS  0C.4
09DA:  GOTO   1D9
09DB:  MOVWF  19
09DC:  MOVF   50,W
09DD:  BSF    03.5
09DE:  MOVWF  32
09DF:  MOVLW  37
09E0:  MOVWF  33
09E1:  BCF    0A.3
09E2:  BCF    03.5
09E3:  CALL   4A6
09E4:  BSF    0A.3
....................             } else { 
09E5:  GOTO   1EF
....................                 printf("Read failed\r\n"); 
09E6:  MOVLW  58
09E7:  BSF    03.6
09E8:  MOVWF  0D
09E9:  MOVLW  00
09EA:  MOVWF  0F
09EB:  BCF    0A.3
09EC:  BCF    03.6
09ED:  CALL   2F9
09EE:  BSF    0A.3
....................             } 
....................  
....................         } else { 
09EF:  GOTO   269
....................             //try to authenticate with key B 
....................             status = authenticate(MF1_AUTHENT1B, i, keyB, serial); 
09F0:  MOVLW  61
09F1:  BSF    03.5
09F2:  MOVWF  31
09F3:  BCF    03.5
09F4:  MOVF   3E,W
09F5:  BSF    03.5
09F6:  MOVWF  32
09F7:  CLRF   34
09F8:  MOVLW  6B
09F9:  MOVWF  33
09FA:  CLRF   36
09FB:  MOVLW  39
09FC:  MOVWF  35
09FD:  BCF    03.5
09FE:  CALL   0C4
09FF:  MOVF   78,W
0A00:  MOVWF  40
....................             if (MI_OK == status) { 
0A01:  MOVF   40,F
0A02:  BTFSS  03.2
0A03:  GOTO   252
....................                 //printf("Authenticated block 0x%2X with key B",i); 
....................                 printf("\r\n"); //a new line each block 
0A04:  MOVLW  0D
0A05:  BTFSS  0C.4
0A06:  GOTO   205
0A07:  MOVWF  19
0A08:  MOVLW  0A
0A09:  BTFSS  0C.4
0A0A:  GOTO   209
0A0B:  MOVWF  19
....................  
....................                 //read from block 
....................                 status = readFromTag(i, data); 
0A0C:  MOVF   3E,W
0A0D:  BSF    03.5
0A0E:  MOVWF  31
0A0F:  CLRF   33
0A10:  MOVLW  41
0A11:  MOVWF  32
0A12:  BCF    03.5
0A13:  CALL   133
0A14:  MOVF   78,W
0A15:  MOVWF  40
....................  
....................                 if (MI_OK == status) { 
0A16:  MOVF   40,F
0A17:  BTFSS  03.2
0A18:  GOTO   248
....................                     for (j = 0; j < 15; j++) { 
0A19:  CLRF   3F
0A1A:  MOVF   3F,W
0A1B:  SUBLW  0E
0A1C:  BTFSS  03.0
0A1D:  GOTO   236
....................                         printf("%2X, ", data[j]); 
0A1E:  MOVLW  41
0A1F:  ADDWF  3F,W
0A20:  MOVWF  04
0A21:  BCF    03.7
0A22:  MOVF   00,W
0A23:  BSF    03.5
0A24:  MOVWF  31
0A25:  MOVWF  32
0A26:  MOVLW  37
0A27:  MOVWF  33
0A28:  BCF    0A.3
0A29:  BCF    03.5
0A2A:  CALL   4A6
0A2B:  BSF    0A.3
0A2C:  MOVLW  2C
0A2D:  BTFSS  0C.4
0A2E:  GOTO   22D
0A2F:  MOVWF  19
0A30:  MOVLW  20
0A31:  BTFSS  0C.4
0A32:  GOTO   231
0A33:  MOVWF  19
0A34:  INCF   3F,F
0A35:  GOTO   21A
....................                     } 
....................                     printf("%2X, ", data[15]); 
0A36:  MOVF   50,W
0A37:  BSF    03.5
0A38:  MOVWF  32
0A39:  MOVLW  37
0A3A:  MOVWF  33
0A3B:  BCF    0A.3
0A3C:  BCF    03.5
0A3D:  CALL   4A6
0A3E:  BSF    0A.3
0A3F:  MOVLW  2C
0A40:  BTFSS  0C.4
0A41:  GOTO   240
0A42:  MOVWF  19
0A43:  MOVLW  20
0A44:  BTFSS  0C.4
0A45:  GOTO   244
0A46:  MOVWF  19
....................                 } else { 
0A47:  GOTO   251
....................                     printf("Read failed \r\n"); 
0A48:  MOVLW  5F
0A49:  BSF    03.6
0A4A:  MOVWF  0D
0A4B:  MOVLW  00
0A4C:  MOVWF  0F
0A4D:  BCF    0A.3
0A4E:  BCF    03.6
0A4F:  CALL   2F9
0A50:  BSF    0A.3
....................                 } 
....................  
....................             } else { 
0A51:  GOTO   269
....................                 printf("Access denied at block 0x%2X", i); 
0A52:  MOVLW  67
0A53:  BSF    03.6
0A54:  MOVWF  0D
0A55:  MOVLW  00
0A56:  MOVWF  0F
0A57:  BCF    03.0
0A58:  MOVLW  19
0A59:  BSF    03.5
0A5A:  BCF    03.6
0A5B:  MOVWF  32
0A5C:  BCF    0A.3
0A5D:  BCF    03.5
0A5E:  CALL   42A
0A5F:  BSF    0A.3
0A60:  MOVF   3E,W
0A61:  BSF    03.5
0A62:  MOVWF  32
0A63:  MOVLW  37
0A64:  MOVWF  33
0A65:  BCF    0A.3
0A66:  BCF    03.5
0A67:  CALL   4A6
0A68:  BSF    0A.3
....................             } 
....................         } 
0A69:  INCF   3E,F
0A6A:  GOTO   17F
....................     } 
0A6B:  BSF    0A.3
0A6C:  BCF    0A.4
0A6D:  GOTO   3B2 (RETURN)
....................  
....................  
.................... } 
....................  
.................... void writeMifare(void){ 
....................     int block = 4; 
....................  
....................                     status = authenticate(MF1_AUTHENT1A, 2, keyA, serial); 
....................  
....................                     //authenticated with key A 
....................                     if (MI_OK == status) { 
....................                         printf("Authenticated with key A \r\n"); 
....................                         status = writeToTag(2, writeData); 
....................                         if (MI_OK == status) { 
....................                             printf("Write Successful\r\n"); 
....................                         }else{ 
....................                             printf("Write failed\r\n"); 
....................                         } 
....................  
....................  
....................                     } else { 
....................                         //try to authenticate with key b 
....................                         status = authenticate(MF1_AUTHENT1B, 2, keyB, serial); 
....................                         if (MI_OK == status) { 
....................                             printf("Authenticated with key B \r\n"); 
....................                             status = writeToTag(2, writeData); 
....................                             if (MI_OK == status) { 
....................                                 printf("Write Successful\r\n"); 
....................                             }else{ 
....................                                 printf("Write Failed"); 
....................                             } 
....................  
....................                         } else { 
....................                             printf("Couldn't access block 0x%X write failed", 2); 
....................                         } 
....................  
....................                     } 
....................  
....................  
.................... } 
....................  
.................... void main() { 
0A6E:  MOVF   03,W
0A6F:  ANDLW  1F
0A70:  MOVWF  03
0A71:  CLRF   20
0A72:  MOVLW  0C
0A73:  BSF    03.5
0A74:  MOVWF  19
0A75:  MOVLW  A6
0A76:  MOVWF  18
0A77:  MOVLW  90
0A78:  BCF    03.5
0A79:  MOVWF  18
0A7A:  CLRF   72
0A7B:  CLRF   71
0A7C:  MOVLW  FF
0A7D:  MOVWF  73
0A7E:  BSF    03.5
0A7F:  BSF    1F.0
0A80:  BSF    1F.1
0A81:  BSF    1F.2
0A82:  BCF    1F.3
0A83:  MOVLW  07
0A84:  MOVWF  1C
0A85:  BCF    03.7
....................  
....................     //setup spi line  
....................  
....................     setup_spi(SPI_MASTER | SPI_MODE_0 | SPI_CLK_DIV_16); 
*
0AB7:  BCF    03.5
0AB8:  BCF    14.5
0AB9:  BCF    73.5
0ABA:  MOVF   73,W
0ABB:  BSF    03.5
0ABC:  MOVWF  07
0ABD:  BSF    73.4
0ABE:  MOVF   73,W
0ABF:  MOVWF  07
0AC0:  BCF    73.3
0AC1:  MOVF   73,W
0AC2:  MOVWF  07
0AC3:  MOVLW  21
0AC4:  BCF    03.5
0AC5:  MOVWF  14
0AC6:  MOVLW  40
0AC7:  BSF    03.5
0AC8:  MOVWF  14
....................  
....................     delay_ms(20); 
0AC9:  MOVLW  14
0ACA:  MOVWF  54
0ACB:  BCF    0A.3
0ACC:  BCF    03.5
0ACD:  CALL   104
0ACE:  BSF    0A.3
....................  
....................     //init lcd and put some string 
....................     lcd_init(); 
0ACF:  BCF    0A.3
0AD0:  GOTO   1E3
0AD1:  BSF    0A.3
....................  
....................     lcd_putc("\f Starting..."); 
0AD2:  MOVLW  C9
0AD3:  BSF    03.6
0AD4:  MOVWF  0D
0AD5:  MOVLW  00
0AD6:  MOVWF  0F
0AD7:  BCF    0A.3
0AD8:  BCF    03.6
0AD9:  CALL   285
0ADA:  BSF    0A.3
....................  
....................     printf("\r\nstarting.."); //output to terminal     
0ADB:  MOVLW  D0
0ADC:  BSF    03.6
0ADD:  MOVWF  0D
0ADE:  MOVLW  00
0ADF:  MOVWF  0F
0AE0:  BCF    0A.3
0AE1:  BCF    03.6
0AE2:  CALL   2F9
0AE3:  BSF    0A.3
....................  
....................     //initialize RFID Reader 
....................  
....................     delay_ms(100); 
0AE4:  MOVLW  64
0AE5:  BSF    03.5
0AE6:  MOVWF  54
0AE7:  BCF    0A.3
0AE8:  BCF    03.5
0AE9:  CALL   104
0AEA:  BSF    0A.3
....................     MFRC_begin(); 
0AEB:  BCF    0A.3
0AEC:  GOTO   3C9
0AED:  BSF    0A.3
....................  
....................     //check if the card reader is connected. 
....................     CheckRFIDHardware(); 
0AEE:  BCF    0A.3
0AEF:  GOTO   4CD
0AF0:  BSF    0A.3
....................  
....................     /////   
....................  
....................  
....................     while (TRUE) { 
....................  
....................         //         
....................         //      //  Check to see if a Tag was detected 
....................         //     // If yes, then the variable FoundTag will contain "MI_OK" 
....................         FoundTag = requestTag(MF1_REQIDL, TagData); 
0AF1:  MOVLW  26
0AF2:  BSF    03.5
0AF3:  MOVWF  31
0AF4:  CLRF   33
0AF5:  MOVLW  29
0AF6:  MOVWF  32
0AF7:  BCF    0A.3
0AF8:  BCF    03.5
0AF9:  GOTO   6ED
0AFA:  BSF    0A.3
0AFB:  MOVF   78,W
0AFC:  MOVWF  27
....................  
....................         // 
....................         //If found tag 
....................         if (FoundTag == MI_OK) { 
0AFD:  MOVF   27,F
0AFE:  BTFSS  03.2
0AFF:  GOTO   3B5
....................  
....................             printf("\r\nFound Tag: "); 
0B00:  MOVLW  D7
0B01:  BSF    03.6
0B02:  MOVWF  0D
0B03:  MOVLW  00
0B04:  MOVWF  0F
0B05:  BCF    0A.3
0B06:  BCF    03.6
0B07:  CALL   2F9
0B08:  BSF    0A.3
....................  
....................             ReadTag = antiCollision(TagData); 
0B09:  BSF    03.5
0B0A:  CLRF   32
0B0B:  MOVLW  29
0B0C:  MOVWF  31
0B0D:  BCF    0A.3
0B0E:  BCF    03.5
0B0F:  GOTO   71F
0B10:  BSF    0A.3
0B11:  MOVF   78,W
0B12:  MOVWF  28
....................  
....................             ///has tag passed anti collision test? 
....................             if (ReadTag == MI_OK) { 
0B13:  MOVF   28,F
0B14:  BTFSS  03.2
0B15:  GOTO   3B5
....................  
....................                 //then put out UUID  
....................                 for (i = 0; i <= 2; i++) { 
0B16:  CLRF   3E
0B17:  MOVF   3E,W
0B18:  SUBLW  02
0B19:  BTFSS  03.0
0B1A:  GOTO   344
....................                     sprintf(buffer2, "%2X", (TagData[i])); //display version in hexadecimal 
0B1B:  MOVLW  29
0B1C:  ADDWF  3E,W
0B1D:  MOVWF  04
0B1E:  BCF    03.7
0B1F:  MOVF   00,W
0B20:  BSF    03.5
0B21:  MOVWF  31
0B22:  CLRF   72
0B23:  MOVLW  51
0B24:  MOVWF  71
0B25:  MOVF   31,W
0B26:  MOVWF  32
0B27:  MOVLW  37
0B28:  MOVWF  33
0B29:  BCF    0A.3
0B2A:  BCF    03.5
0B2B:  CALL   783
0B2C:  BSF    0A.3
....................                     delay_ms(20); 
0B2D:  MOVLW  14
0B2E:  BSF    03.5
0B2F:  MOVWF  54
0B30:  BCF    0A.3
0B31:  BCF    03.5
0B32:  CALL   104
0B33:  BSF    0A.3
....................                     printf(buffer2); 
0B34:  MOVLW  51
0B35:  MOVWF  04
0B36:  BCF    03.7
0B37:  BCF    0A.3
0B38:  CALL   7A8
0B39:  BSF    0A.3
....................                     printf(", "); 
0B3A:  MOVLW  2C
0B3B:  BTFSS  0C.4
0B3C:  GOTO   33B
0B3D:  MOVWF  19
0B3E:  MOVLW  20
0B3F:  BTFSS  0C.4
0B40:  GOTO   33F
0B41:  MOVWF  19
0B42:  INCF   3E,F
0B43:  GOTO   317
....................                 } 
....................  
....................                 sprintf(buffer2, "%2X", (TagData[i])); //display version in hexadecimal 
0B44:  MOVLW  29
0B45:  ADDWF  3E,W
0B46:  MOVWF  04
0B47:  BCF    03.7
0B48:  MOVF   00,W
0B49:  BSF    03.5
0B4A:  MOVWF  31
0B4B:  CLRF   72
0B4C:  MOVLW  51
0B4D:  MOVWF  71
0B4E:  MOVF   31,W
0B4F:  MOVWF  32
0B50:  MOVLW  37
0B51:  MOVWF  33
0B52:  BCF    0A.3
0B53:  BCF    03.5
0B54:  CALL   783
0B55:  BSF    0A.3
....................                 printf(buffer2); 
0B56:  MOVLW  51
0B57:  MOVWF  04
0B58:  BCF    03.7
0B59:  BCF    0A.3
0B5A:  CALL   7A8
0B5B:  BSF    0A.3
....................  
....................                 memcpy(serial, TagData, 5); 
0B5C:  MOVF   29,W
0B5D:  MOVWF  39
0B5E:  MOVF   2A,W
0B5F:  MOVWF  3A
0B60:  MOVF   2B,W
0B61:  MOVWF  3B
0B62:  MOVF   2C,W
0B63:  MOVWF  3C
0B64:  MOVF   2D,W
0B65:  MOVWF  3D
....................  
....................                 //now get SAK for card version check 
....................                 byte sak = selectTag(serial); 
0B66:  BSF    03.5
0B67:  CLRF   32
0B68:  MOVLW  39
0B69:  MOVWF  31
0B6A:  BCF    03.5
0B6B:  GOTO   06E
0B6C:  MOVF   78,W
0B6D:  BSF    03.5
0B6E:  MOVWF  30
....................  
....................                 printf("\r\nSAK: 0x%2x", sak); 
0B6F:  MOVLW  DE
0B70:  BCF    03.5
0B71:  BSF    03.6
0B72:  MOVWF  0D
0B73:  MOVLW  00
0B74:  MOVWF  0F
0B75:  BCF    03.0
0B76:  MOVLW  09
0B77:  BSF    03.5
0B78:  BCF    03.6
0B79:  MOVWF  32
0B7A:  BCF    0A.3
0B7B:  BCF    03.5
0B7C:  CALL   42A
0B7D:  BSF    0A.3
0B7E:  BSF    03.5
0B7F:  MOVF   30,W
0B80:  MOVWF  32
0B81:  MOVLW  57
0B82:  MOVWF  33
0B83:  BCF    0A.3
0B84:  BCF    03.5
0B85:  CALL   4A6
0B86:  BSF    0A.3
....................  
....................  
....................                 if (UID_FAILED == sak) { 
0B87:  BSF    03.5
0B88:  MOVF   30,F
0B89:  BTFSS  03.2
0B8A:  GOTO   397
....................                     printf("\r\n Failed to read card"); 
0B8B:  MOVLW  E5
0B8C:  BCF    03.5
0B8D:  BSF    03.6
0B8E:  MOVWF  0D
0B8F:  MOVLW  00
0B90:  MOVWF  0F
0B91:  BCF    0A.3
0B92:  BCF    03.6
0B93:  CALL   2F9
0B94:  BSF    0A.3
....................                 }//UID was read incompletely 
0B95:  GOTO   3B5
0B96:  BSF    03.5
....................                 else if (UID_NOT_COMPLETE == sak) { 
0B97:  MOVF   30,W
0B98:  SUBLW  04
0B99:  BTFSS  03.2
0B9A:  GOTO   3A7
....................                     printf("\r\n Incomplete UID"); 
0B9B:  MOVLW  F1
0B9C:  BCF    03.5
0B9D:  BSF    03.6
0B9E:  MOVWF  0D
0B9F:  MOVLW  00
0BA0:  MOVWF  0F
0BA1:  BCF    0A.3
0BA2:  BCF    03.6
0BA3:  CALL   2F9
0BA4:  BSF    0A.3
....................                 } else { 
0BA5:  GOTO   3B5
0BA6:  BSF    03.5
....................                     printf("\r\n Is a Mifare Card"); 
0BA7:  MOVLW  FA
0BA8:  BCF    03.5
0BA9:  BSF    03.6
0BAA:  MOVWF  0D
0BAB:  MOVLW  00
0BAC:  MOVWF  0F
0BAD:  BCF    0A.3
0BAE:  BCF    03.6
0BAF:  CALL   2F9
0BB0:  BSF    0A.3
....................  
....................                     //everything went well so far                         
....................                     //now start reading memory 
....................                     readMifareCard(); 
0BB1:  GOTO   17E
....................                     //writeMifare(); 
....................                     
....................  
....................                     haltTag(); 
0BB2:  BCF    0A.3
0BB3:  GOTO   7C6
0BB4:  BSF    0A.3
....................                      
....................  
....................                 } 
....................  
....................  
....................             } 
....................  
....................  
....................         } 
....................  
....................         delay_ms(2000); 
0BB5:  MOVLW  08
0BB6:  BSF    03.5
0BB7:  MOVWF  31
0BB8:  MOVLW  FA
0BB9:  MOVWF  54
0BBA:  BCF    0A.3
0BBB:  BCF    03.5
0BBC:  CALL   104
0BBD:  BSF    0A.3
0BBE:  BSF    03.5
0BBF:  DECFSZ 31,F
0BC0:  GOTO   3B8
0BC1:  BCF    03.5
0BC2:  GOTO   2F1
....................         //     
....................     } 
....................  
....................     return; 
.................... } 
....................  
0BC3:  SLEEP

Configuration Fuses:
   Word  1: 3F71   XT NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
